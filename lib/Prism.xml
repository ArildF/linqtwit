<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Prism</name>
  </assembly>
  <members>
    <member name="T:Microsoft.Practices.Composite.Modularity.IModuleManager">
      <summary>
            Defines the interface for the service that will retrieve and initialize the application's modules.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.IModuleManager.Run">
      <summary>
            Initializes the modules marked as <see cref="F:Microsoft.Practices.Composite.Modularity.InitializationMode.WhenAvailable" /> on the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.IModuleManager.LoadModule(System.String)">
      <summary>
            Initializes the module on the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" /> with the name <paramref name="moduleName" />.
            </summary>
      <param name="moduleName">Name of the module requested for initialization.</param>
    </member>
    <member name="T:Microsoft.Practices.Composite.Logging.ILoggerFacade">
      <summary>
            Defines a simple logger fa√ßade to be used by the Composite Application Library.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Logging.ILoggerFacade.Log(System.String,Microsoft.Practices.Composite.Logging.Category,Microsoft.Practices.Composite.Logging.Priority)">
      <summary>
            Write a new log entry with the specified category and priority.
            </summary>
      <param name="message">Message body to log.</param>
      <param name="category">Category of the entry.</param>
      <param name="priority">The priority of the entry.</param>
    </member>
    <member name="T:Microsoft.Practices.Composite.Logging.TraceLogger">
      <summary>
            Implementation of <see cref="T:Microsoft.Practices.Composite.Logging.ILoggerFacade" /> that logs to .NET <see cref="T:System.Diagnostics.Trace" /> class.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Logging.TraceLogger.Log(System.String,Microsoft.Practices.Composite.Logging.Category,Microsoft.Practices.Composite.Logging.Priority)">
      <summary>
            Write a new log entry with the specified category and priority.
            </summary>
      <param name="message">Message body to log.</param>
      <param name="category">Category of the entry.</param>
      <param name="priority">The priority of the entry.</param>
    </member>
    <member name="T:Microsoft.Practices.Composite.ServiceLocatorExtensions">
      <summary>
            Defines extension methods for the <see cref="T:Microsoft.Practices.ServiceLocation.ServiceLocator" /> class.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.ServiceLocatorExtensions.TryResolve(Microsoft.Practices.ServiceLocation.IServiceLocator,System.Type)">
      <summary>
            Attempts to resolve specified type from the underlying <see cref="T:Microsoft.Practices.ServiceLocation.IServiceLocator" />.
            </summary>
      <remarks>
            This will return null on any <see cref="T:Microsoft.Practices.ServiceLocation.ActivationException" />.</remarks>
      <param name="locator">Locator to use in resolving.</param>
      <param name="type">Type to resolve.</param>
      <returns>T or null</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.ServiceLocatorExtensions.TryResolve``1(Microsoft.Practices.ServiceLocation.IServiceLocator)">
      <summary>
            Attempts to resolve specified type from the underlying <see cref="T:Microsoft.Practices.ServiceLocation.IServiceLocator" />.
            </summary>
      <remarks>
            This will return null on any <see cref="T:Microsoft.Practices.ServiceLocation.ActivationException" />.</remarks>
      <typeparam name="T">Type to resolve.</typeparam>
      <param name="locator">Locator to use in resolving.</param>
      <returns>T or null</returns>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.ModuleState">
      <summary>
            Defines the states a <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> can be in, with regards to the module loading and initialization process. 
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Modularity.ModuleState.NotStarted">
      <summary>
            Initial state for <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" />s. The <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> is defined, 
            but it has not been loaded, retrieved or initialized yet. 
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Modularity.ModuleState.LoadingTypes">
      <summary>
            The assembly that contains the type of the module is currently being loaded by an instance of a
            <see cref="T:Microsoft.Practices.Composite.Modularity.IModuleTypeLoader" />. 
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Modularity.ModuleState.ReadyForInitialization">
      <summary>
            The assembly that holds the Module is present. This means the type of the <see cref="T:Microsoft.Practices.Composite.Modularity.IModule" /> can be instantiated and initialized. 
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Modularity.ModuleState.Initializing">
      <summary>
            The module is currently Initializing, by the <see cref="T:Microsoft.Practices.Composite.Modularity.IModuleInitializer" /></summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Modularity.ModuleState.Initialized">
      <summary>
            The module is initialized and ready to be used. 
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.ModularityException">
      <summary>
            Base class for exceptions that are thrown because of a problem with modules. 
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModularityException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.ModularityException" /> class.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModularityException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.ModularityException" /> class.
            </summary>
      <param name="message">The exception message.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModularityException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.ModularityException" /> class.
            </summary>
      <param name="message">The exception message.</param>
      <param name="innerException">The inner exception.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModularityException.#ctor(System.String,System.String)">
      <summary>
            Initializes the exception with a particular module and error message.
            </summary>
      <param name="moduleName">The name of the module.</param>
      <param name="message">The error message that explains the reason for the exception.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModularityException.#ctor(System.String,System.String,System.Exception)">
      <summary>
            Initializes the exception with a particular module, error message and inner exception that happened.
            </summary>
      <param name="moduleName">The name of the module.</param>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception, 
            or a <see langword="null" /> reference if no inner exception is specified.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModularityException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance with serialized data.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModularityException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Sets the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with information about the exception.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModularityException.ModuleName">
      <summary>
            Gets or sets the name of the module that this exception refers to.
            </summary>
      <value>The name of the module.</value>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.ModuleTypeLoadingException">
      <summary>
            Exception thrown by <see cref="T:Microsoft.Practices.Composite.Modularity.IModuleManager" /> implementations whenever 
            a module fails to retrieve.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleTypeLoadingException.#ctor">
      <summary>
            Initializes a new instance.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleTypeLoadingException.#ctor(System.String)">
      <summary>
            Initializes a new instance with a specified error message.
            </summary>
      <param name="message">The message that describes the error.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleTypeLoadingException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance with a specified error message 
            and a reference to the inner exception that is the cause of this exception.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="exception">The exception that is the cause of the current exception, 
            or a <see langword="null" /> reference if no inner exception is specified.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleTypeLoadingException.#ctor(System.String,System.String)">
      <summary>
            Initializes the exception with a particular module and error message.
            </summary>
      <param name="moduleName">The name of the module.</param>
      <param name="message">The error message that explains the reason for the exception.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleTypeLoadingException.#ctor(System.String,System.String,System.Exception)">
      <summary>
            Initializes the exception with a particular module, error message and inner exception that happened.
            </summary>
      <param name="moduleName">The name of the module.</param>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception, 
            or a <see langword="null" /> reference if no inner exception is specified.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleTypeLoadingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance with serialized data.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.IModuleCatalogItem">
      <summary>
            Marker interface that allows both <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" />s and <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" />s to be
            added to the <see cref="T:Microsoft.Practices.Composite.Modularity.IModuleCatalog" /> from code and XAML. 
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.ModuleInfo">
      <summary>
            Defines the metadata that describes a module.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInfo.#ctor">
      <summary>
            Initializes a new empty instance of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInfo.#ctor(System.String,System.String,System.String[])">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" />.
            </summary>
      <param name="name">The module's name.</param>
      <param name="type">The module <see cref="T:System.Type" />'s AssemblyQualifiedName.</param>
      <param name="dependsOn">The modules this instance depends on.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInfo.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" />.
            </summary>
      <param name="name">The module's name.</param>
      <param name="type">The module's type.</param>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleInfo.ModuleName">
      <summary>
            Gets or sets the name of the module.
            </summary>
      <value>The name of the module.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleInfo.ModuleType">
      <summary>
            Gets or sets the module <see cref="T:System.Type" />'s AssemblyQualifiedName.
            </summary>
      <value>The type of the module.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleInfo.DependsOn">
      <summary>
            Gets or sets the list of modules that this module depends upon.
            </summary>
      <value>The list of modules that this module depends upon.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleInfo.InitializationMode">
      <summary>
            Specifies on which stage the Module will be initialized.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleInfo.Ref">
      <summary>
            Reference to the location of the module assembly.
            <example>The following are examples of valid <see cref="P:Microsoft.Practices.Composite.Modularity.ModuleInfo.Ref" /> values:
            http://myDomain/ClientBin/MyModules.xap for remote module in Silverlight
            file:///c:/MyProject/Modules/MyModule.dll for a loose DLL in WPF.
            </example></summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleInfo.State">
      <summary>
            Gets or sets the state of the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> with regards to the module loading and initialization process.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElement">
      <summary>
            A configuration element to declare module metadata.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElement.#ctor">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElement" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElement.#ctor(System.String,System.String,System.String,System.Boolean)">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElement" />.
            </summary>
      <param name="assemblyFile">The assembly file where the module is located.</param>
      <param name="moduleType">The type of the module.</param>
      <param name="moduleName">The name of the module.</param>
      <param name="startupLoaded">This attribute specifies whether the module is loaded at startup.</param>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElement.AssemblyFile">
      <summary>
            Gets or sets the assembly file.
            </summary>
      <value>The assembly file.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElement.ModuleType">
      <summary>
            Gets or sets the module type.
            </summary>
      <value>The module's type.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElement.ModuleName">
      <summary>
            Gets or sets the module name.
            </summary>
      <value>The module's name.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElement.StartupLoaded">
      <summary>
            Gets or sets a value indicating whether the module should be loaded at startup.
            </summary>
      <value>A value indicating whether the module should be loaded at startup.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElement.Dependencies">
      <summary>
            Gets or sets the modules this module depends on.
            </summary>
      <value>The names of the modules that this depends on.</value>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroupExtensions">
      <summary>
            Defines extension methods for the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" /> class.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInfoGroupExtensions.AddModule(Microsoft.Practices.Composite.Modularity.ModuleInfoGroup,System.String,System.Type,System.String[])">
      <summary>
            Adds a new module that is statically referenced to the specified module info group.
            </summary>
      <param name="moduleInfoGroup">The group where to add the module info in.</param>
      <param name="moduleName">The name for the module.</param>
      <param name="moduleType">The type for the module. This type should be a descendant of <see cref="T:Microsoft.Practices.Composite.Modularity.IModule" />.</param>
      <param name="dependsOn">The names for the modules that this module depends on.</param>
      <returns>Returns the instance of the passed in module info group, to provide a fluid interface.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInfoGroupExtensions.AddModule(Microsoft.Practices.Composite.Modularity.ModuleInfoGroup,System.Type,System.String[])">
      <summary>
            Adds a new module that is statically referenced to the specified module info group.
            </summary>
      <param name="moduleInfoGroup">The group where to add the module info in.</param>
      <param name="moduleType">The type for the module. This type should be a descendant of <see cref="T:Microsoft.Practices.Composite.Modularity.IModule" />.</param>
      <param name="dependsOn">The names for the modules that this module depends on.</param>
      <returns>Returns the instance of the passed in module info group, to provide a fluid interface.</returns>
      <remarks>The name of the module will be the type name.</remarks>
    </member>
    <member name="T:Microsoft.Practices.Composite.Logging.Category">
      <summary>
            Defines values for the categories used by <see cref="T:Microsoft.Practices.Composite.Logging.ILoggerFacade" />.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Logging.Category.Debug">
      <summary>
            Debug category.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Logging.Category.Exception">
      <summary>
            Exception category.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Logging.Category.Info">
      <summary>
            Informational category.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Logging.Category.Warn">
      <summary>
            Warning category.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Events.IEventSubscription">
      <summary>
             Defines a contract for an event subscription to be used by <see cref="T:Microsoft.Practices.Composite.Events.EventBase" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Events.IEventSubscription.GetExecutionStrategy">
      <summary>
            Gets the execution strategy to publish this event.
            </summary>
      <returns>An <see cref="T:System.Action`1" /> with the execution strategy, or <see langword="null" /> if the <see cref="T:Microsoft.Practices.Composite.Events.IEventSubscription" /> is no longer valid.</returns>
    </member>
    <member name="P:Microsoft.Practices.Composite.Events.IEventSubscription.SubscriptionToken">
      <summary>
            Gets or sets a <see cref="T:Microsoft.Practices.Composite.Events.SubscriptionToken" /> that identifies this <see cref="T:Microsoft.Practices.Composite.Events.IEventSubscription" />.
            </summary>
      <value>A token that identifies this <see cref="T:Microsoft.Practices.Composite.Events.IEventSubscription" />.</value>
    </member>
    <member name="T:Microsoft.Practices.Composite.Events.IDelegateReference">
      <summary>
            Represents a reference to a <see cref="T:System.Delegate" />.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Events.IDelegateReference.Target">
      <summary>
            Gets the referenced <see cref="T:System.Delegate" /> object.
            </summary>
      <value>A <see cref="T:System.Delegate" /> instance if the target is valid; otherwise <see langword="null" />.</value>
    </member>
    <member name="T:Microsoft.Practices.Composite.Events.DelegateReference">
      <summary>
            Represents a reference to a <see cref="T:System.Delegate" /> that may contain a
            <see cref="T:System.WeakReference" /> to the target. This class is used
            internally by the Composite Application Library.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Events.DelegateReference.#ctor(System.Delegate,System.Boolean)">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Events.DelegateReference" />.
            </summary>
      <param name="delegate">The original <see cref="T:System.Delegate" /> to create a reference for.</param>
      <param name="keepReferenceAlive">If <see langword="false" /> the class will create a weak reference to the delegate, allowing it to be garbage collected. Otherwise it will keep a strong reference to the target.</param>
      <exception cref="T:System.ArgumentNullException">If the passed <paramref name="delegate" /> is not assignable to <see cref="T:System.Delegate" />.</exception>
    </member>
    <member name="P:Microsoft.Practices.Composite.Events.DelegateReference.Target">
      <summary>
            Gets the <see cref="T:System.Delegate" /> (the target) referenced by the current <see cref="T:Microsoft.Practices.Composite.Events.DelegateReference" /> object.
            </summary>
      <value>
        <see langword="null" /> if the object referenced by the current <see cref="T:Microsoft.Practices.Composite.Events.DelegateReference" /> object has been garbage collected; otherwise, a reference to the <see cref="T:System.Delegate" /> referenced by the current <see cref="T:Microsoft.Practices.Composite.Events.DelegateReference" /> object.</value>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.IModuleCatalog">
      <summary>
            This is the expected catalog definition for the ModuleManager. 
            The ModuleCatalog holds information about the modules that can be used by the 
            application. Each module is described in a ModuleInfo class, that records the 
            name, type and location of the module. 
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.IModuleCatalog.GetDependentModules(Microsoft.Practices.Composite.Modularity.ModuleInfo)">
      <summary>
            Return the list of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" />s that <paramref name="moduleInfo" /> depends on.
            </summary>
      <param name="moduleInfo">The <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> to get the </param>
      <returns>An enumeration of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> that <paramref name="moduleInfo" /> depends on.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.IModuleCatalog.CompleteListWithDependencies(System.Collections.Generic.IEnumerable{Microsoft.Practices.Composite.Modularity.ModuleInfo})">
      <summary>
            Returns the collection of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" />s that contain both the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" />s in 
            <paramref name="modules" />, but also all the modules they depend on. 
            </summary>
      <param name="modules">The modules to get the dependencies for.</param>
      <returns>
            A collection of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> that contains both all <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" />s in <paramref name="modules" />
            and also all the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> they depend on.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.IModuleCatalog.Initialize">
      <summary>
            Initializes the catalog, which may load and validate the modules.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.IModuleCatalog.Modules">
      <summary>
            Gets all the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> classes that are in the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" />.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog">
      <summary>
            The <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" /> holds information about the modules that can be used by the 
            application. Each module is described in a <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> class, that records the 
            name, type and location of the module. 
            
            It also verifies that the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" /> is internally valid. That means that
            it does not have:
            <list><item>Circular dependencies</item><item>Missing dependencies</item><item>
                    Invalid dependencies, such as a Module that's loaded at startup that depends on a module 
                    that might need to be retrieved.
                </item></list>
            The <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" /> also serves as a baseclass for more specialized Catalogs .
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" /> class.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Practices.Composite.Modularity.ModuleInfo})">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" /> class while providing an 
            initial list of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" />s.
            </summary>
      <param name="modules">The initial list of modules.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.CreateFromXaml(System.IO.Stream)">
      <summary>
            Creates a <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" /> from XAML.
            </summary>
      <param name="xamlStream">
        <see cref="T:System.IO.Stream" /> that contains the XAML declaration of the catalog.</param>
      <returns>An instance of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" /> built from the XAML.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.CreateFromXaml(System.Uri)">
      <summary>
            Creates a <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" /> from a XAML included as an Application Resource.
            </summary>
      <param name="builderResourceUri">Relative <see cref="T:System.Uri" /> that identifies the XAML included as an Application Resource.</param>
      <returns>An instance of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" /> build from the XAML.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.Load">
      <summary>
            Loads the catalog if necessary.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.GetDependentModules(Microsoft.Practices.Composite.Modularity.ModuleInfo)">
      <summary>
            Return the list of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" />s that <paramref name="moduleInfo" /> depends on.
            </summary>
      <remarks>
            If  the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" /> was not yet validated, this method will call <see cref="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.Validate" />.
            </remarks>
      <param name="moduleInfo">The <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> to get the </param>
      <returns>An enumeration of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> that <paramref name="moduleInfo" /> depends on.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.AddModule(Microsoft.Practices.Composite.Modularity.ModuleInfo)">
      <summary>
            Adds a <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> to the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" />.
            </summary>
      <param name="moduleInfo">The <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> to add.</param>
      <returns>The <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" /> for easily adding multiple modules.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.CompleteListWithDependencies(System.Collections.Generic.IEnumerable{Microsoft.Practices.Composite.Modularity.ModuleInfo})">
      <summary>
            Returns a list of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" />s that contain both the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" />s in 
            <paramref name="modules" />, but also all the modules they depend on. 
            </summary>
      <param name="modules">The modules to get the dependencies for.</param>
      <returns>
            A list of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> that contains both all <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" />s in <paramref name="modules" />
            but also all the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> they depend on.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.Validate">
      <summary>
            Validates the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" />.
            </summary>
      <exception cref="T:Microsoft.Practices.Composite.Modularity.ModularityException">When validation of the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" /> fails.</exception>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.AddModule(System.Type,System.String[])">
      <summary>
            Adds a groupless <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> to the catalog.
            </summary>
      <param name="moduleType">
        <see cref="T:System.Type" /> of the module to be added.</param>
      <param name="dependsOn">Collection of module names (<see cref="P:Microsoft.Practices.Composite.Modularity.ModuleInfo.ModuleName" />) of the modules on which the module to be added logically depends on.</param>
      <returns>The same <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" /> instance with the added module.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.AddModule(System.Type,Microsoft.Practices.Composite.Modularity.InitializationMode,System.String[])">
      <summary>
            Adds a groupless <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> to the catalog.
            </summary>
      <param name="moduleType">
        <see cref="T:System.Type" /> of the module to be added.</param>
      <param name="initializationMode">Stage on which the module to be added will be initialized.</param>
      <param name="dependsOn">Collection of module names (<see cref="P:Microsoft.Practices.Composite.Modularity.ModuleInfo.ModuleName" />) of the modules on which the module to be added logically depends on.</param>
      <returns>The same <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" /> instance with the added module.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.AddModule(System.String,System.String,System.String[])">
      <summary>
            Adds a groupless <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> to the catalog.
            </summary>
      <param name="moduleName">Name of the module to be added.</param>
      <param name="moduleType">
        <see cref="T:System.Type" /> of the module to be added.</param>
      <param name="dependsOn">Collection of module names (<see cref="P:Microsoft.Practices.Composite.Modularity.ModuleInfo.ModuleName" />) of the modules on which the module to be added logically depends on.</param>
      <returns>The same <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" /> instance with the added module.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.AddModule(System.String,System.String,Microsoft.Practices.Composite.Modularity.InitializationMode,System.String[])">
      <summary>
            Adds a groupless <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> to the catalog.
            </summary>
      <param name="moduleName">Name of the module to be added.</param>
      <param name="moduleType">
        <see cref="T:System.Type" /> of the module to be added.</param>
      <param name="initializationMode">Stage on which the module to be added will be initialized.</param>
      <param name="dependsOn">Collection of module names (<see cref="P:Microsoft.Practices.Composite.Modularity.ModuleInfo.ModuleName" />) of the modules on which the module to be added logically depends on.</param>
      <returns>The same <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" /> instance with the added module.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.AddModule(System.String,System.String,System.String,Microsoft.Practices.Composite.Modularity.InitializationMode,System.String[])">
      <summary>
            Adds a groupless <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> to the catalog.
            </summary>
      <param name="moduleName">Name of the module to be added.</param>
      <param name="moduleType">
        <see cref="T:System.Type" /> of the module to be added.</param>
      <param name="refValue">Reference to the location of the module to be added assembly.</param>
      <param name="initializationMode">Stage on which the module to be added will be initialized.</param>
      <param name="dependsOn">Collection of module names (<see cref="P:Microsoft.Practices.Composite.Modularity.ModuleInfo.ModuleName" />) of the modules on which the module to be added logically depends on.</param>
      <returns>The same <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" /> instance with the added module.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.Initialize">
      <summary>
            Initializes the catalog, which may load and validate the modules.
            </summary>
      <exception cref="T:Microsoft.Practices.Composite.Modularity.ModularityException">When validation of the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" /> fails, because this method calls <see cref="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.Validate" />.</exception>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.AddGroup(Microsoft.Practices.Composite.Modularity.InitializationMode,System.String,Microsoft.Practices.Composite.Modularity.ModuleInfo[])">
      <summary>
            Creates and adds a <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" /> to the catalog.
            </summary>
      <param name="initializationMode">Stage on which the module group to be added will be initialized.</param>
      <param name="refValue">Reference to the location of the module group to be added.</param>
      <param name="moduleInfos">Collection of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> included in the group.</param>
      <returns>
        <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" /> with the added module group.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.SolveDependencies(System.Collections.Generic.IEnumerable{Microsoft.Practices.Composite.Modularity.ModuleInfo})">
      <summary>
            Checks for cyclic dependencies, by calling the dependencysolver. 
            </summary>
      <param name="modules">the.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.ValidateDependencies(System.Collections.Generic.IEnumerable{Microsoft.Practices.Composite.Modularity.ModuleInfo})">
      <summary>
            Ensures that all the dependencies within <paramref name="modules" /> refer to <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" />s
            within that list.
            </summary>
      <param name="modules">The modules to validate modules for.</param>
      <exception cref="T:Microsoft.Practices.Composite.Modularity.ModularityException">
            Throws if a <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> in <paramref name="modules" /> depends on a module that's 
            not in <paramref name="modules" />.
            </exception>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.InnerLoad">
      <summary>
            Does the actual work of loading the catalog.  The base implementation does nothing.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.Sort(System.Collections.Generic.IEnumerable{Microsoft.Practices.Composite.Modularity.ModuleInfo})">
      <summary>
            Sorts a list of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" />s. This method is called by <see cref="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.CompleteListWithDependencies(System.Collections.Generic.IEnumerable{Microsoft.Practices.Composite.Modularity.ModuleInfo})" />
            to return a sorted list. 
            </summary>
      <param name="modules">The <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" />s to sort.</param>
      <returns>Sorted list of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" />s</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.ValidateUniqueModules">
      <summary>
            Makes sure all modules have an Unique name. 
            </summary>
      <exception cref="T:Microsoft.Practices.Composite.Modularity.DuplicateModuleException">
            Thrown if the names of one or more modules are not unique. 
            </exception>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.ValidateDependencyGraph">
      <summary>
            Ensures that there are no cyclic dependencies. 
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.ValidateCrossGroupDependencies">
      <summary>
            Ensures that there are no dependencies between modules on different groups.
            </summary>
      <remarks>
            A groupless module can only depend on other groupless modules.
            A module within a group can depend on other modules within the same group and/or on groupless modules.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.ValidateDependenciesInitializationMode">
      <summary>
            Ensures that there are no modules marked to be loaded <see cref="F:Microsoft.Practices.Composite.Modularity.InitializationMode.WhenAvailable" />
            depending on modules loaded <see cref="F:Microsoft.Practices.Composite.Modularity.InitializationMode.OnDemand" /></summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.GetDependentModulesInner(Microsoft.Practices.Composite.Modularity.ModuleInfo)">
      <summary>
            Returns the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> on which the received module dependens on.
            </summary>
      <param name="moduleInfo">Module whose dependant modules are requested.</param>
      <returns>Collection of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> dependants of <paramref name="moduleInfo" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleCatalog.EnsureCatalogValidated">
      <summary>
            Ensures that the catalog is validated.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleCatalog.Items">
      <summary>
            Gets the items in the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" />. This property is mainly used to add <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" />s or 
            <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" />s through XAML. 
            </summary>
      <value>The items in the catalog.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleCatalog.Modules">
      <summary>
            Gets all the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> classes that are in the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" />, regardless 
            if they are within a <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" /> or not. 
            </summary>
      <value>The modules.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleCatalog.Groups">
      <summary>
            Gets the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" />s that have been added to the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" />. 
            </summary>
      <value>The groups.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleCatalog.Validated">
      <summary>
            Gets or sets a value that remembers whether the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" /> has been validated already. 
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleCatalog.GrouplessModules">
      <summary>
            Returns the list of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" />s that are not contained within any <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" />. 
            </summary>
      <value>The groupless modules.</value>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.ConfigurationModuleCatalog">
      <summary>
            A catalog built from a configuration file.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ConfigurationModuleCatalog.#ctor">
      <summary>
            Builds an instance of ConfigurationModuleCatalog with a <see cref="T:Microsoft.Practices.Composite.Modularity.ConfigurationStore" /> as the default store.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ConfigurationModuleCatalog.InnerLoad">
      <summary>
            Loads the catalog from the configuration.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ConfigurationModuleCatalog.Store">
      <summary>
            Gets or sets the store where the configuration is kept.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Regions.IRegionManager">
      <summary>
            Defines an interface to manage a set of <see cref="T:Microsoft.Practices.Composite.Regions.IRegion">regions</see> and to attach regions to objects (typically controls).
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Regions.IRegionManager.CreateRegionManager">
      <summary>
            Creates a new region manager.
            </summary>
      <returns>A new region manager that can be used as a different scope from the current region manager.</returns>
    </member>
    <member name="P:Microsoft.Practices.Composite.Regions.IRegionManager.Regions">
      <summary>
            Gets a collection of <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> that identify each region by name. You can use this collection to add or remove regions to the current region manager.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Regions.ViewRegisteredEventArgs">
      <summary>
            Argument class used by the <see cref="E:Microsoft.Practices.Composite.Regions.IRegionViewRegistry.ContentRegistered" /> event when a new content is registered.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Regions.ViewRegisteredEventArgs.#ctor(System.String,System.Func{System.Object})">
      <summary>
            Initializes the ViewRegisteredEventArgs class.
            </summary>
      <param name="regionName">The region name to which the content was registered.</param>
      <param name="getViewDelegate">The content which was registered.</param>
    </member>
    <member name="P:Microsoft.Practices.Composite.Regions.ViewRegisteredEventArgs.RegionName">
      <summary>
            Gets the region name to which the content was registered.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Regions.ViewRegisteredEventArgs.GetView">
      <summary>
            Gets the content which was registered.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.ListDictionary`2">
      <summary>
            A dictionary of lists.
            </summary>
      <typeparam name="TKey">The key to use for lists.</typeparam>
      <typeparam name="TValue">The type of the value held by lists.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.Composite.ListDictionary`2.Add(`0)">
      <summary>
            If a list does not already exist, it will be created automatically.
            </summary>
      <param name="key">The key of the list that will hold the value.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.ListDictionary`2.Add(`0,`1)">
      <summary>
            Adds a value to a list with the given key. If a list does not already exist, 
            it will be created automatically.
            </summary>
      <param name="key">The key of the list that will hold the value.</param>
      <param name="value">The value to add to the list under the given key.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.ListDictionary`2.Clear">
      <summary>
            Removes all entries in the dictionary.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.ListDictionary`2.ContainsValue(`1)">
      <summary>
            Determines whether the dictionary contains the specified value.
            </summary>
      <param name="value">The value to locate.</param>
      <returns>true if the dictionary contains the value in any list; otherwise, false.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.ListDictionary`2.ContainsKey(`0)">
      <summary>
            Determines whether the dictionary contains the given key.
            </summary>
      <param name="key">The key to locate.</param>
      <returns>true if the dictionary contains the given key; otherwise, false.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.ListDictionary`2.FindAllValuesByKey(System.Predicate{`0})">
      <summary>
            Retrieves the all the elements from the list which have a key that matches the condition 
            defined by the specified predicate.
            </summary>
      <param name="keyFilter">The filter with the condition to use to filter lists by their key.</param>
      <returns>The elements that have a key that matches the condition defined by the specified predicate.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.ListDictionary`2.FindAllValues(System.Predicate{`1})">
      <summary>
            Retrieves all the elements that match the condition defined by the specified predicate.
            </summary>
      <param name="valueFilter">The filter with the condition to use to filter values.</param>
      <returns>The elements that match the condition defined by the specified predicate.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.ListDictionary`2.Remove(`0)">
      <summary>
            Removes a list by key.
            </summary>
      <param name="key">The key of the list to remove.</param>
      <returns>
        <see langword="true" /> if the element was removed.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.ListDictionary`2.Remove(`0,`1)">
      <summary>
            Removes a value from the list with the given key.
            </summary>
      <param name="key">The key of the list where the value exists.</param>
      <param name="value">The value to remove.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.ListDictionary`2.Remove(`1)">
      <summary>
            Removes a value from all lists where it may be found.
            </summary>
      <param name="value">The value to remove.</param>
    </member>
    <member name="P:Microsoft.Practices.Composite.ListDictionary`2.Values">
      <summary>
            Gets a shallow copy of all values in all lists.
            </summary>
      <value>List of values.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.ListDictionary`2.Keys">
      <summary>
            Gets the list of keys in the dictionary.
            </summary>
      <value>Collection of keys.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.ListDictionary`2.Item(`0)">
      <summary>
            Gets or sets the list associated with the given key. The 
            access always succeeds, eventually returning an empty list.
            </summary>
      <param name="key">The key of the list to access.</param>
      <returns>The list associated with the key.</returns>
    </member>
    <member name="P:Microsoft.Practices.Composite.ListDictionary`2.Count">
      <summary>
            Gets the number of lists in the dictionary.
            </summary>
      <value>Value indicating the values count.</value>
    </member>
    <member name="T:Microsoft.Practices.Composite.Events.IEventAggregator">
      <summary>
            Defines an interface to get instances of an event type.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Events.IEventAggregator.GetEvent``1">
      <summary>
            Gets an instance of an event type.
            </summary>
      <typeparam name="TEventType">The type of event to get.</typeparam>
      <returns>An instance of an event object of type <typeparamref name="TEventType" />.</returns>
    </member>
    <member name="T:Microsoft.Practices.Composite.Regions.IRegionAdapter">
      <summary>
            Defines an interfaces to adapt an object and bind it to a new <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Regions.IRegionAdapter.Initialize(System.Object,System.String)">
      <summary>
            Adapts an object and binds it to a new <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" />.
            </summary>
      <param name="regionTarget">The object to adapt.</param>
      <param name="regionName">The name of the region to be created.</param>
      <returns>The new instance of <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> that the <paramref name="regionTarget" /> is bound to.</returns>
    </member>
    <member name="T:Microsoft.Practices.Composite.Logging.EmptyLogger">
      <summary>
            Implementation of <see cref="T:Microsoft.Practices.Composite.Logging.ILoggerFacade" /> that does nothing. This
            implementation is useful when the application does not need logging
            but there are infrastructure pieces that assume there is a logger.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Logging.EmptyLogger.Log(System.String,Microsoft.Practices.Composite.Logging.Category,Microsoft.Practices.Composite.Logging.Priority)">
      <summary>
            This method does nothing.
            </summary>
      <param name="message">Message body to log.</param>
      <param name="category">Category of the entry.</param>
      <param name="priority">The priority of the entry.</param>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.ModuleInitializeException">
      <summary>
            Exception thrown by <see cref="T:Microsoft.Practices.Composite.Modularity.IModuleInitializer" /> implementations whenever 
            a module fails to load.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInitializeException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance with serialized data.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInitializeException.#ctor">
      <summary>
            Initializes a new instance.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInitializeException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInitializeException" /> class.
            </summary>
      <param name="message">The exception message.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInitializeException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInitializeException" /> class.
            </summary>
      <param name="message">The exception message.</param>
      <param name="innerException">The inner exception.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInitializeException.#ctor(System.String,System.String,System.String)">
      <summary>
            Initializes the exception with a particular module and error message.
            </summary>
      <param name="moduleName">The name of the module.</param>
      <param name="moduleAssembly">The assembly where the module is located.</param>
      <param name="message">The error message that explains the reason for the exception.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInitializeException.#ctor(System.String,System.String,System.String,System.Exception)">
      <summary>
            Initializes the exception with a particular module, error message and inner exception 
            that happened.
            </summary>
      <param name="moduleName">The name of the module.</param>
      <param name="moduleAssembly">The assembly where the module is located.</param>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception, 
            or a <see langword="null" /> reference if no inner exception is specified.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInitializeException.#ctor(System.String,System.String,System.Exception)">
      <summary>
            Initializes the exception with a particular module, error message and inner exception that happened.
            </summary>
      <param name="moduleName">The name of the module.</param>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception, 
            or a <see langword="null" /> reference if no inner exception is specified.</param>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.CyclicDependencyFoundException">
      <summary>
            Represents the exception that is thrown when there is a circular dependency
            between modules during the module loading process.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.CyclicDependencyFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.CyclicDependencyFoundException" /> class
            with the serialization data.
            </summary>
      <param name="info">Holds the serialized object data about the exception being thrown.</param>
      <param name="context">Contains contextual information about the source or destination.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.CyclicDependencyFoundException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.CyclicDependencyFoundException" /> class.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.CyclicDependencyFoundException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.CyclicDependencyFoundException" /> class
            with the specified error message.
            </summary>
      <param name="message">The message that describes the error.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.CyclicDependencyFoundException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.CyclicDependencyFoundException" /> class
            with the specified error message and inner exception.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.CyclicDependencyFoundException.#ctor(System.String,System.String,System.Exception)">
      <summary>
            Initializes the exception with a particular module, error message and inner exception that happened.
            </summary>
      <param name="moduleName">The name of the module.</param>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception, 
            or a <see langword="null" /> reference if no inner exception is specified.</param>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.ModuleDependencySolver">
      <summary>
            Used by <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInitializer" /> to get the load sequence
            for the modules to load according to their dependencies.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleDependencySolver.AddModule(System.String)">
      <summary>
            Adds a module to the solver.
            </summary>
      <param name="name">The name that uniquely identifies the module.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleDependencySolver.AddDependency(System.String,System.String)">
      <summary>
            Adds a module dependency between the modules specified by dependingModule and
            dependentModule.
            </summary>
      <param name="dependingModule">The name of the module with the dependency.</param>
      <param name="dependentModule">The name of the module dependingModule
            depends on.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleDependencySolver.Solve">
      <summary>
            Calculates an ordered vector according to the defined dependencies.
            Non-dependant modules appears at the beginning of the resulting array.
            </summary>
      <returns>The resulting ordered list of modules.</returns>
      <exception cref="T:Microsoft.Practices.Composite.Modularity.CyclicDependencyFoundException">This exception is thrown
            when a cycle is found in the defined depedency graph.</exception>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleDependencySolver.ModuleCount">
      <summary>
            Gets the number of modules added to the solver.
            </summary>
      <value>The number of modules.</value>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.ModuleTypeLoaderNotFoundException">
      <summary>
            Exception that's thrown when there is no <see cref="T:Microsoft.Practices.Composite.Modularity.IModuleTypeLoader" /> registered in 
            <see cref="P:Microsoft.Practices.Composite.Modularity.ModuleManager.ModuleTypeLoaders" /> that can handle this particular type of module. 
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleTypeLoaderNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance with serialized data.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleTypeLoaderNotFoundException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleTypeLoaderNotFoundException" /> class.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleTypeLoaderNotFoundException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleTypeLoaderNotFoundException" /> class with a specified error message.
            </summary>
      <param name="message">
            The message that describes the error. 
            </param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleTypeLoaderNotFoundException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleTypeLoaderNotFoundException" /> class with a specified error message.
            </summary>
      <param name="message">
            The message that describes the error. 
            </param>
      <param name="innerException">The inner exception</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleTypeLoaderNotFoundException.#ctor(System.String,System.String,System.Exception)">
      <summary>
            Initializes the exception with a particular module, error message and inner exception that happened.
            </summary>
      <param name="moduleName">The name of the module.</param>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception, 
            or a <see langword="null" /> reference if no inner exception is specified.</param>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.DuplicateModuleException">
      <summary>
            Exception thrown when a module is declared twice in the same catalog.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.DuplicateModuleException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.DuplicateModuleException" /> class.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.DuplicateModuleException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.DuplicateModuleException" /> class.
            </summary>
      <param name="message">The exception message.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.DuplicateModuleException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.DuplicateModuleException" /> class.
            </summary>
      <param name="message">The exception message.</param>
      <param name="innerException">The inner exception.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.DuplicateModuleException.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.DuplicateModuleException" /> class with a specified error message.
            </summary>
      <param name="moduleName">The name of the module.</param>
      <param name="message">The message that describes the error.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.DuplicateModuleException.#ctor(System.String,System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.DuplicateModuleException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
      <param name="moduleName">The name of the module.</param>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.DuplicateModuleException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.DuplicateModuleException" /> class
            with the serialization data.
            </summary>
      <param name="info">Holds the serialized object data about the exception being thrown.</param>
      <param name="context">Contains contextual information about the source or destination.</param>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.DirectoryModuleCatalog">
      <summary>
            Represets a catalog created from a directory on disk.
            </summary>
      <remarks>
            The directory catalog will scan the contents of a directory, locating classes that implement
            <see cref="T:Microsoft.Practices.Composite.Modularity.IModule" /> and add them to the catalog based on contents in their associated <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleAttribute" />.
            Assemblies are loaded into a new application domain with ReflectionOnlyLoad.  The application domain is destroyed
            once the assemblies have been discovered.
            
            The diretory catalog does not continue to monitor the directory after it has created the initialze catalog.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.DirectoryModuleCatalog.InnerLoad">
      <summary>
            Drives the main logic of building the child domain and searching for the assemblies.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.DirectoryModuleCatalog.BuildChildDomain(System.AppDomain)">
      <summary>
            Creates a new child domain and copies the evidence from a parent domain.
            </summary>
      <param name="parentDomain">The parent domain.</param>
      <returns>The new child domain.</returns>
      <remarks>
            Grabs the <paramref name="parentDomain" /> evidence and uses it to construct the new
            <see cref="T:System.AppDomain" /> because in a ClickOnce execution environment, creating an
            <see cref="T:System.AppDomain" /> will by default pick up the partial trust environment of 
            the AppLaunch.exe, which was the root executable. The AppLaunch.exe does a 
            create domain and applies the evidence from the ClickOnce manifests to 
            create the domain that the application is actually executing in. This will 
            need to be Full Trust for Composite Application Library applications.
            </remarks>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.DirectoryModuleCatalog.ModulePath">
      <summary>
            Directory containing modules to search for.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.ModulesConfigurationSection">
      <summary>
            A <see cref="T:System.Configuration.ConfigurationSection" /> for module configuration.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModulesConfigurationSection.Modules">
      <summary>
            Gets or sets the collection of modules configuration.
            </summary>
      <value>A <seealso cref="T:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElementCollection" /> of <seealso cref="T:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElement" />.</value>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElementCollection">
      <summary>
            A collection of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElement" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElementCollection.#ctor">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElementCollection" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElementCollection.#ctor(Microsoft.Practices.Composite.Modularity.ModuleConfigurationElement[])">
      <summary>
            Initializes a new <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElementCollection" />.
            </summary>
      <param name="modules">The initial set of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElement" />.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElementCollection.Add(Microsoft.Practices.Composite.Modularity.ModuleConfigurationElement)">
      <summary>
            Adds a <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElement" /> to the collection.
            </summary>
      <param name="module">A <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElement" /> instance.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElementCollection.Contains(System.String)">
      <summary>
            Tests if the collection contains the configuration for the specified module name.
            </summary>
      <param name="moduleName">The name of the module to search the configuration for.</param>
      <returns>
        <see langword="true" /> if a configuration for the module is present; otherwise <see langword="false" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElementCollection.FindAll(System.Predicate{Microsoft.Practices.Composite.Modularity.ModuleConfigurationElement})">
      <summary>
            Searches the collection for all the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElement" /> that match the specified predicate.
            </summary>
      <param name="match">A <see cref="T:System.Predicate`1" /> that implements the match test.</param>
      <returns>A <see cref="T:System.Collections.Generic.List`1" /> with the successful matches.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElementCollection.CreateNewElement">
      <summary>
            Creates a new <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElement" />.
            </summary>
      <returns>A <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElement" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElementCollection.GetElementKey(System.Configuration.ConfigurationElement)">
      <summary>
            Gets the element key for a specified configuration element when overridden in a derived class.
            </summary>
      <param name="element">The <see cref="T:System.Configuration.ConfigurationElement" /> to return the key for. </param>
      <returns>
            An <see cref="T:System.Object" /> that acts as the key for the specified <see cref="T:System.Configuration.ConfigurationElement" />.
            </returns>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElementCollection.ThrowOnDuplicate">
      <summary>
            Gets a value indicating whether an exception should be raised if a duplicate element is found.
            This property will always return true.
            </summary>
      <value>A <see cref="T:System.Boolean" /> value.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElementCollection.CollectionType">
      <summary>
            Gets the type of the <see cref="T:System.Configuration.ConfigurationElementCollection" />.
            </summary>
      <value>
            The <see cref="T:System.Configuration.ConfigurationElementCollectionType" /> of this collection.
            </value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElementCollection.ElementName">
      <summary>
            Gets the name used to identify this collection of elements in the configuration file when overridden in a derived class.
            </summary>
      <value>
            The name of the collection; otherwise, an empty string.
            </value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElementCollection.Item(System.Int32)">
      <summary>
            Gets the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElement" /> located at the specified index in the collection.
            </summary>
      <param name="index">The index of the element in the collection.</param>
      <returns>A <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleConfigurationElement" />.</returns>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.ModuleAttribute">
      <summary>
            Indicates that the class should be considered a named module using the
            provided module name.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleAttribute.ModuleName">
      <summary>
            Gets or sets the name of the module.
            </summary>
      <value>The name of the module.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleAttribute.StartupLoaded">
      <summary>
            Gets or sets a value indicating whether the module should be loaded at startup. 
            </summary>
            When <see langword="true" /> (default value), it indicates that this module should be loaded at startup. 
            Otherwise you should explicitly load this module on demand.
            <value>A <see cref="T:System.Boolean" /> value.</value></member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleAttribute.OnDemand">
      <summary>
            Gets or sets the value indicating whether the module should be loaded OnDemand.
            </summary>
            When <see langword="false" /> (default value), it indicates the module should be loaded as soon as it's dependencies are satisfied.
            Otherwise you should explicitily load this module via the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleManager" />.
        </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.IAssemblyResolver">
      <summary>
            Interface for classes that are responsible for resolving and loading assembly files. 
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.IAssemblyResolver.LoadAssemblyFrom(System.String)">
      <summary>
            Load an assembly when it's required by the application. 
            </summary>
      <param name="assemblyFilePath">
      </param>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.AssemblyResolver">
      <summary>
            Handles AppDomain's AssemblyResolve event to be able to load assemblies dynamically in 
            the LoadFrom context, but be able to reference the type from assemblies loaded in the Load context.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.AssemblyResolver.LoadAssemblyFrom(System.String)">
      <summary>
            Registers the specified assembly and resolves the types in it when the AppDomain requests for it.
            </summary>
      <param name="assemblyFilePath">The path to the assemly to load in the LoadFrom context.</param>
      <remarks>This method does not load the assembly immediately, but lazily until someone requests a <see cref="T:System.Type" />
            declared in the assembly.</remarks>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.AssemblyResolver.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
      <remarks>Calls <see cref="M:Microsoft.Practices.Composite.Modularity.AssemblyResolver.Dispose(System.Boolean)" /></remarks>.
            <filterpriority>2</filterpriority></member>
    <member name="M:Microsoft.Practices.Composite.Modularity.AssemblyResolver.Dispose(System.Boolean)">
      <summary>
            Disposes the associated <see cref="T:Microsoft.Practices.Composite.Modularity.AssemblyResolver" />.
            </summary>
      <param name="disposing">When <see langword="true" />, it is being called from the Dispose method.</param>
    </member>
    <member name="T:Microsoft.Practices.Composite.IActiveAware">
      <summary>
            Interface that defines if the object instance is active
            and notifies when the activity changes.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.IActiveAware.IsActive">
      <summary>
            Gets or sets a value indicating whether the object is active.
            </summary>
      <value>
        <see langword="true" /> if the object is active; otherwise <see langword="false" />.</value>
    </member>
    <member name="E:Microsoft.Practices.Composite.IActiveAware.IsActiveChanged">
      <summary>
            Notifies that the value for <see cref="P:Microsoft.Practices.Composite.IActiveAware.IsActive" /> property has changed.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Events.DataEventArgs`1">
      <summary>
            Generic arguments class to pass to event handlers that need to receive data.
            </summary>
      <typeparam name="TData">The type of data to pass.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.Composite.Events.DataEventArgs`1.#ctor(`0)">
      <summary>
            Initializes the DataEventArgs class.
            </summary>
      <param name="value">Information related to the event.</param>
    </member>
    <member name="P:Microsoft.Practices.Composite.Events.DataEventArgs`1.Value">
      <summary>
            Gets the information related to the event.
            </summary>
      <value>Information related to the event.</value>
    </member>
    <member name="T:Microsoft.Practices.Composite.ExceptionExtensions">
      <summary>
            Class that provides extension methods for the Exception class. These extension methods provide
            a mechanism for developers to get more easily to the root cause of an exception, especially in combination with 
            DI-containers such as Unity. 
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.ExceptionExtensions.RegisterFrameworkExceptionType(System.Type)">
      <summary>
            Register the type of an Exception that is thrown by the framework. The <see cref="M:Microsoft.Practices.Composite.ExceptionExtensions.GetRootException(System.Exception)" /> method uses
            this list of Exception types to find out if something has gone wrong.  
            </summary>
      <param name="frameworkExceptionType">The type of exception to register.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.ExceptionExtensions.IsFrameworkExceptionRegistered(System.Type)">
      <summary>
            Determines whether the exception type is already registered using the <see cref="M:Microsoft.Practices.Composite.ExceptionExtensions.RegisterFrameworkExceptionType(System.Type)" /> 
            method
            </summary>
      <param name="frameworkExceptionType">The type of framework exception to find.</param>
      <returns>
        <c>true</c> if the exception type is already registered; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.ExceptionExtensions.GetRootException(System.Exception)">
      <summary>
            Looks at all the inner exceptions of the <paramref name="exception" /> parameter to find the 
            most likely root cause of the exception. This works by skipping all registered exception types.
            </summary>
      <remarks>
            This method is not 100% accurate and should only be used to point a developer into the most likely direction.
            It should not be used to replace the Inner Exception stack of an exception, because this might hide required exception
            information. 
            </remarks>
      <param name="exception">The exception that will provide the list of inner exeptions to examine.</param>
      <returns>
            The exception that most likely caused the exception to occur. If it can't find the root exception, it will return the 
            <paramref name="exception" /> value itself.
            </returns>
    </member>
    <member name="T:Microsoft.Practices.Composite.Regions.IViewsCollection">
      <summary>
            Defines a view of a collection.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Regions.IViewsCollection.Contains(System.Object)">
      <summary>
            Determines whether the collection contains a specific value.
            </summary>
      <param name="value">The object to locate in the collection.</param>
      <returns>
        <see langword="true" /> if <paramref name="value" /> is found in the collection; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="T:Microsoft.Practices.Composite.Regions.IRegionViewRegistry">
      <summary>
            Defines the interface for the registry of region's content.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Regions.IRegionViewRegistry.GetContents(System.String)">
      <summary>
            Returns the contents associated with a region name.
            </summary>
      <param name="regionName">Region name for which contents are requested.</param>
      <returns>Collection of contents associated with the <paramref name="regionName" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Regions.IRegionViewRegistry.RegisterViewWithRegion(System.String,System.Type)">
      <summary>
            Registers a content type with a region name.
            </summary>
      <param name="regionName">Region name to which the <paramref name="viewType" /> will be registered.</param>
      <param name="viewType">Content type to be registered for the <paramref name="regionName" />.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Regions.IRegionViewRegistry.RegisterViewWithRegion(System.String,System.Func{System.Object})">
      <summary>
            Registers a delegate that can be used to retrieve the content associated with a region name. 
            </summary>
      <param name="regionName">Region name to which the <paramref name="getContentDelegate" /> will be registered.</param>
      <param name="getContentDelegate">Delegate used to retrieve the content associated with the <paramref name="regionName" />.</param>
    </member>
    <member name="E:Microsoft.Practices.Composite.Regions.IRegionViewRegistry.ContentRegistered">
      <summary>
            Event triggered when a content is registered to a region name.
            </summary>
      <remarks>
            This event uses weak references to the event handler to prevent this service (typically a singleton) of keeping the
            target element longer than expected. For security reasons, to use weak delegates in Silverlight you must provide
            a delegate that is available in the public API of the class (no private or anonymous delegates allowed).
            </remarks>
    </member>
    <member name="T:Microsoft.Practices.Composite.Regions.IRegionBehavior">
      <summary>
            Interface for allowing extensible behavior on regions.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Regions.IRegionBehavior.Attach">
      <summary>
            Attaches the behavior to the specified region.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Regions.IRegionBehavior.Region">
      <summary>
            The region that this behavior is extending.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.IModule">
      <summary>
            Defines the contract for the modules deployed in the application.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.IModule.Initialize">
      <summary>
            Notifies the module that it has be initialized.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Regions.IRegionCollection">
      <summary>
            Defines a collection of <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> uniquely identified by their Name.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Regions.IRegionCollection.Add(Microsoft.Practices.Composite.Regions.IRegion)">
      <summary>
            Adds a <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> to the collection.
            </summary>
      <param name="region">Region to be added to the collection.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Regions.IRegionCollection.Remove(System.String)">
      <summary>
            Removes a <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> from the collection.
            </summary>
      <param name="regionName">Name of the region to be removed.</param>
      <returns>
        <see langword="true" /> if the region was removed from the collection, otherwise <see langword="false" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Regions.IRegionCollection.ContainsRegionWithName(System.String)">
      <summary>
            Checks if the collection contains a <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> with the name received as parameter.
            </summary>
      <param name="regionName">The name of the region to look for.</param>
      <returns>
        <see langword="true" /> if the region is contained in the collection, otherwise <see langword="false" />.</returns>
    </member>
    <member name="P:Microsoft.Practices.Composite.Regions.IRegionCollection.Item(System.String)">
      <summary>
            Gets the IRegion with the name received as index.
            </summary>
      <param name="regionName">Name of the region to be retrieved.</param>
      <returns>The <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> identified with the requested name.</returns>
    </member>
    <member name="T:Microsoft.Practices.Composite.CollectionExtensions">
      <summary>
            Class that provides extension methods to Collection
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.CollectionExtensions.AddRange``1(System.Collections.ObjectModel.Collection{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Add a range of items to a collection. Note, this method is missing from silverlight. 
            </summary>
      <typeparam name="T">Type of objects within the collection.</typeparam>
      <param name="collection">The collection to add items to.</param>
      <param name="items">The items to add to the collection.</param>
      <returns>The collection.</returns>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.ModuleDependencyConfigurationElement">
      <summary>
            A <see cref="T:System.Configuration.ConfigurationElement" /> for module dependencies.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleDependencyConfigurationElement.#ctor">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleDependencyConfigurationElement" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleDependencyConfigurationElement.#ctor(System.String)">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleDependencyConfigurationElement" />.
            </summary>
      <param name="moduleName">A module name.</param>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleDependencyConfigurationElement.ModuleName">
      <summary>
            Gets or sets the name of a module antoher module depends on.
            </summary>
      <value>The name of a module antoher module depends on.</value>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.ModuleDependencyAttribute">
      <summary>
            Specifies that the current module has a dependency on another module. This attribute should be used on classes that implement <see cref="T:Microsoft.Practices.Composite.Modularity.IModule" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleDependencyAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleDependencyAttribute" />.
            </summary>
      <param name="moduleName">The name of the module that this module is dependant upon.</param>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleDependencyAttribute.ModuleName">
      <summary>
            Gets the name of the module that this module is dependant upon.
            </summary>
      <value>The name of the module that this module is dependant upon.</value>
    </member>
    <member name="T:Microsoft.Practices.Composite.Logging.TextLogger">
      <summary>
            Implementation of <see cref="T:Microsoft.Practices.Composite.Logging.ILoggerFacade" /> that logs into a <see cref="T:System.IO.TextWriter" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Logging.TextLogger.#ctor">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Logging.TextLogger" /> that writes to
            the console output.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Logging.TextLogger.#ctor(System.IO.TextWriter)">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Logging.TextLogger" />.
            </summary>
      <param name="writer">The writer to use for writing log entries.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Logging.TextLogger.Log(System.String,Microsoft.Practices.Composite.Logging.Category,Microsoft.Practices.Composite.Logging.Priority)">
      <summary>
            Write a new log entry with the specified category and priority.
            </summary>
      <param name="message">Message body to log.</param>
      <param name="category">Category of the entry.</param>
      <param name="priority">The priority of the entry.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Logging.TextLogger.Dispose(System.Boolean)">
      <summary>
            Disposes the associated <see cref="T:System.IO.TextWriter" />.
            </summary>
      <param name="disposing">When <see langword="true" />, disposes the associated <see cref="T:System.IO.TextWriter" />.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Logging.TextLogger.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
      <remarks>Calls <see cref="M:Microsoft.Practices.Composite.Logging.TextLogger.Dispose(System.Boolean)" /></remarks>.
            <filterpriority>2</filterpriority></member>
    <member name="T:Microsoft.Practices.Composite.Events.SubscriptionToken">
      <summary>
            Subsription token returned from <see cref="T:Microsoft.Practices.Composite.Events.EventBase" /> on subscribe.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Events.SubscriptionToken.#ctor">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Events.SubscriptionToken" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Events.SubscriptionToken.Equals(Microsoft.Practices.Composite.Events.SubscriptionToken)">
      <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
      <returns>
        <see langword="true" /> if the current object is equal to the <paramref name="other" /> parameter; otherwise, <see langword="false" />.
            </returns>
      <param name="other">An object to compare with this object.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Events.SubscriptionToken.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
            </returns>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />. </param>
      <exception cref="T:System.NullReferenceException">The <paramref name="obj" /> parameter is null.</exception>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:Microsoft.Practices.Composite.Events.SubscriptionToken.GetHashCode">
      <summary>
            Serves as a hash function for a particular type. 
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="T:Microsoft.Practices.Composite.Events.EventAggregator">
      <summary>
            Implements <see cref="T:Microsoft.Practices.Composite.Events.IEventAggregator" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Events.EventAggregator.GetEvent``1">
      <summary>
            Gets the single instance of the event managed by this EventAggregator. Multiple calls to this method with the same <typeparamref name="TEventType" /> returns the same event instance.
            </summary>
      <typeparam name="TEventType">The type of event to get. This must inherit from <see cref="T:Microsoft.Practices.Composite.Events.EventBase" />.</typeparam>
      <returns>A singleton instance of an event object of type <typeparamref name="TEventType" />.</returns>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.ModuleManager">
      <summary>
            Component responsible for coordinating the modules' type loading and module initialization process. 
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleManager.#ctor(Microsoft.Practices.Composite.Modularity.IModuleInitializer,Microsoft.Practices.Composite.Modularity.IModuleCatalog,Microsoft.Practices.Composite.Logging.ILoggerFacade)">
      <summary>
            Initializes an instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleManager" /> class.
            </summary>
      <param name="moduleInitializer">Service used for initialization of modules.</param>
      <param name="moduleCatalog">Catalog that enumerates the modules to be loaded and initialized.</param>
      <param name="loggerFacade">Logger used during the load and initialization of modules.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleManager.Run">
      <summary>
            Initializes the modules marked as <see cref="F:Microsoft.Practices.Composite.Modularity.InitializationMode.WhenAvailable" /> on the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleManager.LoadModule(System.String)">
      <summary>
            Initializes the module on the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" /> with the name <paramref name="moduleName" />.
            </summary>
      <param name="moduleName">Name of the module requested for initialization.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleManager.ModuleNeedsRetrieval(Microsoft.Practices.Composite.Modularity.ModuleInfo)">
      <summary>
            Checks if the module needs to be retrieved before it's initialized.
            </summary>
      <param name="moduleInfo">Module that is being checked if needs retrieval.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleManager.HandleModuleTypeLoadingError(Microsoft.Practices.Composite.Modularity.ModuleInfo,System.Exception)">
      <summary>
            Handles any exception ocurred in the module typeloading process,
            logs the error using the <seealso cref="T:Microsoft.Practices.Composite.Logging.ILoggerFacade" /> and throws a <seealso cref="T:Microsoft.Practices.Composite.Modularity.ModuleTypeLoadingException" />.
            This method can be overriden to provide a different behavior. 
            </summary>
      <param name="moduleInfo">The module metadata where the error happenened.</param>
      <param name="exception">The exception thrown that is the cause of the current error.</param>
      <exception cref="T:Microsoft.Practices.Composite.Modularity.ModuleTypeLoadingException">
      </exception>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleManager.ModuleTypeLoaders">
      <summary>
            Returns the list of registered <see cref="T:Microsoft.Practices.Composite.Modularity.IModuleTypeLoader" /> instances that will be 
            used to load the types of modules. 
            </summary>
      <value>The module type loaders.</value>
    </member>
    <member name="T:Microsoft.Practices.Composite.Regions.IRegionBehaviorCollection">
      <summary>
            Defines the interface for a collection of <see cref="T:Microsoft.Practices.Composite.Regions.IRegionBehavior" /> classes on a Region.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Regions.IRegionBehaviorCollection.Add(System.String,Microsoft.Practices.Composite.Regions.IRegionBehavior)">
      <summary>
            Adds a <see cref="T:Microsoft.Practices.Composite.Regions.IRegionBehavior" /> to the collection, using the specified key as an indexer. 
            </summary>
      <param name="key">
            The key that specifies the type of <see cref="T:Microsoft.Practices.Composite.Regions.IRegionBehavior" /> that's added. 
            </param>
      <param name="regionBehavior">The <see cref="T:Microsoft.Practices.Composite.Regions.IRegionBehavior" /> to add.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Regions.IRegionBehaviorCollection.ContainsKey(System.String)">
      <summary>
            Checks if a <see cref="T:Microsoft.Practices.Composite.Regions.IRegionBehavior" /> with the specified key is already present. 
            </summary>
      <param name="key">The key to use to find a particular <see cref="T:Microsoft.Practices.Composite.Regions.IRegionBehavior" />.</param>
      <returns>
      </returns>
    </member>
    <member name="P:Microsoft.Practices.Composite.Regions.IRegionBehaviorCollection.Item(System.String)">
      <summary>
            Gets the <see cref="T:Microsoft.Practices.Composite.Regions.IRegionBehavior" /> with the specified key.
            </summary>
      <value>The registered <see cref="T:Microsoft.Practices.Composite.Regions.IRegionBehavior" /></value>
    </member>
    <member name="T:Microsoft.Practices.Composite.Properties.Resources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.ConfigurationStoreCannotBeNull">
      <summary>
              Looks up a localized string similar to The ConfigurationStore cannot contain a null value. .
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.CyclicDependencyFound">
      <summary>
              Looks up a localized string similar to At least one cyclic dependency has been found in the module catalog. Cycles in the module dependencies must be avoided..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.DefaultTextLoggerPattern">
      <summary>
              Looks up a localized string similar to {1}: {2}. Priority: {3}. Timestamp:{0:u}..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.DependencyForUnknownModule">
      <summary>
              Looks up a localized string similar to Cannot add dependency for unknown module {0}.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.DependencyOnMissingModule">
      <summary>
              Looks up a localized string similar to A module declared a dependency on another module which is not declared to be loaded. Missing module(s): {0}.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.DirectoryNotFound">
      <summary>
              Looks up a localized string similar to Directory {0} was not found..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.DuplicatedModule">
      <summary>
              Looks up a localized string similar to A duplicated module with name {0} has been found by the loader..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.DuplicatedModuleGroup">
      <summary>
              Looks up a localized string similar to A duplicated module group with name {0} has been found by the loader..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.FailedToGetType">
      <summary>
              Looks up a localized string similar to Unable to retrieve the module type {0} from the loaded assemblies.  You may need to specify a more fully-qualified type name..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.FailedToLoadModule">
      <summary>
              Looks up a localized string similar to An exception occurred while initializing module '{0}'. 
               - The exception message was: {2}
               - The Assembly that the module was trying to be loaded from was:{1}
               Check the InnerException property of the exception for more information. If the exception occurred while creating an object in a DI container, you can exception.GetRootException() to help locate the root cause of the problem. 
             .
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.FailedToLoadModuleNoAssemblyInfo">
      <summary>
              Looks up a localized string similar to An exception occurred while initializing module '{0}'. 
               - The exception message was: {1}
               Check the InnerException property of the exception for more information. If the exception occurred 
               while creating an object in a DI container, you can exception.GetRootException() to help locate the 
               root cause of the problem. .
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.FailedToRetrieveModule">
      <summary>
              Looks up a localized string similar to Failed to load type for module {0}. Error was: {1}..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.IEnumeratorObsolete">
      <summary>
              Looks up a localized string similar to The IModuleEnumerator interface is no longer used and has been replaced by ModuleCatalog..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.InvalidArgumentAssemblyUri">
      <summary>
              Looks up a localized string similar to The argument must be a valid absolute Uri to an assembly file..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.InvalidDelegateRerefenceTypeException">
      <summary>
              Looks up a localized string similar to The Target of the IDelegateReference should be of type {0}..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.ModuleDependenciesNotMetInGroup">
      <summary>
              Looks up a localized string similar to Module {0} depends on other modules that don't belong to the same group..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.ModuleNotFound">
      <summary>
              Looks up a localized string similar to Module {0} was not found in the catalog..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.ModulePathCannotBeNullOrEmpty">
      <summary>
              Looks up a localized string similar to The ModulePath cannot contain a null value or be empty.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.ModuleTypeNotFound">
      <summary>
              Looks up a localized string similar to Failed to load type '{0}' from assembly '{1}'..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.NoRetrieverCanRetrieveModule">
      <summary>
              Looks up a localized string similar to There is currently no moduleTypeLoader in the ModuleManager that can retrieve the specified module..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.RegionManagerWithDifferentNameException">
      <summary>
              Looks up a localized string similar to The region being added already has a name of '{0}' and cannot be added to the region manager with a different name ('{1}')..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.RegionNotFound">
      <summary>
              Looks up a localized string similar to This RegionManager does not contain a Region with the name '{0}'..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.StartupModuleDependsOnAnOnDemandModule">
      <summary>
              Looks up a localized string similar to Module {0} is marked for automatic initialization when the application starts, but it depends on modules that are marked as OnDemand initialization. To fix this error, mark the dependency modules for InitializationMode=WhenAvailable, or remove this validation by extending the ModuleCatalog class..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.StringCannotBeNullOrEmpty">
      <summary>
              Looks up a localized string similar to The provided String argument {0} must not be null or empty..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Properties.Resources.ValueMustBeOfTypeModuleInfo">
      <summary>
              Looks up a localized string similar to The value must be of type ModuleInfo..
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Logging.Priority">
      <summary>
            Defines values for the priorities used by <see cref="T:Microsoft.Practices.Composite.Logging.ILoggerFacade" />.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Logging.Priority.None">
      <summary>
            No priority specified.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Logging.Priority.High">
      <summary>
            High priority entry.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Logging.Priority.Medium">
      <summary>
            Medium priority entry.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Logging.Priority.Low">
      <summary>
            Low priority entry.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Regions.IRegion">
      <summary>
            Defines a model that can be used to compose views.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Regions.IRegion.Add(System.Object)">
      <overloads>Adds a new view to the region.</overloads>
      <summary>
             Adds a new view to the region.
             </summary>
      <param name="view">The view to add.</param>
      <returns>The <see cref="T:Microsoft.Practices.Composite.Regions.IRegionManager" /> that is set on the view if it is a <see cref="T:System.Windows.DependencyObject" />. It will be the current region manager when using this overload.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Regions.IRegion.Add(System.Object,System.String)">
      <summary>
            Adds a new view to the region.
            </summary>
      <param name="view">The view to add.</param>
      <param name="viewName">The name of the view. This can be used to retrieve it later by calling <see cref="M:Microsoft.Practices.Composite.Regions.IRegion.GetView(System.String)" />.</param>
      <returns>The <see cref="T:Microsoft.Practices.Composite.Regions.IRegionManager" /> that is set on the view if it is a <see cref="T:System.Windows.DependencyObject" />. It will be the current region manager when using this overload.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Regions.IRegion.Add(System.Object,System.String,System.Boolean)">
      <summary>
            Adds a new view to the region.
            </summary>
      <param name="view">The view to add.</param>
      <param name="viewName">The name of the view. This can be used to retrieve it later by calling <see cref="M:Microsoft.Practices.Composite.Regions.IRegion.GetView(System.String)" />.</param>
      <param name="createRegionManagerScope">When <see langword="true" />, the added view will receive a new instance of <see cref="T:Microsoft.Practices.Composite.Regions.IRegionManager" />, otherwise it will use the current region manager for this region.</param>
      <returns>The <see cref="T:Microsoft.Practices.Composite.Regions.IRegionManager" /> that is set on the view if it is a <see cref="T:System.Windows.DependencyObject" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Regions.IRegion.Remove(System.Object)">
      <summary>
            Removes the specified view from the region.
            </summary>
      <param name="view">The view to remove.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Regions.IRegion.Activate(System.Object)">
      <summary>
            Marks the specified view as active. 
            </summary>
      <param name="view">The view to activate.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Regions.IRegion.Deactivate(System.Object)">
      <summary>
            Marks the specified view as inactive. 
            </summary>
      <param name="view">The view to deactivate.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Regions.IRegion.GetView(System.String)">
      <summary>
            Returns the view instance that was added to the region using a specific name.
            </summary>
      <param name="viewName">The name used when adding the view to the region.</param>
      <returns>Returns the named view or <see langword="null" /> if the view with <paramref name="viewName" /> does not exist in the current region.</returns>
    </member>
    <member name="P:Microsoft.Practices.Composite.Regions.IRegion.Views">
      <summary>
            Gets a readonly view of the collection of views in the region.
            </summary>
      <value>An <see cref="T:Microsoft.Practices.Composite.Regions.IViewsCollection" /> of all the added views.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Regions.IRegion.ActiveViews">
      <summary>
            Gets a readonly view of the collection of all the active views in the region.
            </summary>
      <value>An <see cref="T:Microsoft.Practices.Composite.Regions.IViewsCollection" /> of all the active views.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Regions.IRegion.Context">
      <summary>
            Gets or sets a context for the region. This value can be used by the user to share context with the views.
            </summary>
      <value>The context value to be shared.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Regions.IRegion.Name">
      <summary>
            Gets the name of the region that uniequely identifies the region within a <see cref="T:Microsoft.Practices.Composite.Regions.IRegionManager" />.
            </summary>
      <value>The name of the region.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Regions.IRegion.RegionManager">
      <summary>
            Gets or sets the <see cref="T:Microsoft.Practices.Composite.Regions.IRegionManager" /> that will be passed to the views when adding them to the region, unless the view is added by specifying createRegionManagerScope as <see langword="true" />.
            </summary>
      <value>The <see cref="T:Microsoft.Practices.Composite.Regions.IRegionManager" /> where this <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> is registered.</value>
      <remarks>This is usually used by implementations of <see cref="T:Microsoft.Practices.Composite.Regions.IRegionManager" /> and should not be
            used by the developer explicitely.</remarks>
    </member>
    <member name="P:Microsoft.Practices.Composite.Regions.IRegion.Behaviors">
      <summary>
                Gets the collection of <see cref="T:Microsoft.Practices.Composite.Regions.IRegionBehavior" />s that can extend the behavior of regions. 
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.InitializationMode">
      <summary>
            Specifies on which stage the Module group will be initialized.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Modularity.InitializationMode.WhenAvailable">
      <summary>
            The module will be initialized when it is available on application start-up.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Modularity.InitializationMode.OnDemand">
      <summary>
            The module will be initialized when requested, and not automatically on application start-up.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.ModuleNotFoundException">
      <summary>
            Exception thrown when a requested <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> is not found.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleNotFoundException" /> class
            with the serialization data.
            </summary>
      <param name="info">Holds the serialized object data about the exception being thrown.</param>
      <param name="context">Contains contextual information about the source or destination.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleNotFoundException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleNotFoundException" /> class.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleNotFoundException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleNotFoundException" /> class with a specified error message.
            </summary>
      <param name="message">
            The message that describes the error. 
            </param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleNotFoundException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleNotFoundException" /> class with a specified error message.
            </summary>
      <param name="message">
            The message that describes the error. 
            </param>
      <param name="innerException">The inner exception</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleNotFoundException.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleNotFoundException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
      <param name="moduleName">The name of the module.</param>
      <param name="message">The error message that explains the reason for the exception.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleNotFoundException.#ctor(System.String,System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleNotFoundException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
      <param name="moduleName">The name of the module.</param>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception, or a null reference if no inner exception is specified.</param>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup">
      <summary>
            Represents a group of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> instances that are usually deployed together. <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" />s 
            are also used by the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleCatalog" /> to prevent common deployment problems such as having a module that's required 
            at startup that depends on modules that will only be downloaded on demand. 
            
            The group also forwards <see cref="P:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup.Ref" /> and <see cref="P:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup.InitializationMode" /> values to the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" />s that it
            contains. 
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup.Add(Microsoft.Practices.Composite.Modularity.ModuleInfo)">
      <summary>
            Adds an <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> moduleInfo to the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" />.
            </summary>
      <param name="item">The <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> to the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" />.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup.ForwardValues(Microsoft.Practices.Composite.Modularity.ModuleInfo)">
      <summary>
            Forwards <see cref="P:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup.InitializationMode" /> and <see cref="P:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup.Ref" /> properties from this <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" />
            to <paramref name="moduleInfo" />.
            </summary>
      <param name="moduleInfo">The module info to forward values to.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup.Clear">
      <summary>
            Removes all <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" />s from the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup.Contains(Microsoft.Practices.Composite.Modularity.ModuleInfo)">
      <summary>
            Determines whether the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" /> contains a specific value.
            </summary>
      <param name="item">The object to locate in the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" />.</param>
      <returns>
            true if <paramref name="item" /> is found in the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" />; otherwise, false.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup.CopyTo(Microsoft.Practices.Composite.Modularity.ModuleInfo[],System.Int32)">
      <summary>
            Copies the elements of the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
      <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> is null.
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="arrayIndex" /> is less than 0.
            </exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" /> is multidimensional.
            -or-
            <paramref name="arrayIndex" /> is equal to or greater than the length of <paramref name="array" />.
            -or-
            The number of elements in the source <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" /> is greater than the available space from <paramref name="arrayIndex" /> to the end of the destination <paramref name="array" />.
            </exception>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup.Remove(Microsoft.Practices.Composite.Modularity.ModuleInfo)">
      <summary>
            Removes the first occurrence of a specific object from the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" />.
            </summary>
      <param name="item">The object to remove from the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" />.</param>
      <returns>
            true if <paramref name="item" /> was successfully removed from the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" />; otherwise, false. This method also returns false if <paramref name="item" /> is not found in the original <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" />.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup.IndexOf(System.Object)">
      <summary>
            Determines the index of a specific item in the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" />.
            </summary>
      <param name="value">
            The <see cref="T:System.Object" /> to locate in the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" />.
            Must be of type <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /></param>
      <returns>
            The index of <paramref name="value" /> if found in the list; otherwise, -1.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup.Insert(System.Int32,System.Object)">
      <summary>
            Inserts an item to the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" /> at the specified index.
            </summary>
      <param name="index">The zero-based index at which <paramref name="value" /> should be inserted.</param>
      <param name="value">
            The <see cref="T:System.Object" /> to insert into the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" />.
            Must be of type <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /></param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not a valid index in the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" />.
            </exception>
      <exception cref="T:System.ArgumentNullException">
            If <paramref name="value" /> is null.
            </exception>
      <exception cref="T:System.ArgumentException">
            If <paramref name="value" /> is not of type <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /></exception>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup.RemoveAt(System.Int32)">
      <summary>
            Removes the <see cref="T:System.Collections.Generic.IList`1" /> item at the specified index.
            </summary>
      <param name="index">The zero-based index of the item to remove.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1" />.
            </exception>
      <exception cref="T:System.NotSupportedException">
            The <see cref="T:System.Collections.Generic.IList`1" /> is read-only.
            </exception>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup.IndexOf(Microsoft.Practices.Composite.Modularity.ModuleInfo)">
      <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1" />.
            </summary>
      <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1" />.</param>
      <returns>
            The index of <paramref name="item" /> if found in the list; otherwise, -1.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup.Insert(System.Int32,Microsoft.Practices.Composite.Modularity.ModuleInfo)">
      <summary>
            Inserts an item to the <see cref="T:System.Collections.Generic.IList`1" /> at the specified index.
            </summary>
      <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
      <param name="item">The object to insert into the <see cref="T:System.Collections.Generic.IList`1" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1" />.
            </exception>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup.InitializationMode">
      <summary>
            Gets or sets the <see cref="P:Microsoft.Practices.Composite.Modularity.ModuleInfo.InitializationMode" /> for the whole group. Any <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> classes that are
            added after setting this value will also get this <see cref="P:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup.InitializationMode" />.
            </summary>
      <seealso cref="P:Microsoft.Practices.Composite.Modularity.ModuleInfo.InitializationMode" />
      <value>The initialization mode.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup.Ref">
      <summary>
            Gets or sets the <see cref="P:Microsoft.Practices.Composite.Modularity.ModuleInfo.Ref" /> value for the whole group. Any <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> classes that are
            added after setting this value will also get this <see cref="P:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup.Ref" />.
            
            The ref value will also be used by the <see cref="T:Microsoft.Practices.Composite.Modularity.IModuleManager" /> to determine which  <see cref="T:Microsoft.Practices.Composite.Modularity.IModuleTypeLoader" /> to use. 
            For example, if the ref property can be converted to an URL, it the XapModuleTypeLoader will be used 
            (Only available in the Silverlight version of CAL).
            For example, using an "file://" prefix with a valid URL will cause the FileModuleTypeLoader to be used
            (Only available in the desktop version of CAL).
            </summary>
      <seealso cref="P:Microsoft.Practices.Composite.Modularity.ModuleInfo.Ref" />
      <value>The ref value that will be used.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup.Count">
      <summary>
            Gets the number of elements contained in the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" />.
            </summary>
      <value>
      </value>
      <returns>
            The number of elements contained in the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" />.
            </returns>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup.IsReadOnly">
      <summary>
            Gets a value indicating whether the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" /> is read-only.
            </summary>
      <value>
      </value>
      <returns>false, because the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" /> is not Read-Only.
            </returns>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup.IsFixedSize">
      <summary>
            Gets a value indicating whether the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" /> has a fixed size.
            </summary>
      <returns>false, because the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup" /> does not have a fixed length.
            </returns>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup.IsSynchronized">
      <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe).
            </summary>
      <value>
      </value>
      <returns>true if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe); otherwise, false.
            </returns>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup.SyncRoot">
      <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
      </value>
      <returns>
            An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </returns>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleInfoGroup.Item(System.Int32)">
      <summary>
            Gets or sets the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> at the specified index.
            </summary>
      <value>The <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> at the specified index </value>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.ModuleTypeLoadedCallback">
      <summary>
            Callback to be called when module's type is loaded.
            </summary>
      <param name="moduleInfo">The retrieved module.</param>
      <param name="error">Exception ocurred during module group retrieval or null if no error ocurred.</param>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.IModuleTypeLoader">
      <summary>
            Defines the interface for moduleTypeLoaders
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.IModuleTypeLoader.CanLoadModuleType(Microsoft.Practices.Composite.Modularity.ModuleInfo)">
      <summary>
            Evaluates the <see cref="P:Microsoft.Practices.Composite.Modularity.ModuleInfo.Ref" /> property to see if the current typeloader will be able to retrieve the <paramref name="moduleInfo" />.
            </summary>
      <param name="moduleInfo">Module that should have it's type loaded.</param>
      <returns>
        <see langword="true" /> if the current typeloader is able to retrieve the module, otherwise <see langword="false" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.IModuleTypeLoader.BeginLoadModuleType(Microsoft.Practices.Composite.Modularity.ModuleInfo,Microsoft.Practices.Composite.Modularity.ModuleTypeLoadedCallback)">
      <summary>
            Starts retrieving the <paramref name="moduleInfo" /> and calls the <paramref name="callback" /> when it is done.
            </summary>
      <param name="moduleInfo">Module that should have it's type loaded.</param>
      <param name="callback">Delegate to be called when typeloading process completes or fails.</param>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.IConfigurationStore">
      <summary>
            Defines a store for the module metadata.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.IConfigurationStore.RetrieveModuleConfigurationSection">
      <summary>
            Gets the module configuration data.
            </summary>
      <returns>A <see cref="T:Microsoft.Practices.Composite.Modularity.ModulesConfigurationSection" /> instance.</returns>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.ConfigurationStore">
      <summary>
            Defines a store for the module metadata.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ConfigurationStore.RetrieveModuleConfigurationSection">
      <summary>
            Gets the module configuration data.
            </summary>
      <returns>A <see cref="T:Microsoft.Practices.Composite.Modularity.ModulesConfigurationSection" /> instance.</returns>
    </member>
    <member name="T:Microsoft.Practices.Composite.Events.EventSubscription`1">
      <summary>
            Provides a way to retrieve a <see cref="T:System.Delegate" /> to execute an action dependending
            on the value of a second filter predicate that returns true if the action should execute.
            </summary>
      <typeparam name="TPayload">The type to use for the generic <see cref="T:System.Action`1" /> and <see cref="T:System.Predicate`1" /> types.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.Composite.Events.EventSubscription`1.#ctor(Microsoft.Practices.Composite.Events.IDelegateReference,Microsoft.Practices.Composite.Events.IDelegateReference)">
      <summary>
             Creates a new instance of <see cref="T:Microsoft.Practices.Composite.Events.EventSubscription`1" />.
            </summary>
      <param name="actionReference">A reference to a delegate of type <see cref="T:System.Action`1" />.</param>
      <param name="filterReference">A reference to a delegate of type <see cref="T:System.Predicate`1" />.</param>
      <exception cref="T:System.ArgumentNullException">When <paramref name="actionReference" /> or <see paramref="filterReference" /> are <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">When the target of <paramref name="actionReference" /> is not of type <see cref="T:System.Action`1" />,
            or the target of <paramref name="filterReference" /> is not of type <see cref="T:System.Predicate`1" />.</exception>
    </member>
    <member name="M:Microsoft.Practices.Composite.Events.EventSubscription`1.GetExecutionStrategy">
      <summary>
            Gets the execution strategy to publish this event.
            </summary>
      <returns>An <see cref="T:System.Action`1" /> with the execution strategy, or <see langword="null" /> if the <see cref="T:Microsoft.Practices.Composite.Events.IEventSubscription" /> is no longer valid.</returns>
      <remarks>
            If <see cref="P:Microsoft.Practices.Composite.Events.EventSubscription`1.Action" /> or <see cref="P:Microsoft.Practices.Composite.Events.EventSubscription`1.Filter" /> are no longer valid because they were
            garbage collected, this method will return <see langword="null" />.
            Otherwise it will return a delegate that evaluates the <see cref="P:Microsoft.Practices.Composite.Events.EventSubscription`1.Filter" /> and if it
            returns <see langword="true" /> will then call <see cref="M:Microsoft.Practices.Composite.Events.EventSubscription`1.InvokeAction(System.Action{`0},`0)" />. The returned
            delegate holds hard references to the <see cref="P:Microsoft.Practices.Composite.Events.EventSubscription`1.Action" /> and <see cref="P:Microsoft.Practices.Composite.Events.EventSubscription`1.Filter" /> target
            <see cref="T:System.Delegate">delegates</see>. As long as the returned delegate is not garbage collected,
            the <see cref="P:Microsoft.Practices.Composite.Events.EventSubscription`1.Action" /> and <see cref="P:Microsoft.Practices.Composite.Events.EventSubscription`1.Filter" /> references delegates won't get collected either.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.Composite.Events.EventSubscription`1.InvokeAction(System.Action{`0},`0)">
      <summary>
            Invokes the specified <see cref="T:System.Action`1" /> synchronously when not overriden.
            </summary>
      <param name="action">The action to execute.</param>
      <param name="argument">The payload to pass <paramref name="action" /> while invoking it.</param>
    </member>
    <member name="P:Microsoft.Practices.Composite.Events.EventSubscription`1.Action">
      <summary>
            Gets the target <see cref="T:System.Action`1" /> that is referenced by the <see cref="T:Microsoft.Practices.Composite.Events.IDelegateReference" />.
            </summary>
      <value>An <see cref="T:System.Action`1" /> or <see langword="null" /> if the referenced target is not alive.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Events.EventSubscription`1.Filter">
      <summary>
            Gets the target <see cref="T:System.Predicate`1" /> that is referenced by the <see cref="T:Microsoft.Practices.Composite.Events.IDelegateReference" />.
            </summary>
      <value>An <see cref="T:System.Predicate`1" /> or <see langword="null" /> if the referenced target is not alive.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Events.EventSubscription`1.SubscriptionToken">
      <summary>
            Gets or sets a <see cref="T:Microsoft.Practices.Composite.Events.SubscriptionToken" /> that identifies this <see cref="T:Microsoft.Practices.Composite.Events.IEventSubscription" />.
            </summary>
      <value>A token that identifies this <see cref="T:Microsoft.Practices.Composite.Events.IEventSubscription" />.</value>
    </member>
    <member name="T:Microsoft.Practices.Composite.Regions.RegionManagerExtensions">
      <summary>
            Class that creates a fluent interface for the <see cref="T:Microsoft.Practices.Composite.Regions.IRegionManager" /> class, with respect to 
            adding views to regions (View Injection pattern), registering view types to regions (View Discovery pattern)
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Regions.RegionManagerExtensions.AddToRegion(Microsoft.Practices.Composite.Regions.IRegionManager,System.String,System.Object)">
      <summary>
                Add a view to the Views collection of a Region. Note that the region must already exist in this regionmanager. 
            </summary>
      <param name="regionManager">The regionmanager that this extension method effects.</param>
      <param name="regionName">The name of the region to add a view to</param>
      <param name="view">The view to add to the views collection</param>
      <returns>The RegionManager, to easily add several views. </returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Regions.RegionManagerExtensions.RegisterViewWithRegion(Microsoft.Practices.Composite.Regions.IRegionManager,System.String,System.Type)">
      <summary>
            Associate a view with a region, by registering a type. When the region get's displayed
            this type will be resolved using the ServiceLocator into a concrete instance. The instance
            will be added to the Views collection of the region
            </summary>
      <param name="regionManager">The regionmanager that this extension method effects.</param>
      <param name="regionName">The name of the region to associate the view with.</param>
      <param name="viewType">The type of the view to register with the </param>
      <returns>The regionmanager, for adding several views easily</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Regions.RegionManagerExtensions.RegisterViewWithRegion(Microsoft.Practices.Composite.Regions.IRegionManager,System.String,System.Func{System.Object})">
      <summary>
            Associate a view with a region, using a delegate to resolve a concreate instance of the view. 
            When the region get's displayed, this delelgate will be called and the result will be added to the
            views collection of the region. 
            </summary>
      <param name="regionManager">The regionmanager that this extension method effects.</param>
      <param name="regionName">The name of the region to associate the view with.</param>
      <param name="getContentDelegate">The delegate used to resolve a concreate instance of the view.</param>
      <returns>The regionmanager, for adding several views easily</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Regions.RegionManagerExtensions.Add(Microsoft.Practices.Composite.Regions.IRegionCollection,System.String,Microsoft.Practices.Composite.Regions.IRegion)">
      <summary>
            Adds a region to the regionmanager with the name received as argument.
            </summary>
      <param name="regionCollection">The regionmanager's collection of regions.</param>
      <param name="regionName">The name to be given to the region.</param>
      <param name="region">The region to be added to the regionmanager.</param>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.ModuleDependencyCollection">
      <summary>
            A collection of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleDependencyConfigurationElement" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleDependencyCollection.#ctor">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleDependencyCollection" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleDependencyCollection.#ctor(Microsoft.Practices.Composite.Modularity.ModuleDependencyConfigurationElement[])">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleDependencyCollection" />.
            </summary>
      <param name="dependencies">An array of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleDependencyConfigurationElement" /> with initial list of dependencies.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleDependencyCollection.CreateNewElement">
      <summary>
            Creates a new <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleDependencyConfigurationElement" />.
            </summary>
      <returns>A <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleDependencyConfigurationElement" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleDependencyCollection.GetElementKey(System.Configuration.ConfigurationElement)">
      <summary>
            Gets the element key for a specified configuration element when overridden in a derived class.
            </summary>
      <param name="element">The <see cref="T:System.Configuration.ConfigurationElement" /> to return the key for. </param>
      <returns>
            An <see cref="T:System.Object" /> that acts as the key for the specified <see cref="T:System.Configuration.ConfigurationElement" />.
            </returns>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleDependencyCollection.CollectionType">
      <summary>
            Gets the type of the <see cref="T:System.Configuration.ConfigurationElementCollection" />.
            </summary>
      <value>
            The <see cref="T:System.Configuration.ConfigurationElementCollectionType" /> of this collection.
            </value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleDependencyCollection.ElementName">
      <summary>
            Gets the name used to identify this collection of elements in the configuration file when overridden in a derived class.
            </summary>
      <value>
            The name of the collection; otherwise, an empty string.
            </value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Modularity.ModuleDependencyCollection.Item(System.Int32)">
      <summary>
            Gets the <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleDependencyConfigurationElement" /> located at the specified index in the collection.
            </summary>
      <param name="index">The index of the element in the collection.</param>
      <returns>A <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleDependencyConfigurationElement" />.</returns>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.FileModuleTypeLoader">
      <summary>
            Loads modules from an arbitrary location on the filesystem. This typeloader is only called if 
            <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInfo" /> classes have a Ref parameter that starts with "file://". 
            This class is only used on the Desktop version of the Composite Application Library.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.FileModuleTypeLoader.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.FileModuleTypeLoader" /> class.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.FileModuleTypeLoader.#ctor(Microsoft.Practices.Composite.Modularity.IAssemblyResolver)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Modularity.FileModuleTypeLoader" /> class.
            </summary>
      <param name="assemblyResolver">The assembly resolver.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.FileModuleTypeLoader.CanLoadModuleType(Microsoft.Practices.Composite.Modularity.ModuleInfo)">
      <summary>
            Evaluates the <see cref="P:Microsoft.Practices.Composite.Modularity.ModuleInfo.Ref" /> property to see if the current typeloader will be able to retrieve the <paramref name="moduleInfo" />.
            Returns true if the <see cref="P:Microsoft.Practices.Composite.Modularity.ModuleInfo.Ref" /> property starts with "file://", because this indicates that the file
            is a local file. 
            </summary>
      <param name="moduleInfo">Module that should have it's type loaded.</param>
      <returns>
        <see langword="true" /> if the current typeloader is able to retrieve the module, otherwise <see langword="false" />.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.FileModuleTypeLoader.BeginLoadModuleType(Microsoft.Practices.Composite.Modularity.ModuleInfo,Microsoft.Practices.Composite.Modularity.ModuleTypeLoadedCallback)">
      <summary>
            Starts retrieving the <paramref name="moduleInfo" /> and calls the <paramref name="callback" /> when it is done.
            </summary>
      <param name="moduleInfo">Module that should have it's type loaded.</param>
      <param name="callback">Delegate to be called when typeloading process completes or fails.</param>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.IModuleInitializer">
      <summary>
            Declares a service which initializes the modules into the application.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.IModuleInitializer.Initialize(Microsoft.Practices.Composite.Modularity.ModuleInfo)">
      <summary>
            Initializes the specified module.
            </summary>
      <param name="moduleInfo">The module to initialize</param>
    </member>
    <member name="T:Microsoft.Practices.Composite.Modularity.ModuleInitializer">
      <summary>
            Implements the <see cref="T:Microsoft.Practices.Composite.Modularity.IModuleInitializer" /> interface. Handles loading of a module based on a type.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInitializer.#ctor(Microsoft.Practices.ServiceLocation.IServiceLocator,Microsoft.Practices.Composite.Logging.ILoggerFacade)">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Modularity.ModuleInitializer" />.
            </summary>
      <param name="serviceLocator">The container that will be used to resolve the modules by specifying its type.</param>
      <param name="loggerFacade">The logger to use.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInitializer.Initialize(Microsoft.Practices.Composite.Modularity.ModuleInfo)">
      <summary>
            Initializes the specified module.
            </summary>
      <param name="moduleInfo">The module to initialize</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInitializer.HandleModuleInitializationError(Microsoft.Practices.Composite.Modularity.ModuleInfo,System.String,System.Exception)">
      <summary>
            Handles any exception ocurred in the module Initialization process,
            logs the error using the <seealso cref="T:Microsoft.Practices.Composite.Logging.ILoggerFacade" /> and throws a <seealso cref="T:Microsoft.Practices.Composite.Modularity.ModuleInitializeException" />.
            This method can be overriden to provide a different behavior. 
            </summary>
      <param name="moduleInfo">The module metadata where the error happenened.</param>
      <param name="assemblyName">The assembly name.</param>
      <param name="exception">The exception thrown that is the cause of the current error.</param>
      <exception cref="T:Microsoft.Practices.Composite.Modularity.ModuleInitializeException">
      </exception>
    </member>
    <member name="M:Microsoft.Practices.Composite.Modularity.ModuleInitializer.CreateModule(System.String)">
      <summary>
            Uses the container to resolve a new <see cref="T:Microsoft.Practices.Composite.Modularity.IModule" /> by specifying its <see cref="T:System.Type" />.
            </summary>
      <param name="typeName">The type name to resolve. This type must implement <see cref="T:Microsoft.Practices.Composite.Modularity.IModule" />.</param>
      <returns>A new instance of <paramref name="typeName" />.</returns>
    </member>
    <member name="T:Microsoft.Practices.Composite.Events.EventBase">
      <summary>
             Defines a base class to publish and subscribe to events.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Events.EventBase.InternalSubscribe(Microsoft.Practices.Composite.Events.IEventSubscription)">
      <summary>
            Adds the specified <see cref="T:Microsoft.Practices.Composite.Events.IEventSubscription" /> to the subscribers' collection.
            </summary>
      <param name="eventSubscription">The subscriber.</param>
      <returns>The <see cref="T:Microsoft.Practices.Composite.Events.SubscriptionToken" /> that uniquely identifies every subscriber.</returns>
      <remarks>
            Adds the subscription to the internal list and assigns it a new <see cref="T:Microsoft.Practices.Composite.Events.SubscriptionToken" />.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.Composite.Events.EventBase.InternalPublish(System.Object[])">
      <summary>
            Calls all the execution strategies exposed by the list of <see cref="T:Microsoft.Practices.Composite.Events.IEventSubscription" />.
            </summary>
      <param name="arguments">The arguments that will be passed to the listeners.</param>
      <remarks>Before executing the strategies, this class will prune all the subscribers from the
            list that return a <see langword="null" /><see cref="T:System.Action`1" /> when calling the
            <see cref="M:Microsoft.Practices.Composite.Events.IEventSubscription.GetExecutionStrategy" /> method.</remarks>
    </member>
    <member name="M:Microsoft.Practices.Composite.Events.EventBase.Unsubscribe(Microsoft.Practices.Composite.Events.SubscriptionToken)">
      <summary>
            Removes the subscriber matching the <seealso cref="T:Microsoft.Practices.Composite.Events.SubscriptionToken" />.
            </summary>
      <param name="token">The <see cref="T:Microsoft.Practices.Composite.Events.SubscriptionToken" /> returned by <see cref="T:Microsoft.Practices.Composite.Events.EventBase" /> while subscribing to the event.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Events.EventBase.Contains(Microsoft.Practices.Composite.Events.SubscriptionToken)">
      <summary>
            Returns <see langword="true" /> if there is a subscriber matching <see cref="T:Microsoft.Practices.Composite.Events.SubscriptionToken" />.
            </summary>
      <param name="token">The <see cref="T:Microsoft.Practices.Composite.Events.SubscriptionToken" /> returned by <see cref="T:Microsoft.Practices.Composite.Events.EventBase" /> while subscribing to the event.</param>
      <returns>
        <see langword="true" /> if there is a <see cref="T:Microsoft.Practices.Composite.Events.SubscriptionToken" /> that matches; otherwise <see langword="false" />.</returns>
    </member>
    <member name="P:Microsoft.Practices.Composite.Events.EventBase.Subscriptions">
      <summary>
            Gets the list of current subscriptions.
            </summary>
      <value>The current subscribers.</value>
    </member>
    <member name="T:Microsoft.Practices.Composite.Events.BackgroundEventSubscription`1">
      <summary>
             Extends <see cref="T:Microsoft.Practices.Composite.Events.EventSubscription`1" /> to invoke the <see cref="P:Microsoft.Practices.Composite.Events.EventSubscription`1.Action" /> delegate in a background thread.
            </summary>
      <typeparam name="TPayload">The type to use for the generic <see cref="T:System.Action`1" /> and <see cref="T:System.Predicate`1" /> types.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.Composite.Events.BackgroundEventSubscription`1.#ctor(Microsoft.Practices.Composite.Events.IDelegateReference,Microsoft.Practices.Composite.Events.IDelegateReference)">
      <summary>
             Creates a new instance of <see cref="T:Microsoft.Practices.Composite.Events.BackgroundEventSubscription`1" />.
            </summary>
      <param name="actionReference">A reference to a delegate of type <see cref="T:System.Action`1" />.</param>
      <param name="filterReference">A reference to a delegate of type <see cref="T:System.Predicate`1" />.</param>
      <exception cref="T:System.ArgumentNullException">When <paramref name="actionReference" /> or <see paramref="filterReference" /> are <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">When the target of <paramref name="actionReference" /> is not of type <see cref="T:System.Action`1" />,
            or the target of <paramref name="filterReference" /> is not of type <see cref="T:System.Predicate`1" />.</exception>
    </member>
    <member name="M:Microsoft.Practices.Composite.Events.BackgroundEventSubscription`1.InvokeAction(System.Action{`0},`0)">
      <summary>
            Invokes the specified <see cref="T:System.Action`1" /> in an asynchronous thread by using a <see cref="T:System.ComponentModel.BackgroundWorker" />.
            </summary>
      <param name="action">The action to execute.</param>
      <param name="argument">The payload to pass <paramref name="action" /> while invoking it.</param>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Events.CompositePresentationEvent`1">
      <summary>
            Defines a class that manages publication and subscription to events.
            </summary>
      <typeparam name="TPayload">The type of message that will be passed to the subscribers.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Events.CompositePresentationEvent`1.Subscribe(System.Action{`0})">
      <summary>
            Subscribes a delegate to an event that will be published on the <see cref="F:Microsoft.Practices.Composite.Presentation.Events.ThreadOption.PublisherThread" />.
            <see cref="T:Microsoft.Practices.Composite.Presentation.Events.CompositePresentationEvent`1" /> will maintain a <seealso cref="T:System.WeakReference" /> to the target of the supplied <paramref name="action" /> delegate.
            </summary>
      <param name="action">The delegate that gets executed when the event is published.</param>
      <returns>A <see cref="T:Microsoft.Practices.Composite.Events.SubscriptionToken" /> that uniquely identifies the added subscription.</returns>
      <remarks>
            The CompositePresentationEvent collection is thread-safe.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Events.CompositePresentationEvent`1.Subscribe(System.Action{`0},Microsoft.Practices.Composite.Presentation.Events.ThreadOption)">
      <summary>
            Subscribes a delegate to an event.
            CompositePresentationEvent will maintain a <seealso cref="T:System.WeakReference" /> to the Target of the supplied <paramref name="action" /> delegate.
            </summary>
      <param name="action">The delegate that gets executed when the event is raised.</param>
      <param name="threadOption">Specifies on which thread to receive the delegate callback.</param>
      <returns>A <see cref="T:Microsoft.Practices.Composite.Events.SubscriptionToken" /> that uniquely identifies the added subscription.</returns>
      <remarks>
            The CompositePresentationEvent collection is thread-safe.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Events.CompositePresentationEvent`1.Subscribe(System.Action{`0},System.Boolean)">
      <summary>
            Subscribes a delegate to an event that will be published on the <see cref="F:Microsoft.Practices.Composite.Presentation.Events.ThreadOption.PublisherThread" />.
            </summary>
      <param name="action">The delegate that gets executed when the event is published.</param>
      <param name="keepSubscriberReferenceAlive">When <see langword="true" />, the <seealso cref="T:Microsoft.Practices.Composite.Presentation.Events.CompositePresentationEvent`1" /> keeps a reference to the subscriber so it does not get garbage collected.</param>
      <returns>A <see cref="T:Microsoft.Practices.Composite.Events.SubscriptionToken" /> that uniquely identifies the added subscription.</returns>
      <remarks>
            If <paramref name="keepSubscriberReferenceAlive" /> is set to <see langword="false" />, <see cref="T:Microsoft.Practices.Composite.Presentation.Events.CompositePresentationEvent`1" /> will maintain a <seealso cref="T:System.WeakReference" /> to the Target of the supplied <paramref name="action" /> delegate.
            If not using a WeakReference (<paramref name="keepSubscriberReferenceAlive" /> is <see langword="true" />), the user must explicitly call Unsubscribe for the event when disposing the subscriber in order to avoid memory leaks or unexepcted behavior.
            
            The CompositePresentationEvent collection is thread-safe.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Events.CompositePresentationEvent`1.Subscribe(System.Action{`0},Microsoft.Practices.Composite.Presentation.Events.ThreadOption,System.Boolean)">
      <summary>
            Subscribes a delegate to an event.
            </summary>
      <param name="action">The delegate that gets executed when the event is published.</param>
      <param name="threadOption">Specifies on which thread to receive the delegate callback.</param>
      <param name="keepSubscriberReferenceAlive">When <see langword="true" />, the <seealso cref="T:Microsoft.Practices.Composite.Presentation.Events.CompositePresentationEvent`1" /> keeps a reference to the subscriber so it does not get garbage collected.</param>
      <returns>A <see cref="T:Microsoft.Practices.Composite.Events.SubscriptionToken" /> that uniquely identifies the added subscription.</returns>
      <remarks>
            If <paramref name="keepSubscriberReferenceAlive" /> is set to <see langword="false" />, <see cref="T:Microsoft.Practices.Composite.Presentation.Events.CompositePresentationEvent`1" /> will maintain a <seealso cref="T:System.WeakReference" /> to the Target of the supplied <paramref name="action" /> delegate.
            If not using a WeakReference (<paramref name="keepSubscriberReferenceAlive" /> is <see langword="true" />), the user must explicitly call Unsubscribe for the event when disposing the subscriber in order to avoid memory leaks or unexepcted behavior.
            
            The CompositePresentationEvent collection is thread-safe.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Events.CompositePresentationEvent`1.Subscribe(System.Action{`0},Microsoft.Practices.Composite.Presentation.Events.ThreadOption,System.Boolean,System.Predicate{`0})">
      <summary>
            Subscribes a delegate to an event.
            </summary>
      <param name="action">The delegate that gets executed when the event is published.</param>
      <param name="threadOption">Specifies on which thread to receive the delegate callback.</param>
      <param name="keepSubscriberReferenceAlive">When <see langword="true" />, the <seealso cref="T:Microsoft.Practices.Composite.Presentation.Events.CompositePresentationEvent`1" /> keeps a reference to the subscriber so it does not get garbage collected.</param>
      <param name="filter">Filter to evaluate if the subscriber should receive the event.</param>
      <returns>A <see cref="T:Microsoft.Practices.Composite.Events.SubscriptionToken" /> that uniquely identifies the added subscription.</returns>
      <remarks>
            If <paramref name="keepSubscriberReferenceAlive" /> is set to <see langword="false" />, <see cref="T:Microsoft.Practices.Composite.Presentation.Events.CompositePresentationEvent`1" /> will maintain a <seealso cref="T:System.WeakReference" /> to the Target of the supplied <paramref name="action" /> delegate.
            If not using a WeakReference (<paramref name="keepSubscriberReferenceAlive" /> is <see langword="true" />), the user must explicitly call Unsubscribe for the event when disposing the subscriber in order to avoid memory leaks or unexepcted behavior.
            
            The CompositePresentationEvent collection is thread-safe.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Events.CompositePresentationEvent`1.Publish(`0)">
      <summary>
            Publishes the <see cref="T:Microsoft.Practices.Composite.Presentation.Events.CompositePresentationEvent`1" />.
            </summary>
      <param name="payload">Message to pass to the subscribers.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Events.CompositePresentationEvent`1.Unsubscribe(System.Action{`0})">
      <summary>
            Removes the first subscriber matching <seealso cref="T:System.Action`1" /> from the subscribers' list.
            </summary>
      <param name="subscriber">The <see cref="T:System.Action`1" /> used when subscribing to the event.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Events.CompositePresentationEvent`1.Contains(System.Action{`0})">
      <summary>
            Returns <see langword="true" /> if there is a subscriber matching <seealso cref="T:System.Action`1" />.
            </summary>
      <param name="subscriber">The <see cref="T:System.Action`1" /> used when subscribing to the event.</param>
      <returns>
        <see langword="true" /> if there is an <seealso cref="T:System.Action`1" /> that matches; otherwise <see langword="false" />.</returns>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Events.CompositePresentationEvent`1.UIDispatcher">
      <summary>
            Gets the <see cref="T:System.Windows.Threading.Dispatcher" /> that is bound to the UI elements.
            </summary>
      <value>The <see cref="T:System.Windows.Threading.Dispatcher" /> to use when subscribing using <see cref="F:Microsoft.Practices.Composite.Presentation.Events.ThreadOption.UIThread" />.</value>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.Region">
      <summary>
            Implementation of <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> that allows multiple active views.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Region.#ctor">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.Region" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Region.Add(System.Object)">
      <overloads>Adds a new view to the region.</overloads>
      <summary>
            Adds a new view to the region.
            </summary>
      <param name="view">The view to add.</param>
      <returns>The <see cref="T:Microsoft.Practices.Composite.Regions.IRegionManager" /> that is set on the view if it is a <see cref="T:System.Windows.DependencyObject" />. It will be the current region manager when using this overload.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Region.Add(System.Object,System.String)">
      <summary>
            Adds a new view to the region.
            </summary>
      <param name="view">The view to add.</param>
      <param name="viewName">The name of the view. This can be used to retrieve it later by calling <see cref="M:Microsoft.Practices.Composite.Regions.IRegion.GetView(System.String)" />.</param>
      <returns>The <see cref="T:Microsoft.Practices.Composite.Regions.IRegionManager" /> that is set on the view if it is a <see cref="T:System.Windows.DependencyObject" />. It will be the current region manager when using this overload.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Region.Add(System.Object,System.String,System.Boolean)">
      <summary>
            Adds a new view to the region.
            </summary>
      <param name="view">The view to add.</param>
      <param name="viewName">The name of the view. This can be used to retrieve it later by calling <see cref="M:Microsoft.Practices.Composite.Regions.IRegion.GetView(System.String)" />.</param>
      <param name="createRegionManagerScope">When <see langword="true" />, the added view will receive a new instance of <see cref="T:Microsoft.Practices.Composite.Regions.IRegionManager" />, otherwise it will use the current region manager for this region.</param>
      <returns>The <see cref="T:Microsoft.Practices.Composite.Regions.IRegionManager" /> that is set on the view if it is a <see cref="T:System.Windows.DependencyObject" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Region.Remove(System.Object)">
      <summary>
            Removes the specified view from the region.
            </summary>
      <param name="view">The view to remove.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Region.Activate(System.Object)">
      <summary>
            Marks the specified view as active. 
            </summary>
      <param name="view">The view to activate.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Region.Deactivate(System.Object)">
      <summary>
            Marks the specified view as inactive. 
            </summary>
      <param name="view">The view to deactivate.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Region.GetView(System.String)">
      <summary>
            Returns the view instance that was added to the region using a specific name.
            </summary>
      <param name="viewName">The name used when adding the view to the region.</param>
      <returns>Returns the named view or <see langword="null" /> if the view with <paramref name="viewName" /> does not exist in the current region.</returns>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Regions.Region.Behaviors">
      <summary>
            Gets the collection of <see cref="T:Microsoft.Practices.Composite.Regions.IRegionBehavior" />s that can extend the behavior of regions. 
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Regions.Region.Context">
      <summary>
            Gets or sets a context for the region. This value can be used by the user to share context with the views.
            </summary>
      <value>The context value to be shared.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Regions.Region.Name">
      <summary>
            Gets the name of the region that uniequely identifies the region within a <see cref="T:Microsoft.Practices.Composite.Regions.IRegionManager" />.
            </summary>
      <value>The name of the region.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Regions.Region.Views">
      <summary>
            Gets a readonly view of the collection of views in the region.
            </summary>
      <value>An <see cref="T:Microsoft.Practices.Composite.Regions.IViewsCollection" /> of all the added views.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Regions.Region.ActiveViews">
      <summary>
            Gets a readonly view of the collection of all the active views in the region.
            </summary>
      <value>An <see cref="T:Microsoft.Practices.Composite.Regions.IViewsCollection" /> of all the active views.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Regions.Region.RegionManager">
      <summary>
            Gets or sets the <see cref="T:Microsoft.Practices.Composite.Regions.IRegionManager" /> that will be passed to the views when adding them to the region, unless the view is added by specifying createRegionManagerScope as <see langword="true" />.
            </summary>
      <value>The <see cref="T:Microsoft.Practices.Composite.Regions.IRegionManager" /> where this <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> is registered.</value>
      <remarks>This is usually used by implementations of <see cref="T:Microsoft.Practices.Composite.Regions.IRegionManager" /> and should not be
            used by the developer explicitely.</remarks>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Regions.Region.ItemMetadataCollection">
      <summary>
            Gets the collection with all the views along with their metadata.
            </summary>
      <value>An <see cref="T:System.Collections.ObjectModel.ObservableCollection`1" /> of <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.ItemMetadata" /> with all the added views.</value>
    </member>
    <member name="E:Microsoft.Practices.Composite.Presentation.Regions.Region.PropertyChanged">
      <summary>
            Occurs when a property value changes.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.ViewsCollection">
      <summary>
            Implementation of <see cref="T:Microsoft.Practices.Composite.Regions.IViewsCollection" /> that takes an <see cref="T:System.Collections.ObjectModel.ObservableCollection`1" /> of <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.ItemMetadata" />
            and filters it to display an <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" /> collection of
            <see cref="T:System.Object" /> elements (the items which the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.ItemMetadata" /> wraps).
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.ViewsCollection.#ctor(System.Collections.ObjectModel.ObservableCollection{Microsoft.Practices.Composite.Presentation.Regions.ItemMetadata},System.Predicate{Microsoft.Practices.Composite.Presentation.Regions.ItemMetadata})">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.ViewsCollection" />.
            </summary>
      <param name="list">The list to wrap and filter.</param>
      <param name="filter">A predicate to filter the <paramref name="list" /> collection.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.ViewsCollection.Contains(System.Object)">
      <summary>
            Determines whether the collection contains a specific value.
            </summary>
      <param name="value">The object to locate in the collection.</param>
      <returns>
        <see langword="true" /> if <paramref name="value" /> is found in the collection; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.ViewsCollection.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="E:Microsoft.Practices.Composite.Presentation.Regions.ViewsCollection.CollectionChanged">
      <summary>
            Occurs when the collection changes.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.SingleActiveRegion">
      <summary>
            Region that allows a maximum of one active view at a time.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.SingleActiveRegion.Activate(System.Object)">
      <summary>
            Marks the specified view as active.
            </summary>
      <param name="view">The view to activate.</param>
      <remarks>If there is an active view before calling this method,
            that view will be deactivated automatically.</remarks>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.IRegionManagerAccessor">
      <summary>
            Provides an abstraction on top of the RegionManager static members.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.IRegionManagerAccessor.GetRegionName(System.Windows.DependencyObject)">
      <summary>
            Gets the value for the RegionName attached property.
            </summary>
      <param name="element">The object to adapt. This is typically a container (i.e a control).</param>
      <returns>The name of the region that should be created when 
            the RegionManager is also set in this element.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.IRegionManagerAccessor.GetRegionManager(System.Windows.DependencyObject)">
      <summary>
            Gets the value of the RegionName attached property.
            </summary>
      <param name="element">The target element.</param>
      <returns>The <see cref="T:Microsoft.Practices.Composite.Regions.IRegionManager" /> attached to the <paramref name="element" /> element.</returns>
    </member>
    <member name="E:Microsoft.Practices.Composite.Presentation.Regions.IRegionManagerAccessor.UpdatingRegions">
      <summary>
            Notification used by attached behaviors to update the region managers appropriatelly if needed to.
            </summary>
      <remarks>This event uses weak references to the event handler to prevent this static event of keeping the
            target element longer than expected. For security reasons, to use weak delegates in Silverlight you must provide
            a delegate that is available in the public API of the class (no private or anonymous delegates allowed).</remarks>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.ItemMetadata">
      <summary>
            Defines a class that wraps an item and adds metadata for it.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Presentation.Regions.ItemMetadata.NameProperty">
      <summary>
            The name of the wrapped item.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Presentation.Regions.ItemMetadata.IsActiveProperty">
      <summary>
            Value indicating whether the wrapped item is considered active.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.ItemMetadata.#ctor(System.Object)">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.ItemMetadata" />.
            </summary>
      <param name="item">The item to wrap.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.ItemMetadata.InvokeMetadataChanged">
      <summary>
            Explicitly invokes <see cref="E:Microsoft.Practices.Composite.Presentation.Regions.ItemMetadata.MetadataChanged" /> to notify listeners.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Regions.ItemMetadata.Item">
      <summary>
            Gets the wrapped item.
            </summary>
      <value>The wrapped item.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Regions.ItemMetadata.Name">
      <summary>
            Gets or sets a name for the wrapped item.
            </summary>
      <value>The name of the wrapped item.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Regions.ItemMetadata.IsActive">
      <summary>
            Gets or sets a value indicating whether the wrapped item is considered active.
            </summary>
      <value>
        <see langword="true" /> if the item should be considered active; otherwise <see langword="false" />.</value>
    </member>
    <member name="E:Microsoft.Practices.Composite.Presentation.Regions.ItemMetadata.MetadataChanged">
      <summary>
            Occurs when metadata on the item changes.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Commands.CompositeCommand">
      <summary>
            The CompositeCommand composites one or more ICommands.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Commands.CompositeCommand.#ctor">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Presentation.Commands.CompositeCommand" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Commands.CompositeCommand.#ctor(System.Boolean)">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Presentation.Commands.CompositeCommand" />.
            </summary>
      <param name="monitorCommandActivity">Indicates when the command activity is going to be monitored.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Commands.CompositeCommand.RegisterCommand(System.Windows.Input.ICommand)">
      <summary>
            Adds a command to the collection and signs up for the <see cref="E:System.Windows.Input.ICommand.CanExecuteChanged" /> event of it.
            </summary>
      <remarks>
            If this command is set to monitor command activity, and <paramref name="command" /> 
            implements the <see cref="T:Microsoft.Practices.Composite.IActiveAware" /> interface, this method will subscribe to its
            <see cref="E:Microsoft.Practices.Composite.IActiveAware.IsActiveChanged" /> event.
            </remarks>
      <param name="command">The command to register.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Commands.CompositeCommand.UnregisterCommand(System.Windows.Input.ICommand)">
      <summary>
            Removes a command from the collection and removes itself from the <see cref="E:System.Windows.Input.ICommand.CanExecuteChanged" /> event of it.
            </summary>
      <param name="command">The command to unregister.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Commands.CompositeCommand.CanExecute(System.Object)">
      <summary>
            Forwards <see cref="M:System.Windows.Input.ICommand.CanExecute(System.Object)" /> to the registered commands and returns
            <see langword="true" /> if all of the commands return <see langword="true" />.
            </summary>
      <param name="parameter">Data used by the command.
            If the command does not require data to be passed, this object can be set to <see langword="null" />.
            </param>
      <returns>
        <see langword="true" /> if all of the commands return <see langword="true" />; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Commands.CompositeCommand.Execute(System.Object)">
      <summary>
            Forwards <see cref="M:System.Windows.Input.ICommand.Execute(System.Object)" /> to the registered commands.
            </summary>
      <param name="parameter">Data used by the command.
            If the command does not require data to be passed, this object can be set to <see langword="null" />.
            </param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Commands.CompositeCommand.ShouldExecute(System.Windows.Input.ICommand)">
      <summary>
            Evaluates if a command should execute.
            </summary>
      <param name="command">The command to evaluate.</param>
      <returns>A <see cref="T:System.Boolean" /> value indicating whether the command should be used 
            when evaluating <see cref="M:Microsoft.Practices.Composite.Presentation.Commands.CompositeCommand.CanExecute(System.Object)" /> and <see cref="M:Microsoft.Practices.Composite.Presentation.Commands.CompositeCommand.Execute(System.Object)" />.</returns>
      <remarks>
            If this command is set to monitor command activity, and <paramref name="command" />
            implements the <see cref="T:Microsoft.Practices.Composite.IActiveAware" /> interface, 
            this method will return <see langword="false" /> if the command's <see cref="P:Microsoft.Practices.Composite.IActiveAware.IsActive" /> 
            property is <see langword="false" />; otherwise it always returns <see langword="true" />.</remarks>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Commands.CompositeCommand.Command_IsActiveChanged(System.Object,System.EventArgs)">
      <summary>
            Handler for IsActiveChanged events of registered commands.
            </summary>
      <param name="sender">The sender.</param>
      <param name="e">EventArgs to pass to the event.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Commands.CompositeCommand.OnCanExecuteChanged">
      <summary>
            Raises <see cref="E:System.Windows.Input.ICommand.CanExecuteChanged" /> on the UI thread so every 
            command invoker can requery <see cref="M:System.Windows.Input.ICommand.CanExecute(System.Object)" /> to check if the
            <see cref="T:Microsoft.Practices.Composite.Presentation.Commands.CompositeCommand" /> can execute.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Commands.CompositeCommand.RegisteredCommands">
      <summary>
            Gets the list of all the registered commands.
            </summary>
      <value>A list of registered commands.</value>
      <remarks>This returns a copy of the commands subscribed to the CompositeCommand.</remarks>
    </member>
    <member name="E:Microsoft.Practices.Composite.Presentation.Commands.CompositeCommand.CanExecuteChanged">
      <summary>
            Occurs when any of the registered commands raise <seealso cref="E:Microsoft.Practices.Composite.Presentation.Commands.CompositeCommand.CanExecuteChanged" />.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Commands.DelegateCommand`1">
      <summary>
            An <see cref="T:System.Windows.Input.ICommand" /> whose delegates can be attached for <see cref="M:Microsoft.Practices.Composite.Presentation.Commands.DelegateCommand`1.Execute(`0)" /> and <see cref="M:Microsoft.Practices.Composite.Presentation.Commands.DelegateCommand`1.CanExecute(`0)" />.
            It also implements the <see cref="T:Microsoft.Practices.Composite.IActiveAware" /> interface, which is
            useful when registering this command in a <see cref="T:Microsoft.Practices.Composite.Presentation.Commands.CompositeCommand" />
            that monitors command's activity.
            </summary>
      <typeparam name="T">Parameter type.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Commands.DelegateCommand`1.#ctor(System.Action{`0})">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Presentation.Commands.DelegateCommand`1" />.
            </summary>
      <param name="executeMethod">Delegate to execute when Execute is called on the command.  This can be null to just hook up a CanExecute delegate.</param>
      <remarks>
        <seealso cref="M:Microsoft.Practices.Composite.Presentation.Commands.DelegateCommand`1.CanExecute(`0)" /> will always return true.</remarks>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Commands.DelegateCommand`1.#ctor(System.Action{`0},System.Func{`0,System.Boolean})">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Presentation.Commands.DelegateCommand`1" />.
            </summary>
      <param name="executeMethod">Delegate to execute when Execute is called on the command.  This can be null to just hook up a CanExecute delegate.</param>
      <param name="canExecuteMethod">Delegate to execute when CanExecute is called on the command.  This can be null.</param>
      <exception cref="T:System.ArgumentNullException">When both <paramref name="executeMethod" /> and <paramref name="canExecuteMethod" /> ar <see langword="null" />.</exception>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Commands.DelegateCommand`1.CanExecute(`0)">
      <summary>
            Defines the method that determines whether the command can execute in its current state.
            </summary>
      <param name="parameter">Data used by the command. If the command does not require data to be passed, this object can be set to <see langword="null" />.</param>
      <returns>
        <see langword="true" /> if this command can be executed; otherwise, <see langword="false" />.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Commands.DelegateCommand`1.Execute(`0)">
      <summary>
            Defines the method to be called when the command is invoked.
            </summary>
      <param name="parameter">Data used by the command. If the command does not require data to be passed, this object can be set to <see langword="null" />.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Commands.DelegateCommand`1.RaiseCanExecuteChanged">
      <summary>
            Raises <see cref="E:Microsoft.Practices.Composite.Presentation.Commands.DelegateCommand`1.CanExecuteChanged" /> on the UI thread so every command invoker
            can requery to check if the command can execute.
            <remarks>Note that this will trigger the execution of <see cref="M:Microsoft.Practices.Composite.Presentation.Commands.DelegateCommand`1.CanExecute(`0)" /> once for each invoker.</remarks></summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Commands.DelegateCommand`1.OnIsActiveChanged">
      <summary>
            This raises the <see cref="E:Microsoft.Practices.Composite.Presentation.Commands.DelegateCommand`1.IsActiveChanged" /> event.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Commands.DelegateCommand`1.OnCanExecuteChanged">
      <summary>
            Raises <see cref="E:Microsoft.Practices.Composite.Presentation.Commands.DelegateCommand`1.CanExecuteChanged" /> on the UI thread so every command invoker can requery to check if the command can execute.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Commands.DelegateCommand`1.IsActive">
      <summary>
            Gets or sets a value indicating whether the object is active.
            </summary>
      <value>
        <see langword="true" /> if the object is active; otherwise <see langword="false" />.</value>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.DelayedRegionCreationBehavior">
      <summary>
            Behavior that creates a new <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" />, when the control that will host the <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> (see <see cref="P:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.DelayedRegionCreationBehavior.TargetElement" />)
            is added to the VisualTree. This behavior will use the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.RegionAdapterMappings" /> class to find the right type of adapter to create
            the region. After the region is created, this behavior will detach. 
            </summary>
      <remarks>
            Attached property value inheritance is not available in Silverlight, so the current approach walks up the visual tree when requesting a region from a region manager.
            The <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionManagerRegistrationBehavior" /> is now responsible for walking up the Tree. 
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.DelayedRegionCreationBehavior.#ctor(Microsoft.Practices.Composite.Presentation.Regions.RegionAdapterMappings)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.DelayedRegionCreationBehavior" /> class.
            </summary>
      <param name="regionAdapterMappings">
            The region adapter mappings, that are used to find the correct adapter for 
            a given controltype. The controltype is determined by the <see name="TargetElement" /> value. 
            </param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.DelayedRegionCreationBehavior.Attach">
      <summary>
            Start monitoring the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.RegionManager" /> and the <see cref="P:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.DelayedRegionCreationBehavior.TargetElement" /> to detect when the <see cref="P:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.DelayedRegionCreationBehavior.TargetElement" /> becomes
            part of the Visual Tree. When that happens, the Region will be created and the behavior will <see cref="M:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.DelayedRegionCreationBehavior.Detach" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.DelayedRegionCreationBehavior.Detach">
      <summary>
            Stop monitoring the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.RegionManager" /> and the  <see cref="P:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.DelayedRegionCreationBehavior.TargetElement" />, so that this behavior can be garbage collected. 
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.DelayedRegionCreationBehavior.OnUpdatingRegions(System.Object,System.EventArgs)">
      <summary>
            Called when the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.RegionManager" /> is updating it's <see cref="P:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.Regions" /> collection. 
            </summary>
      <remarks>
            This method has to be public, because it has to be callable using weak references in silverlight and other partial trust environments.
            </remarks>
      <param name="sender">The <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.RegionManager" />. </param>
      <param name="e">The <see cref="T:System.EventArgs" /> instance containing the event data.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.DelayedRegionCreationBehavior.CreateRegion(System.Windows.DependencyObject,System.String)">
      <summary>
            Method that will create the region, by calling the right <see cref="T:Microsoft.Practices.Composite.Regions.IRegionAdapter" />. 
            </summary>
      <param name="targetElement">The target element that will host the <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" />.</param>
      <param name="regionName">Name of the region.</param>
      <returns>The created <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /></returns>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.DelayedRegionCreationBehavior.RegionManagerAccessor">
      <summary>
            Sets a class that interfaces between the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.RegionManager" /> 's static properties/events and this behavior,
            so this behavior can be tested in isolation. 
            </summary>
      <value>The region manager accessor.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.DelayedRegionCreationBehavior.TargetElement">
      <summary>
            The element that will host the Region. 
            </summary>
      <value>The target element.</value>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Commands.CommandBehaviorBase`1">
      <summary>
            Base behavior to handle connecting a <see cref="T:System.Windows.Controls.Control" /> to a Command.
            </summary>
      <typeparam name="T">The target object must derive from Control</typeparam>
      <remarks>
            CommandBehaviorBase can be used to provide new behaviors similar to <see cref="T:Microsoft.Practices.Composite.Presentation.Commands.ButtonBaseClickCommandBehavior" />.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Commands.CommandBehaviorBase`1.#ctor(`0)">
      <summary>
            Constructor specifying the target object.
            </summary>
      <param name="targetObject">The target object the behavior is attached to.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Commands.CommandBehaviorBase`1.UpdateEnabledState">
      <summary>
            Updates the target object's IsEnabled property based on the commands ability to execute.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Commands.CommandBehaviorBase`1.ExecuteCommand">
      <summary>
            Executes the command, if it's set, providing the <see cref="P:Microsoft.Practices.Composite.Presentation.Commands.CommandBehaviorBase`1.CommandParameter" /></summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Commands.CommandBehaviorBase`1.Command">
      <summary>
            Corresponding command to be execute and monitored for <see cref="E:System.Windows.Input.ICommand.CanExecuteChanged" /></summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Commands.CommandBehaviorBase`1.CommandParameter">
      <summary>
            The parameter to supply the command during execution
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Commands.CommandBehaviorBase`1.TargetObject">
      <summary>
            Object to which this behavior is attached.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Commands.ButtonBaseClickCommandBehavior">
      <summary>
            Behavior that allows controls that derrive from <see cref="T:System.Windows.Controls.Primitives.ButtonBase" /> to hook up with <see cref="T:System.Windows.Input.ICommand" /> objects. 
            </summary>
      <remarks>
            This Behavior is required in Silverlight, because Silverlight does not have Commanding support.  
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Commands.ButtonBaseClickCommandBehavior.#ctor(System.Windows.Controls.Primitives.ButtonBase)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Presentation.Commands.ButtonBaseClickCommandBehavior" /> class and hooks up the Click event of 
            <paramref name="clickableObject" /> to the ExecuteCommand() method. 
            </summary>
      <param name="clickableObject">The clickable object.</param>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.RegionBehavior">
      <summary>
            Provides a base class for region's behaviors.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionBehavior.Attach">
      <summary>
            Attaches the behavior to the region.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionBehavior.OnAttach">
      <summary>
            Override this method to perform the logic after the behavior has been attached.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Regions.RegionBehavior.Region">
      <summary>
            Behavior's attached region.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Regions.RegionBehavior.IsAttached">
      <summary>
            Returns <see langword="true" /> if the behavior is attached to a region, <see langword="false" /> otherwise.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.IHostAwareRegionBehavior">
      <summary>
            Defines a <see cref="T:Microsoft.Practices.Composite.Regions.IRegionBehavior" /> that not allows extensible behaviors on regions which also interact
            with the target element that the <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> is attached to.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.IHostAwareRegionBehavior.HostControl">
      <summary>
            Gets or sets the <see cref="T:System.Windows.DependencyObject" /> that the <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> is attached to.
            </summary>
      <value>A <see cref="T:System.Windows.DependencyObject" /> that the <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> is attached to.
            This is usually a <see cref="T:System.Windows.FrameworkElement" /> that is part of the tree.</value>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.SyncRegionContextWithHostBehavior">
      <summary>
            Behavior that synchronizes the <see cref="P:Microsoft.Practices.Composite.Regions.IRegion.Context" /> property of a <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> with 
            the control that hosts the Region. It does this by setting the <see cref="F:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.RegionContextProperty" /> 
            Dependency Property on the host control.
            
            This behavior allows the usage of two way databinding of the RegionContext from XAML. 
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.SyncRegionContextWithHostBehavior.BehaviorKey">
      <summary>
            Name that identifies the SyncRegionContextWithHostBehavior behavior in a collection of RegionsBehaviors. 
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.SyncRegionContextWithHostBehavior.OnAttach">
      <summary>
            Override this method to perform the logic after the behavior has been attached.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.SyncRegionContextWithHostBehavior.HostControl">
      <summary>
            Gets or sets the <see cref="T:System.Windows.DependencyObject" /> that the <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> is attached to.
            </summary>
      <value>
            A <see cref="T:System.Windows.DependencyObject" /> that the <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> is attached to.
            This is usually a <see cref="T:System.Windows.FrameworkElement" /> that is part of the tree.
            </value>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.UpdateRegionsException">
      <summary>
            Represents errors that occured during the regions' update.
            </summary>
      <summary>
            Represents errors that occured during the regions' update.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.UpdateRegionsException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.UpdateRegionsException" /></summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.UpdateRegionsException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.UpdateRegionsException" /> class with a specified error message.
            </summary>
      <param name="message">The message that describes the error.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.UpdateRegionsException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.UpdateRegionsException" /> class with a specified error message and a reference 
            to the inner exception that is the cause of this exception. 
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="inner">The exception that is the cause of the current exception, or a null reference 
            (Nothing in Visual Basic) if no inner exception is specified.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.UpdateRegionsException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.UpdateRegionsException" /> class with serialized data.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionCreationException">
      <summary>
      </summary>
      <summary>
            Represents errors that occured during region creation.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionCreationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionCreationException" /> class with serialized data.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionCreationException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionCreationException" /></summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionCreationException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionCreationException" /> class with a specified error message.
            </summary>
      <param name="message">The message that describes the error.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionCreationException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionCreationException" /> class with a specified error message and a reference 
            to the inner exception that is the cause of this exception. 
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="inner">The exception that is the cause of the current exception, or a null reference 
            (Nothing in Visual Basic) if no inner exception is specified.</param>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.RegionManager">
      <summary>
            This class is responsible for maintaining a collection of regions and attaching regions to controls. 
            </summary>
      <remarks>
            This class supplies the attached properties that can be used for simple region creation from XAML.
            </remarks>
    </member>
    <member name="F:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.RegionNameProperty">
      <summary>
            Identifies the RegionName attached property.
            </summary>
      <remarks>
            When a control has both the <see cref="F:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.RegionNameProperty" /> and
            <see cref="F:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.RegionManagerProperty" /> attached properties set to
            a value different than <see langword="null" /> and there is a
            <see cref="T:Microsoft.Practices.Composite.Regions.IRegionAdapter" /> mapping registered for the control, it
            will create and adapt a new region for that control, and register it
            in the <see cref="T:Microsoft.Practices.Composite.Regions.IRegionManager" /> with the specified region name.
            </remarks>
    </member>
    <member name="F:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.RegionManagerProperty">
      <summary>
            Identifies the RegionManager attached property.
            </summary>
      <remarks>
            When a control has both the <see cref="F:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.RegionNameProperty" /> and
            <see cref="F:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.RegionManagerProperty" /> attached properties set to
            a value different than <see langword="null" /> and there is a
            <see cref="T:Microsoft.Practices.Composite.Regions.IRegionAdapter" /> mapping registered for the control, it
            will create and adapt a new region for that control, and register it
            in the <see cref="T:Microsoft.Practices.Composite.Regions.IRegionManager" /> with the specified region name.
            </remarks>
    </member>
    <member name="F:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.RegionContextProperty">
      <summary>
            Identifies the RegionContext attached property.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.SetRegionName(System.Windows.DependencyObject,System.String)">
      <summary>
            Sets the <see cref="F:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.RegionNameProperty" /> attached property.
            </summary>
      <param name="regionTarget">The object to adapt. This is typically a container (i.e a control).</param>
      <param name="regionName">The name of the region to register.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.GetRegionName(System.Windows.DependencyObject)">
      <summary>
            Gets the value for the <see cref="F:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.RegionNameProperty" /> attached property.
            </summary>
      <param name="regionTarget">The object to adapt. This is typically a container (i.e a control).</param>
      <returns>The name of the region that should be created when 
            <see cref="F:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.RegionManagerProperty" /> is also set in this element.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.GetObservableRegion(System.Windows.DependencyObject)">
      <summary>
            Returns an <see cref="T:Microsoft.Practices.Composite.Presentation.ObservableObject`1" /> wrapper that can hold an <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" />. Using this wrapper
            you can detect when an <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> has been created by the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.RegionAdapterBase`1" />. 
            
            If the <see cref="T:Microsoft.Practices.Composite.Presentation.ObservableObject`1" /> wrapper does not yet exist, a new wrapper will be created. When the region
            gets created and assigned to the wrapper, you can use the <see cref="E:Microsoft.Practices.Composite.Presentation.ObservableObject`1.PropertyChanged" /> event 
            to get notified of that change. 
            </summary>
      <param name="view">The view that will host the region. </param>
      <returns>Wrapper that can hold an <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> value and can notify when the <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> value changes. </returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.GetRegionManager(System.Windows.DependencyObject)">
      <summary>
            Gets the value of the <see cref="F:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.RegionNameProperty" /> attached property.
            </summary>
      <param name="target">The target element.</param>
      <returns>The <see cref="T:Microsoft.Practices.Composite.Regions.IRegionManager" /> attached to the <paramref name="target" /> element.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.SetRegionManager(System.Windows.DependencyObject,Microsoft.Practices.Composite.Regions.IRegionManager)">
      <summary>
            Sets the <see cref="F:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.RegionManagerProperty" /> attached property.
            </summary>
      <param name="target">The target element.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.GetRegionContext(System.Windows.DependencyObject)">
      <summary>
            Gets the value of the <see cref="F:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.RegionContextProperty" /> attached property.
            </summary>
      <param name="target">The target element.</param>
      <returns>The region context to pass to the contained views.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.SetRegionContext(System.Windows.DependencyObject,System.Object)">
      <summary>
            Sets the <see cref="F:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.RegionContextProperty" /> attached property.
            </summary>
      <param name="target">The target element.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.UpdateRegions">
      <summary>
            Notifies attached behaviors to update the region managers appropriatelly if needed to. 
            </summary>
      <remarks>
            This method is normally called internally, and there is usually no need to call this from user code.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.#ctor">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.RegionManager" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.CreateRegionManager">
      <summary>
            Creates a new region manager.
            </summary>
      <returns>A new region manager that can be used as a different scope from the current region manager.</returns>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.Regions">
      <summary>
            Gets a collection of <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> that identify each region by name. You can use this collection to add or remove regions to the current region manager.
            </summary>
      <value>A <see cref="T:Microsoft.Practices.Composite.Regions.IRegionCollection" /> with all the registered regions.</value>
    </member>
    <member name="E:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.UpdatingRegions">
      <summary>
            Notification used by attached behaviors to update the region managers appropriatelly if needed to.
            </summary>
      <remarks>This event uses weak references to the event handler to prevent this static event of keeping the
            target element longer than expected. For security reasons, to use weak delegates in Silverlight you must provide
            a delegate that is available in the public API of the class (no private or anonymous delegates allowed).</remarks>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Events.DispatcherEventSubscription`1">
      <summary>
             Extends <see cref="T:Microsoft.Practices.Composite.Events.EventSubscription`1" /> to invoke the <see cref="P:Microsoft.Practices.Composite.Events.EventSubscription`1.Action" /> delegate
             in a specific <see cref="T:System.Windows.Threading.Dispatcher" />.
            </summary>
      <typeparam name="TPayload">The type to use for the generic <see cref="T:System.Action`1" /> and <see cref="T:System.Predicate`1" /> types.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Events.DispatcherEventSubscription`1.#ctor(Microsoft.Practices.Composite.Events.IDelegateReference,Microsoft.Practices.Composite.Events.IDelegateReference,Microsoft.Practices.Composite.Presentation.Events.IDispatcherFacade)">
      <summary>
             Creates a new instance of <see cref="T:Microsoft.Practices.Composite.Events.BackgroundEventSubscription`1" />.
            </summary>
      <param name="actionReference">A reference to a delegate of type <see cref="T:System.Action`1" />.</param>
      <param name="filterReference">A reference to a delegate of type <see cref="T:System.Predicate`1" />.</param>
      <param name="dispatcher">The dispatcher to use when executing the <paramref name="actionReference" /> delegate.</param>
      <exception cref="T:System.ArgumentNullException">When <paramref name="actionReference" /> or <see paramref="filterReference" /> are <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentException">When the target of <paramref name="actionReference" /> is not of type <see cref="T:System.Action`1" />,
            or the target of <paramref name="filterReference" /> is not of type <see cref="T:System.Predicate`1" />.</exception>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Events.DispatcherEventSubscription`1.InvokeAction(System.Action{`0},`0)">
      <summary>
            Invokes the specified <see cref="T:System.Action`1" /> asynchronously in the specified <see cref="T:System.Windows.Threading.Dispatcher" />.
            </summary>
      <param name="action">The action to execute.</param>
      <param name="argument">The payload to pass <paramref name="action" /> while invoking it.</param>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.ObservableObject`1">
      <summary>
            Class that wraps an object, so that other classes can notify for Change events. Typically, this class is set as 
            a Dependency Property on DependencyObjects, and allows other classes to observe any changes in the Value. 
            </summary>
      <remarks>
            This class is required, because in Silverlight, it's not possible to receive Change notifications for Dependency properties that you do not own. 
            </remarks>
      <typeparam name="T">The type of the property that's wrapped in the Observable object</typeparam>
    </member>
    <member name="F:Microsoft.Practices.Composite.Presentation.ObservableObject`1.ValueProperty">
      <summary>
            Identifies the Value property of the ObservableObject
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.ObservableObject`1.Value">
      <summary>
            The value that's wrapped inside the ObservableObject.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.RegionViewRegistry">
      <summary>
            Defines a registry for the content of the regions used on View Discovery composition.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionViewRegistry.#ctor(Microsoft.Practices.ServiceLocation.IServiceLocator)">
      <summary>
            Creates a new instance of the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.RegionViewRegistry" /> class.
            </summary>
      <param name="locator">
        <see cref="T:Microsoft.Practices.ServiceLocation.IServiceLocator" /> used to create the instance of the views from its <see cref="T:System.Type" />.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionViewRegistry.GetContents(System.String)">
      <summary>
            Returns the contents registered for a region.
            </summary>
      <param name="regionName">Name of the region which content is being requested.</param>
      <returns>Collection of contents registered for the region.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionViewRegistry.RegisterViewWithRegion(System.String,System.Type)">
      <summary>
            Registers a content type with a region name.
            </summary>
      <param name="regionName">Region name to which the <paramref name="viewType" /> will be registered.</param>
      <param name="viewType">Content type to be registered for the <paramref name="regionName" />.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionViewRegistry.RegisterViewWithRegion(System.String,System.Func{System.Object})">
      <summary>
            Registers a delegate that can be used to retrieve the content associated with a region name. 
            </summary>
      <param name="regionName">Region name to which the <paramref name="getContentDelegate" /> will be registered.</param>
      <param name="getContentDelegate">Delegate used to retrieve the content associated with the <paramref name="regionName" />.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionViewRegistry.CreateInstance(System.Type)">
      <summary>
            Creates an instance of a registered view <see cref="T:System.Type" />. 
            </summary>
      <param name="type">Type of the registered view.</param>
      <returns>Instance of the registered view.</returns>
    </member>
    <member name="E:Microsoft.Practices.Composite.Presentation.Regions.RegionViewRegistry.ContentRegistered">
      <summary>
            Occurs whenever a new view is registered.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.IRegionBehaviorFactory">
      <summary>
            Interface for RegionBehaviorFactories. This factory allows the registration of the default set of RegionBehaviors, that will
            be added to the <see cref="T:Microsoft.Practices.Composite.Regions.IRegionBehaviorCollection" />s of all <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" />s, unless overridden on a 'per-region' basis. 
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.IRegionBehaviorFactory.AddIfMissing(System.String,System.Type)">
      <summary>
            Adds a particular type of RegionBehavior if it was not already registered. the <paramref name="behaviorKey" /> string is used to check if the behavior is already present
            </summary>
      <param name="behaviorKey">The behavior key that's used to find if a certain behavior is already added.</param>
      <param name="behaviorType">Type of the behavior to add. .</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.IRegionBehaviorFactory.ContainsKey(System.String)">
      <summary>
            Determines whether a behavior with the specified key already exists
            </summary>
      <param name="behaviorKey">The behavior key.</param>
      <returns>
        <see langword="true" /> if a behavior with the specified key is present; otherwise, <see langword="false" />.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.IRegionBehaviorFactory.CreateFromKey(System.String)">
      <summary>
            Creates an instance of the the Behaviortype that's registered using the specified key.
            </summary>
      <param name="key">The key that's used to register a behavior type.</param>
      <returns>The created behavior. </returns>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.RegionBehaviorFactory">
      <summary>
            Defines a factory that allows the registration of the default set of <see cref="T:Microsoft.Practices.Composite.Regions.IRegionBehavior" />, that will
            be added to the <see cref="T:Microsoft.Practices.Composite.Regions.IRegionBehaviorCollection" /> of all <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" />s, unless overridden on a 'per-region' basis. 
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionBehaviorFactory.#ctor(Microsoft.Practices.ServiceLocation.IServiceLocator)">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.RegionBehaviorFactory" />.
            </summary>
      <param name="serviceLocator">
        <see cref="T:Microsoft.Practices.ServiceLocation.IServiceLocator" /> used to create the instance of the behavior from its <see cref="T:System.Type" />.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionBehaviorFactory.AddIfMissing(System.String,System.Type)">
      <summary>
            Adds a particular type of RegionBehavior if it was not already registered. The <paramref name="behaviorKey" /> string is used to check if the behavior is already present
            </summary>
      <param name="behaviorKey">The behavior key that's used to find if a certain behavior is already added.</param>
      <param name="behaviorType">Type of the behavior to add.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionBehaviorFactory.CreateFromKey(System.String)">
      <summary>
            Creates an instance of the the behavior <see cref="T:System.Type" /> that is registered using the specified key.
            </summary>
      <param name="key">The key that is used to register a behavior type.</param>
      <returns>A new instance of the behavior. </returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionBehaviorFactory.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionBehaviorFactory.ContainsKey(System.String)">
      <summary>
            Determines whether a behavior with the specified key already exists.
            </summary>
      <param name="behaviorKey">The behavior key.</param>
      <returns>
        <see langword="true" /> if a behavior with the specified key is present; otherwise, <see langword="false" />.
            </returns>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.RegionContext">
      <summary>
            Class that holds methods to Set and Get the RegionContext from a DependencyObject. 
            
            RegionContext allows sharing of contextual information between the view that's hosting a <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" />
            and any views that are inside the Region. 
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionContext.GetObservableContext(System.Windows.DependencyObject)">
      <summary>
            Returns an <see cref="T:Microsoft.Practices.Composite.Presentation.ObservableObject`1" /> wrapper around the RegionContext value. The RegionContext
            will be set on any views (dependency objects) that are inside the <see cref="P:Microsoft.Practices.Composite.Regions.IRegion.Views" /> collection by 
            the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.BindRegionContextToDependencyObjectBehavior" /> Behavior.
            The RegionContext will also be set to the control that hosts the Region, by the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.SyncRegionContextWithHostBehavior" /> Behavior.
            
            If the <see cref="T:Microsoft.Practices.Composite.Presentation.ObservableObject`1" /> wrapper does not already exist, an empty one will be created. This way, an observer can 
            notify when the value is set for the first time. 
            </summary>
      <param name="view">Any view that hold the RegionContext value. </param>
      <returns>Wrapper around the Regioncontext value. </returns>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Events.IDispatcherFacade">
      <summary>
            Defines the interface for invoking methods through a Dispatcher Facade
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Events.IDispatcherFacade.BeginInvoke(System.Delegate,System.Object)">
      <summary>
            Dispatches an invocation to the method received as parameter.
            </summary>
      <param name="method">Method to be invoked.</param>
      <param name="arg">Arguments to pass to the invoked method.</param>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Events.DefaultDispatcher">
      <summary>
            Wraps the Application Dispatcher.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Events.DefaultDispatcher.BeginInvoke(System.Delegate,System.Object)">
      <summary>
            Forwards the BeginInvoke to the current application's <see cref="T:System.Windows.Threading.Dispatcher" />.
            </summary>
      <param name="method">Method to be invoked.</param>
      <param name="arg">Arguments to pass to the invoked method.</param>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.AllActiveRegion">
      <summary>
            Region that keeps all the views in it as active. Deactivation of views is not allowed.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.AllActiveRegion.Deactivate(System.Object)">
      <summary>
            Deactive is not valid in this Region. This method will always throw <see cref="T:System.InvalidOperationException" />.
            </summary>
      <param name="view">The view to deactivate.</param>
      <exception cref="T:System.InvalidOperationException">Every time this method is called.</exception>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Regions.AllActiveRegion.ActiveViews">
      <summary>
            Gets a readonly view of the collection of all the active views in the region. These are all the added views.
            </summary>
      <value>An <see cref="T:Microsoft.Practices.Composite.Regions.IViewsCollection" /> of all the active views.</value>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.RegionBehaviorCollection">
      <summary>
            A collection of <see cref="T:Microsoft.Practices.Composite.Regions.IRegionBehavior" /> instances, that are stored and retrieved by Key.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionBehaviorCollection.#ctor(Microsoft.Practices.Composite.Regions.IRegion)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.RegionBehaviorCollection" /> class and associates it with a region.
            </summary>
      <param name="region">The region to associate the behavior collection with.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionBehaviorCollection.Add(System.String,Microsoft.Practices.Composite.Regions.IRegionBehavior)">
      <summary>
            Adds a <see cref="T:Microsoft.Practices.Composite.Regions.IRegionBehavior" /> to the collection, using the specified key as an indexer.
            </summary>
      <param name="key">The key that specifies the type of <see cref="T:Microsoft.Practices.Composite.Regions.IRegionBehavior" /> that's added.</param>
      <param name="regionBehavior">The <see cref="T:Microsoft.Practices.Composite.Regions.IRegionBehavior" /> to add.</param>
      <exception cref="T:System.ArgumentNullException">
            Thrown is the <paramref name="key" /> parameter is Null, 
            or if the <paramref name="regionBehavior" /> parameter is Null.
            </exception>
      <exception cref="T:System.ArgumentException">Thrown if a behavior with the specified Key parameter already exists.</exception>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionBehaviorCollection.ContainsKey(System.String)">
      <summary>
            Checks if a <see cref="T:Microsoft.Practices.Composite.Regions.IRegionBehavior" /> with the specified key is already present.
            </summary>
      <param name="key">The key to use to find a particular <see cref="T:Microsoft.Practices.Composite.Regions.IRegionBehavior" />.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionBehaviorCollection.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Regions.RegionBehaviorCollection.Item(System.String)">
      <summary>
            Gets the <see cref="T:Microsoft.Practices.Composite.Regions.IRegionBehavior" /> with the specified key.
            </summary>
      <value>The RegionBehavior that's registered with the key.</value>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.RegionAdapterBase`1">
      <summary>
            Base class to facilitate the creation of <see cref="T:Microsoft.Practices.Composite.Regions.IRegionAdapter" /> implementations.
            </summary>
      <typeparam name="T">Type of object to adapt.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionAdapterBase`1.#ctor(Microsoft.Practices.Composite.Presentation.Regions.IRegionBehaviorFactory)">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.RegionAdapterBase`1" />.
            </summary>
      <param name="regionBehaviorFactory">The factory used to create the region behaviors to attach to the created regions.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionAdapterBase`1.Initialize(`0,System.String)">
      <summary>
            Adapts an object and binds it to a new <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" />.
            </summary>
      <param name="regionTarget">The object to adapt.</param>
      <param name="regionName">The name of the region to be created.</param>
      <returns>The new instance of <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> that the <paramref name="regionTarget" /> is bound to.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionAdapterBase`1.AttachDefaultBehaviors(Microsoft.Practices.Composite.Regions.IRegion,`0)">
      <summary>
            This method adds the default behaviors by using the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.IRegionBehaviorFactory" /> object.
            </summary>
      <param name="region">The region being used.</param>
      <param name="regionTarget">The object to adapt.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionAdapterBase`1.AttachBehaviors(Microsoft.Practices.Composite.Regions.IRegion,`0)">
      <summary>
            Template method to attach new behaviors.
            </summary>
      <param name="region">The region being used.</param>
      <param name="regionTarget">The object to adapt.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionAdapterBase`1.Adapt(Microsoft.Practices.Composite.Regions.IRegion,`0)">
      <summary>
            Template method to adapt the object to an <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" />.
            </summary>
      <param name="region">The new region being used.</param>
      <param name="regionTarget">The object to adapt.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionAdapterBase`1.CreateRegion">
      <summary>
            Template method to create a new instance of <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" />
            that will be used to adapt the object.
            </summary>
      <returns>A new instance of <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" />.</returns>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Regions.RegionAdapterBase`1.RegionBehaviorFactory">
      <summary>
            Gets or sets the factory used to create the region behaviors to attach to the created regions.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.ItemsControlRegionAdapter">
      <summary>
            Adapter that creates a new <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.AllActiveRegion" /> and binds all
            the views to the adapted <see cref="T:System.Windows.Controls.ItemsControl" />. 
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.ItemsControlRegionAdapter.#ctor(Microsoft.Practices.Composite.Presentation.Regions.IRegionBehaviorFactory)">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.ItemsControlRegionAdapter" />.
            </summary>
      <param name="regionBehaviorFactory">The factory used to create the region behaviors to attach to the created regions.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.ItemsControlRegionAdapter.Adapt(Microsoft.Practices.Composite.Regions.IRegion,System.Windows.Controls.ItemsControl)">
      <summary>
            Adapts an <see cref="T:System.Windows.Controls.ItemsControl" /> to an <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" />.
            </summary>
      <param name="region">The new region being used.</param>
      <param name="regionTarget">The object to adapt.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.ItemsControlRegionAdapter.CreateRegion">
      <summary>
            Creates a new instance of <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.AllActiveRegion" />.
            </summary>
      <returns>A new instance of <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.AllActiveRegion" />.</returns>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionManagerRegistrationBehavior">
      <summary>
            Subscribes to a static event from the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.RegionManager" /> in order to register the target <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" />
            in a <see cref="T:Microsoft.Practices.Composite.Regions.IRegionManager" /> when one is available on the host control by walking up the tree and finding
            a control whose <see cref="F:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.RegionManagerProperty" /> property is not <see langword="null" />.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionManagerRegistrationBehavior.BehaviorKey">
      <summary>
            The key of this behavior.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionManagerRegistrationBehavior.#ctor">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionManagerRegistrationBehavior" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionManagerRegistrationBehavior.OnAttach">
      <summary>
            When the <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> has a name assigned, the behavior will start monitoring the ancestor controls in the element tree
            to look for an <see cref="T:Microsoft.Practices.Composite.Regions.IRegionManager" /> where to register the region in.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionManagerRegistrationBehavior.OnUpdatingRegions(System.Object,System.EventArgs)">
      <summary>
            This event handler gets called when a RegionManager is requering the instances of a region to be registered if they are not already.
            <remarks>Although this is a public method to support Weak Delegates in Silverlight, it should not be called by the user.</remarks></summary>
      <param name="sender">The sender.</param>
      <param name="e">The arguments.</param>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionManagerRegistrationBehavior.RegionManagerAccessor">
      <summary>
            Provides an abstraction on top of the RegionManager static members.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionManagerRegistrationBehavior.HostControl">
      <summary>
            Gets or sets the <see cref="T:System.Windows.DependencyObject" /> that the <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> is attached to.
            </summary>
      <value>A <see cref="T:System.Windows.DependencyObject" /> that the <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> is attached to.
            This is usually a <see cref="T:System.Windows.FrameworkElement" /> that is part of the tree.</value>
      <exception cref="T:System.InvalidOperationException">When this member is set after the <see cref="M:Microsoft.Practices.Composite.Regions.IRegionBehavior.Attach" /> method has being called.</exception>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.ViewRegistrationException">
      <summary>
            Exception that's thrown when something goes wrong while Registering a View with a region name in the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.RegionViewRegistry" /> class. 
            </summary>
      <summary>
            Exception that's thrown when something goes wrong while Registering a View with a region name in the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.RegionViewRegistry" /> class. 
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.ViewRegistrationException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.ViewRegistrationException" /> class.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.ViewRegistrationException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.ViewRegistrationException" /> class.
            </summary>
      <param name="message">The exception message.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.ViewRegistrationException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.ViewRegistrationException" /> class.
            </summary>
      <param name="message">The exception message.</param>
      <param name="inner">The inner exception.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.ViewRegistrationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.ViewRegistrationException" /> class with serialized data.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized 
            object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.AutoPopulateRegionBehavior">
      <summary>
            Populates the target region with the views registered to it in the <see cref="T:Microsoft.Practices.Composite.Regions.IRegionViewRegistry" />.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.AutoPopulateRegionBehavior.BehaviorKey">
      <summary>
            The key of this behavior.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.AutoPopulateRegionBehavior.#ctor(Microsoft.Practices.Composite.Regions.IRegionViewRegistry)">
      <summary>
            Creates a new instance of the AutoPopulateRegionBehavior 
            associated with the <see cref="T:Microsoft.Practices.Composite.Regions.IRegionViewRegistry" /> received.
            </summary>
      <param name="regionViewRegistry">
        <see cref="T:Microsoft.Practices.Composite.Regions.IRegionViewRegistry" /> that the behavior will monitor for views to populate the region.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.AutoPopulateRegionBehavior.OnAttach">
      <summary>
            Attaches the AutoPopulateRegionBehavior to the Region.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.AutoPopulateRegionBehavior.CreateViewsToAutoPopulate">
      <summary>
            Returns a collection of views that will be added to the
            View collection. 
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.AutoPopulateRegionBehavior.AddViewIntoRegion(System.Object)">
      <summary>
            Adds a view into the views collection of this region. 
            </summary>
      <param name="viewToAdd">
      </param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.AutoPopulateRegionBehavior.OnViewRegistered(System.Object,Microsoft.Practices.Composite.Regions.ViewRegisteredEventArgs)">
      <summary>
            Handler of the event that fires when a new viewtype is registered to the registry. 
            </summary>
      <remarks>Although this is a public method to support Weak Delegates in Silverlight, it should not be called by the user.</remarks>
      <param name="sender">
      </param>
      <param name="e">
      </param>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Events.ThreadOption">
      <summary>
            Specifies on which thread a <see cref="T:Microsoft.Practices.Composite.Presentation.Events.CompositePresentationEvent`1" /> subscriber will be called.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Presentation.Events.ThreadOption.PublisherThread">
      <summary>
            The call is done on the same thread on which the <see cref="T:Microsoft.Practices.Composite.Presentation.Events.CompositePresentationEvent`1" /> was published.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Presentation.Events.ThreadOption.UIThread">
      <summary>
            The call is done on the UI thread.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Presentation.Events.ThreadOption.BackgroundThread">
      <summary>
            The call is done asynchronously on a background thread.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.SelectorRegionAdapter">
      <summary>
            Adapter that creates a new <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.Region" /> and binds all
            the views to the adapted <see cref="T:System.Windows.Controls.Primitives.Selector" />.
            It also keeps the <see cref="P:Microsoft.Practices.Composite.Regions.IRegion.ActiveViews" /> and the selected items
            of the <see cref="T:System.Windows.Controls.Primitives.Selector" /> in sync.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.SelectorRegionAdapter.#ctor(Microsoft.Practices.Composite.Presentation.Regions.IRegionBehaviorFactory)">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.SelectorRegionAdapter" />.
            </summary>
      <param name="regionBehaviorFactory">The factory used to create the region behaviors to attach to the created regions.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.SelectorRegionAdapter.Adapt(Microsoft.Practices.Composite.Regions.IRegion,System.Windows.Controls.Primitives.Selector)">
      <summary>
            Adapts an <see cref="T:System.Windows.Controls.Primitives.Selector" /> to an <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" />.
            </summary>
      <param name="region">The new region being used.</param>
      <param name="regionTarget">The object to adapt.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.SelectorRegionAdapter.AttachBehaviors(Microsoft.Practices.Composite.Regions.IRegion,System.Windows.Controls.Primitives.Selector)">
      <summary>
            Attach new behaviors.
            </summary>
      <param name="region">The region being used.</param>
      <param name="regionTarget">The object to adapt.</param>
      <remarks>
            This class attaches the base behaviors and also listens for changes in the
            activity of the region or the control selection and keeps the in sync.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.SelectorRegionAdapter.CreateRegion">
      <summary>
            Creates a new instance of <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.Region" />.
            </summary>
      <returns>A new instance of <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.Region" />.</returns>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.BindRegionContextToDependencyObjectBehavior">
      <summary>
            Defines a behavior that forwards the <see cref="F:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.RegionContextProperty" /> 
            to the views in the region.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.BindRegionContextToDependencyObjectBehavior.BehaviorKey">
      <summary>
            The key of this behavior.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.BindRegionContextToDependencyObjectBehavior.Attach">
      <summary>
            Attaches the behavior to the specified region.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.BindRegionContextToDependencyObjectBehavior.Region">
      <summary>
            Behavior's attached region.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.ContentControlRegionAdapter">
      <summary>
            Adapter that creates a new <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.SingleActiveRegion" /> and monitors its
            active view to set it on the adapted <see cref="T:System.Windows.Controls.ContentControl" />. 
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.ContentControlRegionAdapter.#ctor(Microsoft.Practices.Composite.Presentation.Regions.IRegionBehaviorFactory)">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.ContentControlRegionAdapter" />.
            </summary>
      <param name="regionBehaviorFactory">The factory used to create the region behaviors to attach to the created regions.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.ContentControlRegionAdapter.Adapt(Microsoft.Practices.Composite.Regions.IRegion,System.Windows.Controls.ContentControl)">
      <summary>
            Adapts a <see cref="T:System.Windows.Controls.ContentControl" /> to an <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" />.
            </summary>
      <param name="region">The new region being used.</param>
      <param name="regionTarget">The object to adapt.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.ContentControlRegionAdapter.CreateRegion">
      <summary>
            Creates a new instance of <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.SingleActiveRegion" />.
            </summary>
      <returns>A new instance of <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.SingleActiveRegion" />.</returns>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.RegionAdapterMappings">
      <summary>
            This class maps <see cref="T:System.Type" /> with <see cref="T:Microsoft.Practices.Composite.Regions.IRegionAdapter" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionAdapterMappings.RegisterMapping(System.Type,Microsoft.Practices.Composite.Regions.IRegionAdapter)">
      <summary>
            Registers the mapping between a type and an adapter.
            </summary>
      <param name="controlType">The type of the control.</param>
      <param name="adapter">The adapter to use with the <paramref name="controlType" /> type.</param>
      <exception cref="T:System.ArgumentNullException">When any of <paramref name="controlType" /> or <paramref name="adapter" /> are <see langword="null" />.</exception>
      <exception cref="T:System.InvalidOperationException">If a mapping for <paramref name="controlType" /> already exists.</exception>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.RegionAdapterMappings.GetMapping(System.Type)">
      <summary>
            Returns the adapter associated with the type provided.
            </summary>
      <param name="controlType">The type to obtain the <seealso cref="T:Microsoft.Practices.Composite.Regions.IRegionAdapter" /> mapped.</param>
      <returns>The <seealso cref="T:Microsoft.Practices.Composite.Regions.IRegionAdapter" /> mapped to the <paramref name="controlType" />.</returns>
      <remarks>This class will look for a registered type for <paramref name="controlType" /> and if there is not any,
            it will look for a registered type for any of its ancestors in the class hierarchy.
            If there is no registered type for <paramref name="controlType" /> or any of its ancestors,
            an exception will be thrown.</remarks>
      <exception cref="T:System.Collections.Generic.KeyNotFoundException">When there is no registered type for <paramref name="controlType" /> or any of its ancestors.</exception>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Commands.Click">
      <summary>
            Static Class that holds all Dependency Properties and Static methods to allow 
            the Click event of the ButtonBase class to be attached to a Command. 
            </summary>
      <remarks>
            This class is required, because Silverlight doesn't have native support for Commands. 
            </remarks>
    </member>
    <member name="F:Microsoft.Practices.Composite.Presentation.Commands.Click.CommandProperty">
      <summary>
            Command to execute on click event.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Presentation.Commands.Click.CommandParameterProperty">
      <summary>
            Command parameter to supply on command execution.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Commands.Click.SetCommand(System.Windows.Controls.Primitives.ButtonBase,System.Windows.Input.ICommand)">
      <summary>
            Sets the <see cref="T:System.Windows.Input.ICommand" /> to execute on the click event.
            </summary>
      <param name="buttonBase">ButtonBase dependency object to attach command</param>
      <param name="command">Command to attach</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Commands.Click.GetCommand(System.Windows.Controls.Primitives.ButtonBase)">
      <summary>
            Retrieves the <see cref="T:System.Windows.Input.ICommand" /> attached to the <see cref="T:System.Windows.Controls.Primitives.ButtonBase" />.
            </summary>
      <param name="buttonBase">ButtonBase containing the Command dependency property</param>
      <returns>The value of the command attached</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Commands.Click.SetCommandParameter(System.Windows.Controls.Primitives.ButtonBase,System.Object)">
      <summary>
            Sets the value for the CommandParameter attached property on the provided <see cref="T:System.Windows.Controls.Primitives.ButtonBase" />.
            </summary>
      <param name="buttonBase">ButtonBase to attach CommandParameter</param>
      <param name="parameter">Parameter value to attach</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Commands.Click.GetCommandParameter(System.Windows.Controls.Primitives.ButtonBase)">
      <summary>
            Gets the value in CommandParameter attached property on the provided <see cref="T:System.Windows.Controls.Primitives.ButtonBase" /></summary>
      <param name="buttonBase">ButtonBase that has the CommandParameter</param>
      <returns>The value of the property</returns>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionActiveAwareBehavior">
      <summary>
            Behavior that monitors a <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> object and 
            changes the value for the <see cref="P:Microsoft.Practices.Composite.IActiveAware.IsActive" /> property when
            an object that implements <see cref="T:Microsoft.Practices.Composite.IActiveAware" /> gets added or removed 
            from the collection.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionActiveAwareBehavior.BehaviorKey">
      <summary>
            Name that identifies the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionActiveAwareBehavior" /> behavior in a collection of <see cref="T:Microsoft.Practices.Composite.Regions.IRegionBehavior" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionActiveAwareBehavior.Attach">
      <summary>
            Attaches the behavior to the specified region
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionActiveAwareBehavior.Detach">
      <summary>
            Detaches the behavior from the <see cref="T:System.Collections.Specialized.INotifyCollectionChanged" />.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.RegionActiveAwareBehavior.Region">
      <summary>
            The region that this behavior is extending
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Properties.Resources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.AdapterInvalidTypeException">
      <summary>
              Looks up a localized string similar to The object must be of type '{0}' in order to use the current region adapter..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.CannotChangeRegionNameException">
      <summary>
              Looks up a localized string similar to Cannot change the region name once is set. The current region name is '{0}'..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.CannotRegisterCompositeCommandInItself">
      <summary>
              Looks up a localized string similar to Cannot register a CompositeCommand in itself..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.CannotRegisterSameCommandTwice">
      <summary>
              Looks up a localized string similar to Cannot register the same command twice in the same CompositeCommand..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.CanOnlyAddTypesThatInheritIFromRegionBehavior">
      <summary>
              Looks up a localized string similar to Type '{0}' does not implement from IRegionBehavior..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.ContentControlHasContentException">
      <summary>
              Looks up a localized string similar to ContentControl's Content property is not empty. 
               This control is being associated with a region, but the control is already bound to something else. 
               If you did not explicitly set the control's Content property, 
               this exception may be caused by a change in the value of the inherited RegionManager attached property..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.DeactiveNotPossibleException">
      <summary>
              Looks up a localized string similar to Deactivation is not possible in this type of region..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.DelegateCommandDelegatesCannotBeNull">
      <summary>
              Looks up a localized string similar to Both the executeMethod and the canExecuteMethod delegates cannot be null..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.HostControlCannotBeNull">
      <summary>
              Looks up a localized string similar to HostControl cannot have null value when behavior attaches. .
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.HostControlCannotBeSetAfterAttach">
      <summary>
              Looks up a localized string similar to The HostControl property cannot be set after Attach method has been called..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.HostControlMustBeATabControl">
      <summary>
              Looks up a localized string similar to HostControl type must be a TabControl..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.ItemsControlHasItemsSourceException">
      <summary>
              Looks up a localized string similar to ItemsControl's ItemsSource property is not empty. 
               This control is being associated with a region, but the control is already bound to something else. 
               If you did not explicitly set the control's ItemSource property, 
               this exception may be caused by a change in the value of the inherited RegionManager attached property..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.MappingExistsException">
      <summary>
              Looks up a localized string similar to Mapping with the given type is already registered: {0}..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.OnViewRegisteredException">
      <summary>
              Looks up a localized string similar to An exception has occurred while trying to add a view to region '{0}'. 
               - The most likely causing exception was was: '{1}'.
               But also check the InnerExceptions for more detail or call .GetRootException(). .
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.RegionBehaviorAttachCannotBeCallWithNullRegion">
      <summary>
              Looks up a localized string similar to The Attach method cannot be called when Region property is null..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.RegionBehaviorRegionCannotBeSetAfterAttach">
      <summary>
              Looks up a localized string similar to The Region property cannot be set after Attach method has been called..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.RegionCreationException">
      <summary>
              Looks up a localized string similar to An exception occurred while creating a region with name '{0}'. The exception was: {1}. .
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.RegionNameCannotBeEmptyException">
      <summary>
              Looks up a localized string similar to The region name cannot be null or empty..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.RegionNameExistsException">
      <summary>
              Looks up a localized string similar to Region with the given name is already registered: {0}.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.RegionNotInRegionManagerException">
      <summary>
              Looks up a localized string similar to The region manager does not contain the {0} region..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.RegionViewExistsException">
      <summary>
              Looks up a localized string similar to View already exists in region..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.RegionViewNameExistsException">
      <summary>
              Looks up a localized string similar to View with name '{0}' already exists in the region..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.StringCannotBeNullOrEmpty">
      <summary>
              Looks up a localized string similar to The provided String argument {0} must not be null or empty..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.TypeWithKeyNotRegistered">
      <summary>
              Looks up a localized string similar to No BehaviorType with key '{0}' was registered..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.UpdateRegionException">
      <summary>
              Looks up a localized string similar to An exception occurred while trying to create region objects. 
               - The most likely causing exception was was: '{1}'.
               But also check the InnerExceptions for more detail or call .GetRootException(). .
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.ValueNotFound">
      <summary>
              Looks up a localized string similar to {0} not found..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Properties.Resources.ViewNotInRegionException">
      <summary>
              Looks up a localized string similar to The region does not contain the specified view..
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.SelectorItemsSourceSyncBehavior">
      <summary>
            Defines the attached behavior that keeps the items of the <see cref="T:System.Windows.Controls.Primitives.Selector" /> host control in synchronization with the <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" />.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.SelectorItemsSourceSyncBehavior.BehaviorKey">
      <summary>
            Name that identifies the SelectorItemsSourceSyncBehavior behavior in a collection of RegionsBehaviors. 
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.SelectorItemsSourceSyncBehavior.OnAttach">
      <summary>
            Starts to monitor the <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> to keep it in synch with the items of the <see cref="P:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.SelectorItemsSourceSyncBehavior.HostControl" />.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.Presentation.Regions.Behaviors.SelectorItemsSourceSyncBehavior.HostControl">
      <summary>
            Gets or sets the <see cref="T:System.Windows.DependencyObject" /> that the <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> is attached to.
            </summary>
      <value>
            A <see cref="T:System.Windows.DependencyObject" /> that the <see cref="T:Microsoft.Practices.Composite.Regions.IRegion" /> is attached to.
            </value>
      <remarks>For this behavior, the host control must always be a <see cref="T:System.Windows.Controls.Primitives.Selector" /> or an inherited class.</remarks>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.DefaultRegionManagerAccessor.GetRegionName(System.Windows.DependencyObject)">
      <summary>
            Gets the value for the RegionName attached property.
            </summary>
      <param name="element">The object to adapt. This is typically a container (i.e a control).</param>
      <returns>The name of the region that should be created when 
            the RegionManager is also set in this element.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.Presentation.Regions.DefaultRegionManagerAccessor.GetRegionManager(System.Windows.DependencyObject)">
      <summary>
            Gets the value of the RegionName attached property.
            </summary>
      <param name="element">The target element.</param>
      <returns>The <see cref="T:Microsoft.Practices.Composite.Regions.IRegionManager" /> attached to the <paramref name="element" /> element.</returns>
    </member>
    <member name="E:Microsoft.Practices.Composite.Presentation.Regions.DefaultRegionManagerAccessor.UpdatingRegions">
      <summary>
            Notification used by attached behaviors to update the region managers appropriatelly if needed to.
            </summary>
      <remarks>This event uses weak references to the event handler to prevent this static event of keeping the
            target element longer than expected. For security reasons, to use weak delegates in Silverlight you must provide
            a delegate that is available in the public API of the class (no private or anonymous delegates allowed).</remarks>
    </member>
    <member name="T:Microsoft.Practices.Composite.UnityExtensions.Properties.Resources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.UnityExtensions.Properties.Resources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.UnityExtensions.Properties.Resources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.UnityExtensions.Properties.Resources.NotOverwrittenGetModuleEnumeratorException">
      <summary>
              Looks up a localized string similar to The method 'GetModuleEnumerator' of the bootstrapper must be overwritten in order to use the default module initialization logic..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.UnityExtensions.Properties.Resources.NullLoggerFacadeException">
      <summary>
              Looks up a localized string similar to The ILoggerFacade is required and cannot be null..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.UnityExtensions.Properties.Resources.NullModuleCatalogException">
      <summary>
              Looks up a localized string similar to The IModuleCatalog is required and cannot be null in order to initialize the modules..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.UnityExtensions.Properties.Resources.NullUnityContainerException">
      <summary>
              Looks up a localized string similar to The IUnityContainer is required and cannot be null..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Composite.UnityExtensions.Properties.Resources.TypeMappingAlreadyRegistered">
      <summary>
              Looks up a localized string similar to Type '{0}' was already registered by the application. Skipping....
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Composite.UnityExtensions.UnityContainerHelper">
      <summary>
            Extensions methods to extend and facilitate the usage of <see cref="T:Microsoft.Practices.Unity.IUnityContainer" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.UnityExtensions.UnityContainerHelper.IsTypeRegistered(Microsoft.Practices.Unity.IUnityContainer,System.Type)">
      <summary>
            Returns whether a specified type has a type mapping registered in the container.
            </summary>
      <param name="container">The <see cref="T:Microsoft.Practices.Unity.IUnityContainer" /> to check for the type mapping.</param>
      <param name="type">The type to check if there is a type mapping for.</param>
      <returns>
        <see langword="true" /> if there is a type mapping registered for <paramref name="type" />.</returns>
      <remarks>In order to use this extension method, you first need to add the
            <see cref="T:Microsoft.Practices.Unity.IUnityContainer" /> extension to the <see cref="T:Microsoft.Practices.Composite.UnityExtensions.UnityBootstrapperExtension" />.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.Composite.UnityExtensions.UnityContainerHelper.TryResolve``1(Microsoft.Practices.Unity.IUnityContainer)">
      <summary>
            Utility method to try to resolve a service from the container avoiding an exception if the container cannot build the type.
            </summary>
      <param name="container">The cointainer that will be used to resolve the type.</param>
      <typeparam name="T">The type to resolve.</typeparam>
      <returns>The instance of <typeparamref name="T" /> built up by the container.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.UnityExtensions.UnityContainerHelper.TryResolve(Microsoft.Practices.Unity.IUnityContainer,System.Type)">
      <summary>
            Utility method to try to resolve a service from the container avoiding an exception if the container cannot build the type.
            </summary>
      <param name="container">The cointainer that will be used to resolve the type.</param>
      <param name="typeToResolve">The type to resolve.</param>
      <returns>The instance of <paramref name="typeToResolve" /> built up by the container.</returns>
    </member>
    <member name="T:Microsoft.Practices.Composite.UnityExtensions.UnityBootstrapper">
      <summary>
            Base class that provides a basic bootstrapping sequence that
            registers most of the Composite Application Library assets
            in a <see cref="T:Microsoft.Practices.Unity.IUnityContainer" />.
            </summary>
      <remarks>
            This class must be overriden to provide application specific configuration.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.Composite.UnityExtensions.UnityBootstrapper.Run">
      <summary>
            Runs the bootstrapper process.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.UnityExtensions.UnityBootstrapper.Run(System.Boolean)">
      <summary>
            Run the bootstrapper process.
            </summary>
      <param name="runWithDefaultConfiguration">If <see langword="true" />, registers default Composite Application Library services in the container. This is the default behavior.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.UnityExtensions.UnityBootstrapper.RegisterFrameworkExceptionTypes">
      <summary>
            Registers in the <see cref="T:Microsoft.Practices.Unity.IUnityContainer" /> the <see cref="T:System.Type" /> of the Exceptions
            that are not considered root exceptions by the <see cref="T:Microsoft.Practices.Composite.ExceptionExtensions" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.UnityExtensions.UnityBootstrapper.ConfigureContainer">
      <summary>
            Configures the <see cref="T:Microsoft.Practices.Unity.IUnityContainer" />. May be overwritten in a derived class to add specific
            type mappings required by the application.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.UnityExtensions.UnityBootstrapper.ConfigureRegionAdapterMappings">
      <summary>
            Configures the default region adapter mappings to use in the application, in order
            to adapt UI controls defined in XAML to use a region and register it automatically.
            May be overwritten in a derived class to add specific mappings required by the application.
            </summary>
      <returns>The <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.RegionAdapterMappings" /> instance containing all the mappings.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.UnityExtensions.UnityBootstrapper.ConfigureDefaultRegionBehaviors">
      <summary>
            Configures the <see cref="T:Microsoft.Practices.Composite.Presentation.Regions.IRegionBehaviorFactory" />. This will be the list of default
            behaviors that will be added to a region. 
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.UnityExtensions.UnityBootstrapper.InitializeModules">
      <summary>
            Initializes the modules. May be overwritten in a derived class to use a custom Modules Catalog
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.UnityExtensions.UnityBootstrapper.GetModuleCatalog">
      <summary>
            Returns the module catalog that will be used to initialize the modules.
            </summary>
      <remarks>
            When using the default initialization behavior, this method must be overwritten by a derived class.
            </remarks>
      <returns>An instance of <see cref="T:Microsoft.Practices.Composite.Modularity.IModuleCatalog" /> that will be used to initialize the modules.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.UnityExtensions.UnityBootstrapper.CreateContainer">
      <summary>
            Creates the <see cref="T:Microsoft.Practices.Unity.IUnityContainer" /> that will be used as the default container.
            </summary>
      <returns>A new instance of <see cref="T:Microsoft.Practices.Unity.IUnityContainer" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.UnityExtensions.UnityBootstrapper.RegisterTypeIfMissing(System.Type,System.Type,System.Boolean)">
      <summary>
            Registers a type in the container only if that type was not already registered.
            </summary>
      <param name="fromType">The interface type to register.</param>
      <param name="toType">The type implementing the interface.</param>
      <param name="registerAsSingleton">Registers the type as a singleton.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.UnityExtensions.UnityBootstrapper.CreateShell">
      <summary>
            Creates the shell or main window of the application.
            </summary>
      <returns>The shell of the application.</returns>
      <remarks>
            If the returned instance is a <see cref="T:System.Windows.DependencyObject" />, the
            <see cref="T:Microsoft.Practices.Composite.UnityExtensions.UnityBootstrapper" /> will attach the default <seealso cref="T:Microsoft.Practices.Composite.Regions.IRegionManager" /> of
            the application in its <see cref="F:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.RegionManagerProperty" /> attached property
            in order to be able to add regions by using the <seealso cref="F:Microsoft.Practices.Composite.Presentation.Regions.RegionManager.RegionNameProperty" />
            attached property from XAML.
            </remarks>
    </member>
    <member name="P:Microsoft.Practices.Composite.UnityExtensions.UnityBootstrapper.Container">
      <summary>
            Gets the default <see cref="T:Microsoft.Practices.Unity.IUnityContainer" /> for the application.
            </summary>
      <value>The default <see cref="T:Microsoft.Practices.Unity.IUnityContainer" /> instance.</value>
    </member>
    <member name="P:Microsoft.Practices.Composite.UnityExtensions.UnityBootstrapper.LoggerFacade">
      <summary>
            Gets the default <see cref="T:Microsoft.Practices.Composite.Logging.ILoggerFacade" /> for the application.
            </summary>
      <value>A <see cref="T:Microsoft.Practices.Composite.Logging.ILoggerFacade" /> instance.</value>
    </member>
    <member name="T:Microsoft.Practices.Composite.UnityExtensions.UnityServiceLocatorAdapter">
      <summary>
            Defines a <seealso cref="T:Microsoft.Practices.Unity.IUnityContainer" /> adapter for
            the <see cref="T:Microsoft.Practices.ServiceLocation.IServiceLocator" /> interface
            to be used by the Composite Application Library.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.UnityExtensions.UnityServiceLocatorAdapter.#ctor(Microsoft.Practices.Unity.IUnityContainer)">
      <summary>
            Initializes a new instance of <see cref="T:Microsoft.Practices.Composite.UnityExtensions.UnityServiceLocatorAdapter" />.
            </summary>
      <param name="unityContainer">The <seealso cref="T:Microsoft.Practices.Unity.IUnityContainer" /> that will be used
            by the <see cref="M:Microsoft.Practices.Composite.UnityExtensions.UnityServiceLocatorAdapter.DoGetInstance(System.Type,System.String)" /> and <see cref="M:Microsoft.Practices.Composite.UnityExtensions.UnityServiceLocatorAdapter.DoGetAllInstances(System.Type)" /> methods.</param>
    </member>
    <member name="M:Microsoft.Practices.Composite.UnityExtensions.UnityServiceLocatorAdapter.DoGetInstance(System.Type,System.String)">
      <summary>
            Resolves the instance of the requested service.
            </summary>
      <param name="serviceType">Type of instance requested.</param>
      <param name="key">Name of registered service you want. May be null.</param>
      <returns>The requested service instance.</returns>
    </member>
    <member name="M:Microsoft.Practices.Composite.UnityExtensions.UnityServiceLocatorAdapter.DoGetAllInstances(System.Type)">
      <summary>
            Resolves all the instances of the requested service.
            </summary>
      <param name="serviceType">Type of service requested.</param>
      <returns>Sequence of service instance objects.</returns>
    </member>
    <member name="T:Microsoft.Practices.Composite.UnityExtensions.UnityBootstrapperExtension">
      <summary>
            Implements a <see cref="T:Microsoft.Practices.Unity.UnityContainerExtension" /> that checks if a specific type was registered with the container.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Composite.UnityExtensions.UnityBootstrapperExtension.IsTypeRegistered(Microsoft.Practices.Unity.IUnityContainer,System.Type)">
      <summary>
            Evaluates if a specified type was registered in the container.
            </summary>
      <param name="container">The container to check if the type was registered in.</param>
      <param name="type">The type to check if it was registered.</param>
      <returns>
        <see langword="true" /> if the <paramref name="type" /> was registered with the container.</returns>
      <remarks>
            In order to use this extension, you must first call <see cref="M:Microsoft.Practices.Unity.IUnityContainer.AddNewExtension``1" /> 
            and specify <see cref="T:Microsoft.Practices.Unity.UnityContainerExtension" /> as the extension type.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.Composite.UnityExtensions.UnityBootstrapperExtension.Initialize">
      <summary>
            Initializes the container with this extension's functionality.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IBuilder">
      <summary>
            Represents the main interface for an object builder.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IBuilder.BuildUp(Microsoft.Practices.ObjectBuilder2.IReadWriteLocator,Microsoft.Practices.ObjectBuilder2.ILifetimeContainer,Microsoft.Practices.ObjectBuilder2.IPolicyList,Microsoft.Practices.ObjectBuilder2.IStrategyChain,System.Object,System.Object)">
      <summary>
            Performs a build operation.
            </summary>
      <remarks>
            This operation uses the strategies and permanent policies already configured
            into the builder, combined with the optional transient policies, and starts a build
            operation. Transient policies override any built-in policies, when present.
            </remarks>
      <param name="locator">The locator to be used for this build operation.</param>
      <param name="lifetime">The <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> to use for this build operation.</param>
      <param name="policies">
            The transient policies to apply to this build. These
            policies take precedence over any permanent policies built into the builder.
            </param>
      <param name="strategies">
            The <see cref="T:Microsoft.Practices.ObjectBuilder2.IStrategyChain" /> to use for this build operation.
            </param>
      <param name="buildKey">The key of the object to build.</param>
      <param name="existing">
            The existing object to run the build chain on, if one exists.
            If null is passed, a new object instance will typically be created by some strategy
            in the chain.
            </param>
      <returns>The built object.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IBuilder.BuildUp``1(Microsoft.Practices.ObjectBuilder2.IReadWriteLocator,Microsoft.Practices.ObjectBuilder2.ILifetimeContainer,Microsoft.Practices.ObjectBuilder2.IPolicyList,Microsoft.Practices.ObjectBuilder2.IStrategyChain,System.Object,System.Object)">
      <summary>
            Performs a build operation.
            </summary>
      <remarks>
            This operation uses the strategies and permanent policies already configured
            into the builder, combined with the optional transient policies, and starts a build
            operation. Transient policies override any built-in policies, when present.
            </remarks>
      <typeparam name="TTypeToBuild">The type to build.</typeparam>
      <param name="locator">The locator to be used for this build operation.</param>
      <param name="lifetime">The <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> to use for this build operation.</param>
      <param name="policies">
            The transient policies to apply to this build. These
            policies take precedence over any permanent policies built into the builder.
            </param>
      <param name="strategies">
            The <see cref="T:Microsoft.Practices.ObjectBuilder2.IStrategyChain" /> to use for this build operation.
            </param>
      <param name="buildKey">The key of the object to build.</param>
      <param name="existing">
            The existing object to run the build chain on, if one exists.
            If null is passed, a new object instance will typically be created by some strategy
            in the chain.
            </param>
      <returns>The built object.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IBuilder.TearDown``1(Microsoft.Practices.ObjectBuilder2.IReadWriteLocator,Microsoft.Practices.ObjectBuilder2.ILifetimeContainer,Microsoft.Practices.ObjectBuilder2.IPolicyList,Microsoft.Practices.ObjectBuilder2.IStrategyChain,``0)">
      <summary>
            Performs an unbuild operation.
            </summary>
      <typeparam name="TItem">The type to unbuild. If not provided, it will be inferred from the
            type of item.
            </typeparam>
      <param name="locator">The locator to be used for this build operation.</param>
      <param name="lifetime">The <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> to use for this build operation.</param>
      <param name="policies">
            The transient policies to apply to this build. These
            policies take precedence over any permanent policies built into the builder.
            </param>
      <param name="strategies">
            The <see cref="T:Microsoft.Practices.ObjectBuilder2.IStrategyChain" /> to use for this build operation.
            </param>
      <param name="item">The item to tear down.</param>
      <returns>The torn down item.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.Builder">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilder" />. It contains all the default strategies shipped
            with ObjectBuilder.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Builder.BuildUp(Microsoft.Practices.ObjectBuilder2.IReadWriteLocator,Microsoft.Practices.ObjectBuilder2.ILifetimeContainer,Microsoft.Practices.ObjectBuilder2.IPolicyList,Microsoft.Practices.ObjectBuilder2.IStrategyChain,System.Object,System.Object)">
      <summary>
            Performs a build operation.
            </summary>
      <remarks>
            This operation uses the strategies and permanent policies already configured
            into the builder, combined with the optional transient policies, and starts a build
            operation. Transient policies override any built-in policies, when present.
            </remarks>
      <param name="locator">The locator to be used for this build operation.</param>
      <param name="lifetime">The <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> to use for this build operation.</param>
      <param name="policies">
            The transient policies to apply to this build. These
            policies take precedence over any permanent policies built into the builder.
            </param>
      <param name="strategies">
            The <see cref="T:Microsoft.Practices.ObjectBuilder2.IStrategyChain" /> to use for this build operation.
            </param>
      <param name="buildKey">The key of the object to build.</param>
      <param name="existing">
            The existing object to run the build chain on, if one exists.
            If null is passed, a new object instance will typically be created by some strategy
            in the chain.
            </param>
      <returns>The built object.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Builder.BuildUp``1(Microsoft.Practices.ObjectBuilder2.IReadWriteLocator,Microsoft.Practices.ObjectBuilder2.ILifetimeContainer,Microsoft.Practices.ObjectBuilder2.IPolicyList,Microsoft.Practices.ObjectBuilder2.IStrategyChain,System.Object,System.Object)">
      <summary>
            Performs a build operation.
            </summary>
      <remarks>
            This operation uses the strategies and permanent policies already configured
            into the builder, combined with the optional transient policies, and starts a build
            operation. Transient policies override any built-in policies, when present.
            </remarks>
      <typeparam name="TTypeToBuild">The type to build.</typeparam>
      <param name="locator">The locator to be used for this build operation.</param>
      <param name="lifetime">The <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> to use for this build operation.</param>
      <param name="policies">
            The transient policies to apply to this build. These
            policies take precedence over any permanent policies built into the builder.
            </param>
      <param name="strategies">
            The <see cref="T:Microsoft.Practices.ObjectBuilder2.IStrategyChain" /> to use for this build operation.
            </param>
      <param name="buildKey">The key of the object to build.</param>
      <param name="existing">
            The existing object to run the build chain on, if one exists.
            If null is passed, a new object instance will typically be created by some strategy
            in the chain.
            </param>
      <returns>The built object.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Builder.TearDown``1(Microsoft.Practices.ObjectBuilder2.IReadWriteLocator,Microsoft.Practices.ObjectBuilder2.ILifetimeContainer,Microsoft.Practices.ObjectBuilder2.IPolicyList,Microsoft.Practices.ObjectBuilder2.IStrategyChain,``0)">
      <summary>
            Performs an unbuild operation.
            </summary>
      <typeparam name="TItem">The type to unbuild. If not provided, it will be inferred from the
            type of item.
            </typeparam>
      <param name="locator">The locator to be used for this build operation.</param>
      <param name="lifetime">The <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> to use for this build operation.</param>
      <param name="policies">
            The transient policies to apply to this build. These
            policies take precedence over any permanent policies built into the builder.
            </param>
      <param name="strategies">
            The <see cref="T:Microsoft.Practices.ObjectBuilder2.IStrategyChain" /> to use for this build operation.
            </param>
      <param name="item">The item to tear down.</param>
      <returns>The torn down item.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IBuilderContext">
      <summary>
            Represents the context in which a build-up or tear-down operation runs.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IBuilderContext.CloneForNewBuild(System.Object,System.Object)">
      <summary>
            Create a new IBuilderContext which has the same strategies, locator, policies, and lifetime
            but a new build key and existing object. Used to execute recursive calls when
            building up dependencies.
            </summary>
      <param name="newBuildKey">Build key for new buildup.</param>
      <param name="newExistingObject">New exsting object for buildup.</param>
      <returns>The new context.</returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IBuilderContext.Strategies">
      <summary>
            Gets the head of the strategy chain.
            </summary>
      <returns>
            The strategy that's first in the chain; returns null if there are no
            strategies in the chain.
            </returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IBuilderContext.Lifetime">
      <summary>
            Gets the <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> associated with the build.
            </summary>
      <value>
            The <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> associated with the build.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IBuilderContext.Locator">
      <summary>
            Gets the locator available to the strategies.
            </summary>
      <value>
            The locator available to the strategies.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IBuilderContext.OriginalBuildKey">
      <summary>
            Gets the original build key for the build operation.
            </summary>
      <value>
            The original build key for the build operation.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IBuilderContext.PersistentPolicies">
      <summary>
            The set of policies that were passed into this context.
            </summary>
      <remarks>This returns the policies passed into the context.
            Policies added here will remain after buildup completes.</remarks>
      <value>The persistent policies for the current context.</value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IBuilderContext.Policies">
      <summary>
            Gets the policies for the current context. 
            </summary>
      <remarks>Any policies added to this object are transient
            and will be erased at the end of the buildup.</remarks>
      <value>
            The policies for the current context.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IBuilderContext.RecoveryStack">
      <summary>
            Gets the collection of <see cref="T:Microsoft.Practices.ObjectBuilder2.IRequiresRecovery" /> objects
            that need to execute in event of an exception.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IBuilderContext.BuildKey">
      <summary>
            Get the current build key for the current build operation.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IBuilderContext.Existing">
      <summary>
            The current object being built up or torn down.
            </summary>
      <value>
            The current object being manipulated by the build operation. May
            be null if the object hasn't been created yet.</value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IBuilderContext.BuildComplete">
      <summary>
            Flag indicating if the build operation should continue.
            </summary>
      <value>true means that building should not call any more
            strategies, false means continue to the next strategy.</value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.BuilderContext">
      <summary>
            Represents the context in which a build-up or tear-down operation runs.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuilderContext.#ctor">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.BuilderContext" /> class.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuilderContext.#ctor(Microsoft.Practices.ObjectBuilder2.IStrategyChain,Microsoft.Practices.ObjectBuilder2.IReadWriteLocator,Microsoft.Practices.ObjectBuilder2.ILifetimeContainer,Microsoft.Practices.ObjectBuilder2.IPolicyList,System.Object,System.Object)">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.BuilderContext" /> class with a <see cref="T:Microsoft.Practices.ObjectBuilder2.IStrategyChain" />, 
            <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadWriteLocator" />, <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" />, <see cref="T:Microsoft.Practices.ObjectBuilder2.IPolicyList" /> and the 
            build key used to start this build operation. 
            </summary>
      <param name="chain">The <see cref="T:Microsoft.Practices.ObjectBuilder2.IStrategyChain" /> to use for this context.</param>
      <param name="locator">The <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadWriteLocator" /> to use for this context.</param>
      <param name="lifetime">The <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> to use for this context.</param>
      <param name="policies">The <see cref="T:Microsoft.Practices.ObjectBuilder2.IPolicyList" /> to use for this context.</param>
      <param name="originalBuildKey">Build key to start building.</param>
      <param name="existing">The existing object to build up.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuilderContext.#ctor(Microsoft.Practices.ObjectBuilder2.IStrategyChain,Microsoft.Practices.ObjectBuilder2.IReadWriteLocator,Microsoft.Practices.ObjectBuilder2.ILifetimeContainer,Microsoft.Practices.ObjectBuilder2.IPolicyList,Microsoft.Practices.ObjectBuilder2.IPolicyList,System.Object,System.Object)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.ObjectBuilder2.BuilderContext" /> using the explicitly provided
            values.
            </summary>
      <param name="chain">The <see cref="T:Microsoft.Practices.ObjectBuilder2.IStrategyChain" /> to use for this context.</param>
      <param name="locator">The <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadWriteLocator" /> to use for this context.</param>
      <param name="lifetime">The <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> to use for this context.</param>
      <param name="persistentPolicies">The set of persistent policies to use for this context.</param>
      <param name="transientPolicies">The set of transient policies to use for this context. It is
            the caller's responsibility to ensure that the transient and persistent policies are properly
            combined.</param>
      <param name="buildKey">Build key for this context.</param>
      <param name="existing">Existing object to build up.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuilderContext.CloneForNewBuild(System.Object,System.Object)">
      <summary>
            Create a new IBuilderContext which has the same strategies, locator, policies, and lifetime
            but a new build key and existing object. Used to execute recursive calls when
            building up dependencies.
            </summary>
      <param name="newBuildKey">Build key for new buildup.</param>
      <param name="newExistingObject">New exsting object for buildup.</param>
      <returns>The new context.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuilderContext.NewBuildUp``1(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            A convenience method to do a new buildup operation on an existing context.
            </summary>
      <remarks>This helper is specific to NamedTypeBuildKey.</remarks>
      <typeparam name="T">Type to return from the buildup.</typeparam>
      <param name="context">Existing context.</param>
      <returns>The built up object.</returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.BuilderContext.Strategies">
      <summary>
            Gets the head of the strategy chain.
            </summary>
      <returns>
            The strategy that's first in the chain; returns null if there are no
            strategies in the chain.
            </returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.BuilderContext.BuildKey">
      <summary>
            Get the current build key for the current build operation.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.BuilderContext.Existing">
      <summary>
            The current object being built up or torn down.
            </summary>
      <value>
            The current object being manipulated by the build operation. May
            be null if the object hasn't been created yet.</value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.BuilderContext.Lifetime">
      <summary>
            Gets the <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> associated with the build.
            </summary>
      <value>
            The <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> associated with the build.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.BuilderContext.Locator">
      <summary>
            Gets the locator available to the strategies.
            </summary>
      <value>
            The locator available to the strategies.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.BuilderContext.OriginalBuildKey">
      <summary>
            Gets the original build key for the build operation.
            </summary>
      <value>
            The original build key for the build operation.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.BuilderContext.PersistentPolicies">
      <summary>
            The set of policies that were passed into this context.
            </summary>
      <remarks>This returns the policies passed into the context.
            Policies added here will remain after buildup completes.</remarks>
      <value>The persistent policies for the current context.</value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.BuilderContext.Policies">
      <summary>
            Gets the policies for the current context. 
            </summary>
      <remarks>
            Any modifications will be transient (meaning, they will be forgotten when 
            the outer BuildUp for this context is finished executing).
            </remarks>
      <value>
            The policies for the current context.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.BuilderContext.RecoveryStack">
      <summary>
            Gets the collection of <see cref="T:Microsoft.Practices.ObjectBuilder2.IRequiresRecovery" /> objects
            that need to execute in event of an exception.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.BuilderContext.BuildComplete">
      <summary>
            Flag indicating if the build operation should continue.
            </summary>
      <value>true means that building should not call any more
            strategies, false means continue to the next strategy.</value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.BuildFailedException">
      <summary>
            The exception that gets thrown if a build or teardown operation fails.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuildFailedException.#ctor(Microsoft.Practices.ObjectBuilder2.IBuilderStrategy,System.Int32,System.Object,System.Exception)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.ObjectBuilder2.BuildFailedException" /> instance containing
            the information about the currently executing strategy that caused
            the exception.
            </summary>
      <param name="executingStrategy">The <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderStrategy" /> that was
            executing at the time the exception was thrown.</param>
      <param name="executingStrategyIndex">The index of the current strategy in its
            strategy chain.</param>
      <param name="buildKey">The build key being built up.</param>
      <param name="innerException">Underlying exception.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuildFailedException.#ctor">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.ObjectBuilder2.BuildFailedException" />. Do not use this constructor, it
            does not take any of the data that makes this type useful.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuildFailedException.#ctor(System.String)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.ObjectBuilder2.BuildFailedException" />. Do not use this constructor, it
            does not take any of the data that makes this type useful.
            </summary>
      <param name="message">Error message, ignored.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuildFailedException.#ctor(System.String,System.Exception)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.ObjectBuilder2.BuildFailedException" />. Do not use this constructor, it
            does not take any of the data that makes this type useful.
            </summary>
      <param name="message">Error message, ignored.</param>
      <param name="innerException">Inner exception.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuildFailedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.ObjectBuilder2.BuildFailedException" /> from the serialized information.
            </summary>
      <param name="info">Serialization info.</param>
      <param name="context">Streaming context.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuildFailedException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            When overridden in a derived class, sets the <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> with information about the exception.
            </summary>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"></see> that contains contextual information about the source or destination. </param>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> that holds the serialized object data about the exception being thrown. </param>
      <exception cref="T:System.ArgumentNullException">The info parameter is a null reference (Nothing in Visual Basic). </exception>
      <filterpriority>2</filterpriority>
      <PermissionSet>
        <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Read="*AllFiles*" PathDiscovery="*AllFiles*" />
        <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="SerializationFormatter" />
      </PermissionSet>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.BuildFailedException.ExecutingStrategyTypeName">
      <summary>
            The strategy that was executing when the exception occurred.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.BuildFailedException.ExecutingStrategyIndex">
      <summary>
            The index of the currently executing strategy in the build chain.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.BuildFailedException.BuildKey">
      <summary>
            The build key that was being built at the time of the exception.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.BuildFailedException.Message">
      <summary>
            Gets a message that describes the current exception.
            </summary>
      <returns>
            The error message that explains the reason for the exception, or an empty string("").
            </returns>
      <filterpriority>1</filterpriority>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.DependencyMissingException">
      <summary>
            Represents that a dependency could not be resolved.
            </summary>
      <summary>
            Represents that a dependency could not be resolved.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DependencyMissingException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.DependencyMissingException" /> class with no extra information.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DependencyMissingException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.DependencyMissingException" /> class with the given message.
            </summary>
      <param name="message">Some random message.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DependencyMissingException.#ctor(System.String,System.Exception)">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.DependencyMissingException" /> class with the given
            message and inner exception.
            </summary>
      <param name="message">Some random message</param>
      <param name="innerException">Inner exception.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DependencyMissingException.#ctor(System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.DependencyMissingException" /> class with the build key of the object begin built.
            </summary>
      <param name="buildKey">The build key of the object begin built.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DependencyMissingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.DependencyMissingException" /> class with serialized data.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination. </param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IRecoveryStack">
      <summary>
            Data structure that stores the set of <see cref="T:Microsoft.Practices.ObjectBuilder2.IRequiresRecovery" />
            objects and executes them when requested.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IRecoveryStack.Add(Microsoft.Practices.ObjectBuilder2.IRequiresRecovery)">
      <summary>
            Add a new <see cref="T:Microsoft.Practices.ObjectBuilder2.IRequiresRecovery" /> object to this
            list.
            </summary>
      <param name="recovery">Object to add.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IRecoveryStack.ExecuteRecovery">
      <summary>
            Execute the <see cref="M:Microsoft.Practices.ObjectBuilder2.IRequiresRecovery.Recover" /> method
            of everything in the recovery list. Recoveries will execute
            in the opposite order of add - it's a stack.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IRecoveryStack.Count">
      <summary>
            Return the number of recovery objects currently in the stack.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IRequiresRecovery">
      <summary>
            This interface provides a hook for the builder context to
            implement error recovery when a builder strategy throws
            an exception. Since we can't get try/finally blocks onto
            the call stack for later stages in the chain, we instead
            add these objects to the context. If there's an exception,
            all the current IRequiresRecovery instances will have
            their Recover methods called.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IRequiresRecovery.Recover">
      <summary>
            A method that does whatever is needed to clean up
            as part of cleaning up after an exception.
            </summary>
      <remarks>
            Don't do anything that could throw in this method,
            it will cause later recover operations to get skipped
            and play real havok with the stack trace.
            </remarks>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.Properties.Resources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Properties.Resources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Properties.Resources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Properties.Resources.AmbiguousInjectionConstructor">
      <summary>
              Looks up a localized string similar to The type {0} has multiple constructors of length {1}. Unable to disambiguate..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Properties.Resources.BuildFailedException">
      <summary>
              Looks up a localized string similar to The current build operation (build key {2}) failed: {3} (Strategy type {0}, index {1}).
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Properties.Resources.CannotConstructInterface">
      <summary>
              Looks up a localized string similar to The current type, {0}, is an interface and cannot be constructed. Are you missing a type mapping?.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Properties.Resources.CannotExtractTypeFromBuildKey">
      <summary>
              Looks up a localized string similar to Cannot extract type from build key {0}..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Properties.Resources.CannotInjectMethodWithOutParam">
      <summary>
              Looks up a localized string similar to The method {1} on type {0} has an out parameter. Injection cannot be performed..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Properties.Resources.CannotInjectOpenGenericMethod">
      <summary>
              Looks up a localized string similar to The method {1} on type {0} is marked for injection, but it is an open generic method. Injection cannot be performed..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Properties.Resources.ConstructorParameterResolutionFailed">
      <summary>
              Looks up a localized string similar to The parameter {0} could not be resolved when attempting to call constructor {1}..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Properties.Resources.KeyAlreadyPresent">
      <summary>
              Looks up a localized string similar to An item with the given key is already present in the dictionary..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Properties.Resources.MethodParameterResolutionFailed">
      <summary>
              Looks up a localized string similar to The value for parameter "{1}" of method {0} could not be resolved. .
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Properties.Resources.MissingDependency">
      <summary>
              Looks up a localized string similar to Could not resolve dependency for build key {0}..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Properties.Resources.MultipleInjectionConstructors">
      <summary>
              Looks up a localized string similar to The type {0} has multiple constructors marked with the InjectionConstructor attribute. Unable to disambiguate..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Properties.Resources.MustHaveOpenGenericType">
      <summary>
              Looks up a localized string similar to The supplied type {0} must be an open generic type..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Properties.Resources.MustHaveSameNumberOfGenericArguments">
      <summary>
              Looks up a localized string similar to The supplied type {0} does not have the same number of generic arguments as the target type {1}..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Properties.Resources.NoConstructorFound">
      <summary>
              Looks up a localized string similar to The type {0} does not have an accessible constructor..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Properties.Resources.PropertyValueResolutionFailed">
      <summary>
              Looks up a localized string similar to The value for the property "{0}" could not be resolved..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Properties.Resources.ProvidedStringArgMustNotBeEmpty">
      <summary>
              Looks up a localized string similar to The provided string argument must not be empty..
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.RecoveryStack">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IRecoveryStack" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.RecoveryStack.Add(Microsoft.Practices.ObjectBuilder2.IRequiresRecovery)">
      <summary>
            Add a new <see cref="T:Microsoft.Practices.ObjectBuilder2.IRequiresRecovery" /> object to this
            list.
            </summary>
      <param name="recovery">Object to add.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.RecoveryStack.ExecuteRecovery">
      <summary>
            Execute the <see cref="M:Microsoft.Practices.ObjectBuilder2.IRequiresRecovery.Recover" /> method
            of everything in the recovery list. Recoveries will execute
            in the opposite order of add - it's a stack.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.RecoveryStack.Count">
      <summary>
            Return the number of recovery objects currently in the stack.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IBuilderStrategy">
      <summary>
            Represents a strategy in the <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilder" />'s chain of responsibility.
            Strategies are required to support both BuildUp and TearDown. Although you
            can implement this interface directly, you may also choose to use
            <see cref="T:Microsoft.Practices.ObjectBuilder2.BuilderStrategy" /> as the base class for your strategies, as
            this class provides useful helper methods and makes support BuildUp and TearDown
            optional.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IBuilderStrategy.PreBuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Called during the chain of responsibility for a build operation. The
            PreBuildUp method is called when the chain is being executed in the
            forward direction.
            </summary>
      <param name="context">Context of the build operation.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IBuilderStrategy.PostBuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Called during the chain of responsibility for a build operation. The
            PostBuildUp method is called when the chain has finished the PreBuildUp
            phase and executes in reverse order from the PreBuildUp calls.
            </summary>
      <param name="context">Context of the build operation.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IBuilderStrategy.PreTearDown(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Called during the chain of responsibility for a teardown operation. The
            PreTearDown method is called when the chain is being executed in the
            forward direction.
            </summary>
      <param name="context">Context of the teardown operation.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IBuilderStrategy.PostTearDown(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Called during the chain of responsibility for a teardown operation. The
            PostTearDown method is called when the chain has finished the PreTearDown
            phase and executes in reverse order from the PreTearDown calls.
            </summary>
      <param name="context">
      </param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.BuilderStrategy">
      <summary>
            Represents a strategy in the <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilder" />'s chain of responsibility.
            Strategies are required to support both BuildUp and TearDown.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuilderStrategy.PreBuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Called during the chain of responsibility for a build operation. The
            PreBuildUp method is called when the chain is being executed in the
            forward direction.
            </summary>
      <param name="context">Context of the build operation.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuilderStrategy.PostBuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Called during the chain of responsibility for a build operation. The
            PostBuildUp method is called when the chain has finished the PreBuildUp
            phase and executes in reverse order from the PreBuildUp calls.
            </summary>
      <param name="context">Context of the build operation.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuilderStrategy.PreTearDown(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Called during the chain of responsibility for a teardown operation. The
            PreTearDown method is called when the chain is being executed in the
            forward direction.
            </summary>
      <param name="context">Context of the teardown operation.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuilderStrategy.PostTearDown(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Called during the chain of responsibility for a teardown operation. The
            PostTearDown method is called when the chain has finished the PreTearDown
            phase and executes in reverse order from the PreTearDown calls.
            </summary>
      <param name="context">
      </param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.BuilderAwareStrategy">
      <summary>
            Implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderStrategy" /> which will notify an object about
            the completion of a <see cref="M:Microsoft.Practices.ObjectBuilder2.IBuilder.BuildUp(Microsoft.Practices.ObjectBuilder2.IReadWriteLocator,Microsoft.Practices.ObjectBuilder2.ILifetimeContainer,Microsoft.Practices.ObjectBuilder2.IPolicyList,Microsoft.Practices.ObjectBuilder2.IStrategyChain,System.Object,System.Object)" /> operation, or start of a
            <see cref="M:Microsoft.Practices.ObjectBuilder2.IBuilder.TearDown``1(Microsoft.Practices.ObjectBuilder2.IReadWriteLocator,Microsoft.Practices.ObjectBuilder2.ILifetimeContainer,Microsoft.Practices.ObjectBuilder2.IPolicyList,Microsoft.Practices.ObjectBuilder2.IStrategyChain,``0)" /> operation.
            </summary>
      <remarks>
            This strategy checks the object that is passing through the builder chain to see if it
            implements IBuilderAware and if it does, it will call <see cref="M:Microsoft.Practices.ObjectBuilder2.IBuilderAware.OnBuiltUp(System.Object)" />
            and <see cref="M:Microsoft.Practices.ObjectBuilder2.IBuilderAware.OnTearingDown" />. This strategy is meant to be used from the
            <see cref="F:Microsoft.Practices.ObjectBuilder2.BuilderStage.PostInitialization" /> stage.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuilderAwareStrategy.PreBuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Called during the chain of responsibility for a build operation. The
            PreBuildUp method is called when the chain is being executed in the
            forward direction.
            </summary>
      <param name="context">Context of the build operation.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuilderAwareStrategy.PreTearDown(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Called during the chain of responsibility for a teardown operation. The
            PreTearDown method is called when the chain is being executed in the
            forward direction.
            </summary>
      <param name="context">Context of the teardown operation.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IBuilderAware">
      <summary>
            Implemented on a class when it wants to receive notifications
            about the build process.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IBuilderAware.OnBuiltUp(System.Object)">
      <summary>
            Called by the <see cref="T:Microsoft.Practices.ObjectBuilder2.BuilderAwareStrategy" /> when the object is being built up.
            </summary>
      <param name="buildKey">The key of the object that was just built up.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IBuilderAware.OnTearingDown">
      <summary>
            Called by the <see cref="T:Microsoft.Practices.ObjectBuilder2.BuilderAwareStrategy" /> when the object is being torn down.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.BuilderStage">
      <summary>
            Enumeration to represent the object builder stages.
            </summary>
      <remarks>
            The order of the values in the enumeration is the order in which the stages are run.
            </remarks>
    </member>
    <member name="F:Microsoft.Practices.ObjectBuilder2.BuilderStage.PreCreation">
      <summary>
            Strategies in this stage run before creation. Typical work done in this stage might
            include strategies that use reflection to set policies into the context that other
            strategies would later use.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.ObjectBuilder2.BuilderStage.Creation">
      <summary>
            Strategies in this stage create objects. Typically you will only have a single policy-driven
            creation strategy in this stage.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.ObjectBuilder2.BuilderStage.Initialization">
      <summary>
            Strategies in this stage work on created objects. Typical work done in this stage might
            include setter injection and method calls.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.ObjectBuilder2.BuilderStage.PostInitialization">
      <summary>
            Strategies in this stage work on objects that are already initialized. Typical work done in
            this stage might include looking to see if the object implements some notification interface
            to discover when its initialization stage has been completed.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IBuilderPolicy">
      <summary>
            Represents a builder policy interface. Since there are no fixed requirements
            for policies, it acts as a marker interface from which to derive all other
            policy interfaces.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IBuildKeyMappingPolicy">
      <summary>
            Represents a builder policy for mapping build keys.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IBuildKeyMappingPolicy.Map(System.Object)">
      <summary>
            Maps the build key.
            </summary>
      <param name="buildKey">The build key to map.</param>
      <returns>The new build key.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.BuildKeyMappingPolicy">
      <summary>
            Represents a builder policy for mapping build keys.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuildKeyMappingPolicy.#ctor(System.Object)">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.BuildKeyMappingPolicy" /> with the new build key.
            </summary>
      <param name="newBuildKey">
      </param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuildKeyMappingPolicy.Map(System.Object)">
      <summary>
            Map the <paramref name="buildKey" /> to a new build key.
            </summary>
      <param name="buildKey">The build key to mapl</param>
      <returns>The new build key.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.BuildKeyMappingStrategy">
      <summary>
            Represents a strategy for mapping build keys in the build up operation.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuildKeyMappingStrategy.PreBuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Called during the chain of responsibility for a build operation.  Looks for the <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuildKeyMappingPolicy" />
            and if found maps the build key for the current operation.
            </summary>
      <param name="context">The context for the operation.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.GenericTypeBuildKeyMappingPolicy">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuildKeyMappingPolicy" /> that can map
            generic types.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.GenericTypeBuildKeyMappingPolicy.#ctor(System.Object)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.ObjectBuilder2.GenericTypeBuildKeyMappingPolicy" /> instance
            that will map generic types.
            </summary>
      <param name="destinationKey">Build key to map to. This must be or contain an open generic type.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.GenericTypeBuildKeyMappingPolicy.Map(System.Object)">
      <summary>
            Maps the build key.
            </summary>
      <param name="buildKey">The build key to map.</param>
      <returns>The new build key.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy">
      <summary>
            A <see cref="T:Microsoft.Practices.ObjectBuilder2.BuilderStrategy" /> that will look for a build plan
            in the current context. If it exists, it invokes it, otherwise
            it creates one and stores it for later, and invokes it.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Called during the chain of responsibility for a build operation.
            </summary>
      <param name="context">The context for the operation.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IConstructorSelectorPolicy">
      <summary>
            A <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderPolicy" /> that, when implemented,
            will determine which constructor to call from the build plan.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IConstructorSelectorPolicy.SelectConstructor(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Choose the constructor to call for the given type.
            </summary>
      <param name="context">Current build context</param>
      <returns>The chosen constructor.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ConstructorSelectorPolicyBase`1">
      <summary>
            Base class that provides an implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IConstructorSelectorPolicy" />
            which lets you override how the parameter resolvers are created.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ConstructorSelectorPolicyBase`1.ConstructorLengthComparer.Compare(System.Reflection.ConstructorInfo,System.Reflection.ConstructorInfo)">
      <summary>
            Compares two objects and returns a value indicating whether one is less than, equal to, or greater than the other.
            </summary>
      <returns>
            Value Condition Less than zerox is less than y.Zerox equals y.Greater than zerox is greater than y.
            </returns>
      <param name="y">The second object to compare.</param>
      <param name="x">The first object to compare.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ConstructorSelectorPolicyBase`1.SelectConstructor(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
             Choose the constructor to call for the given type.
             </summary>
      <param name="context">Current build context.</param>
      <returns>The chosen constructor.</returns>
      <exception cref="T:System.InvalidOperationException">Thrown when the constructor to choose is ambiguous.</exception>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ConstructorSelectorPolicyBase`1.CreateResolver(System.Reflection.ParameterInfo)">
      <summary>
            Create a <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" /> instance for the given
            <see cref="T:System.Reflection.ParameterInfo" />.
            </summary>
      <param name="param">Parameter to create the resolver for.</param>
      <returns>The resolver object.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ConstructorSelectorPolicy`1">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IConstructorSelectorPolicy" /> that chooses
            constructors based on these criteria: first, pick a constructor marked with the
            <typeparamref name="TInjectionConstructorMarkerAttribute" /> attribute. If there
            isn't one, then choose the constructor with the longest parameter list. If that is ambiguous,
            then throw.
            </summary>
      <exception cref="T:System.InvalidOperationException">Thrown when the constructor to choose is ambiguous.</exception>
      <typeparam name="TInjectionConstructorMarkerAttribute">Attribute used to mark the constructor to call.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ConstructorSelectorPolicy`1.CreateResolver(System.Reflection.ParameterInfo)">
      <summary>
            Create a <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" /> instance for the given
            <see cref="T:System.Reflection.ParameterInfo" />.
            </summary>
      <param name="param">Parameter to create the resolver for.</param>
      <returns>The resolver object.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.SelectedMemberWithParameters">
      <summary>
            Base class for return of selector policies that need
            to keep track of a set of parameter keys.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.SelectedMemberWithParameters.AddParameterKey(System.String)">
      <summary>
            Add a new parameter key to this object. Keys are assumed
            to be in the order of the parameters to the constructor.
            </summary>
      <param name="newKey">Key for the next parameter to look up.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.SelectedMemberWithParameters.GetParameterKeys">
      <summary>
            The set of keys for the constructor parameters.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.SelectedMemberWithParameters`1">
      <summary>
            Base class for return values from selector policies that
            return a memberinfo of some sort plus a list of parameter
            keys to look up the parameter resolvers.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.SelectedMemberWithParameters`1.#ctor(`0)">
      <summary>
            Construct a new <see cref="T:Microsoft.Practices.ObjectBuilder2.SelectedMemberWithParameters`1" />, storing
            the given member info.
            </summary>
      <param name="memberInfo">Member info to store.</param>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.SelectedMemberWithParameters`1.MemberInfo">
      <summary>
            The member info stored.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.SelectedConstructor">
      <summary>
            Objects of this type are the return value from <see cref="M:Microsoft.Practices.ObjectBuilder2.IConstructorSelectorPolicy.SelectConstructor(Microsoft.Practices.ObjectBuilder2.IBuilderContext)" />.
            It encapsulates the desired <see cref="T:System.Reflection.ConstructorInfo" /> with the string keys
            needed to look up the <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" /> for each
            parameter.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.SelectedConstructor.#ctor(System.Reflection.ConstructorInfo)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.ObjectBuilder2.SelectedConstructor" /> instance which
            contains the given constructor.
            </summary>
      <param name="constructor">
      </param>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.SelectedConstructor.Constructor">
      <summary>
            The constructor this object wraps.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.DynamicMethodConstructorStrategy">
      <summary>
            A <see cref="T:Microsoft.Practices.ObjectBuilder2.BuilderStrategy" /> that emits IL to call constructors
            as part of creating a build plan.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicMethodConstructorStrategy.PreBuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Called during the chain of responsibility for a build operation.
            </summary>
      <remarks>Existing object is an instance of <see cref="T:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext" />.</remarks>
      <param name="context">The context for the operation.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicMethodConstructorStrategy.ThrowForNullExistingObject(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            A helper method used by the generated IL to throw an exception if
            a dependency cannot be resolved.
            </summary>
      <param name="context">The <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderContext" /> currently being
            used for the build of this object.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicMethodConstructorStrategy.ThrowForResolutionFailed(System.Exception,System.String,System.String,Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            A helper method used by the generated IL to throw an exception if a parameter
            fails to resolve.
            </summary>
      <param name="inner">Inner exception to throw.</param>
      <param name="parameterName">Name of the parameter that was attempted to be resolved.</param>
      <param name="constructorSignature">String describing which constructor we were calling.</param>
      <param name="context">Current build context.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicMethodConstructorStrategy.ThrowForAttemptingToConstructInterface(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            A helper method used by the generated IL to throw an exception if
            no existing object is present, but the user is attempting to build
            an interface (usually due to the lack of a type mapping).
            </summary>
      <param name="context">
      </param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IDynamicBuilderMethodCreatorPolicy">
      <summary>
            This interface defines a policy that manages creation of the dynamic methods
            used by the ObjectBuilder code generation. This way, we can replace the details
            of how the dynamic method is created to handle differences in CLR (like Silverlight
            vs desktop) or security policies.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IDynamicBuilderMethodCreatorPolicy.CreateBuilderMethod(System.Type,System.String)">
      <summary>
            Create a builder method for the given type, using the given name.
            </summary>
      <param name="typeToBuild">Type that will be built by the generated method.</param>
      <param name="methodName">Name to give to the method.</param>
      <returns>A <see cref="T:System.Reflection.Emit.DynamicMethod" /> object with the proper signature to use
            as part of a build plan.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.DefaultDynamicBuilderMethodCreatorPolicy">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IDynamicBuilderMethodCreatorPolicy" /> that will
            check for full trust and if we're building a class or an interface. If in full
            trust, attach to the class or module of the interface respectively. If in partial
            trust, attach to the OB2 module instead.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DefaultDynamicBuilderMethodCreatorPolicy.CreateBuilderMethod(System.Type,System.String)">
      <summary>
            Create a builder method for the given type, using the given name.
            </summary>
      <param name="typeToBuild">Type that will be built by the generated method.</param>
      <param name="methodName">Name to give to the method.</param>
      <returns>A <see cref="T:System.Reflection.Emit.DynamicMethod" /> object with the proper signature to use
            as part of a build plan.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext">
      <summary>
            This object tracks the current state of the build plan generation,
            accumulates the IL, provides the preamble &amp; postamble for the dynamic
            method, and tracks things like local variables in the generated IL
            so that they can be reused across IL generation strategies.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.#ctor(System.Type,Microsoft.Practices.ObjectBuilder2.IDynamicBuilderMethodCreatorPolicy)">
      <summary>
            Create a <see cref="T:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext" /> that is initialized
            to handle creation of a dynamic method to build the given type.
            </summary>
      <param name="typeToBuild">Type that we're trying to create a build plan for.</param>
      <param name="builderMethodCreator">An <see cref="T:Microsoft.Practices.ObjectBuilder2.IDynamicBuilderMethodCreatorPolicy" /> object that actually
            creates our <see cref="T:System.Reflection.Emit.DynamicMethod" /> object.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.GetBuildMethod">
      <summary>
            Completes generation of the dynamic method and returns the
            generated dynamic method delegate.
            </summary>
      <returns>The created <see cref="T:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanMethod" /></returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.EmitLoadContext">
      <summary>
            Emit the IL to put the build context on top of the IL stack.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.EmitLoadBuildKey">
      <summary>
            Emit the IL to put the current build key on top of the IL stack.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.EmitLoadExisting">
      <summary>
            Emit the IL to put the current "existing" object on the top of the IL stack.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.EmitStoreExisting">
      <summary>
            Emit the IL to make the top of the IL stack our current "existing" object.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.EmitLoadTypeOnStack(System.Type)">
      <summary>
            Emit the IL to load the given <see cref="T:System.Type" /> object onto the top of the IL stack.
            </summary>
      <param name="t">Type to load on the stack.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.EmitResolveDependency(System.Type,System.String)">
      <summary>
            Emit the IL needed to look up an <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" /> and
            call it to get a value.
            </summary>
      <param name="dependencyType">Type of the dependency to resolve.</param>
      <param name="key">Key to look up the policy by.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.GetPropertyGetter``2(System.String)">
      <summary>
            A reflection helper method to make it easier to grab a property getter
            <see cref="T:System.Reflection.MethodInfo" /> for the given property.
            </summary>
      <typeparam name="TImplementor">Type that implements the property we want.</typeparam>
      <typeparam name="TProperty">Type of the property.</typeparam>
      <param name="name">Name of the property.</param>
      <returns>The property getter's <see cref="T:System.Reflection.MethodInfo" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.GetMethodInfo``1(System.String,System.Type[])">
      <summary>
            A reflection helper method that makes it easier to grab a <see cref="T:System.Reflection.MethodInfo" />
            for a method.
            </summary>
      <typeparam name="TImplementor">Type that implements the method we want.</typeparam>
      <param name="name">Name of the method.</param>
      <param name="argumentTypes">Types of arguments to the method.</param>
      <returns>The method's <see cref="T:System.Reflection.MethodInfo" />.</returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.IL">
      <summary>
            The underlying <see cref="T:System.Reflection.Emit.ILGenerator" /> that can be used to
            emit IL into the generated dynamic method.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.TypeToBuild">
      <summary>
            The type we're currently creating the method to build.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanMethod">
      <summary>
            A delegate type that defines the signature of the
            dynamic method created by the build plans.
            </summary>
      <param name="context">
        <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderContext" /> used to build up the object.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IBuildPlanPolicy">
      <summary>
            A build plan is an object that, when invoked, will create a new object
            or fill in a given existing one. It encapsulates all the information
            gathered by the strategies to construct a particular object.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IBuildPlanPolicy.BuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Creates an instance of this build plan's type, or fills
            in the existing type if passed in.
            </summary>
      <param name="context">Context used to build up the object.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuildPlanPolicy" /> that runs the
            given delegate to execute the plan.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IBuildPlanCreatorPolicy">
      <summary>
            A <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderPolicy" /> that can create and return an <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuildPlanPolicy" />
            for the given build key.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IBuildPlanCreatorPolicy.CreatePlan(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object)">
      <summary>
            Create a build plan using the given context and build key.
            </summary>
      <param name="context">Current build context.</param>
      <param name="buildKey">Current build key.</param>
      <returns>The build plan.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlanCreatorPolicy">
      <summary>
            An <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuildPlanCreatorPolicy" /> implementation
            that constructs a build plan via dynamic IL emission.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlanCreatorPolicy.#ctor(Microsoft.Practices.ObjectBuilder2.IStagedStrategyChain)">
      <summary>
            Construct a <see cref="T:Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlanCreatorPolicy" /> that
            uses the given strategy chain to construct the build plan.
            </summary>
      <param name="strategies">
      </param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlanCreatorPolicy.CreatePlan(Microsoft.Practices.ObjectBuilder2.IBuilderContext,System.Object)">
      <summary>
            Construct a build plan.
            </summary>
      <param name="context">The current build context.</param>
      <param name="buildKey">The current build key.</param>
      <returns>The created build plan.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.DynamicMethodCallStrategy">
      <summary>
            A <see cref="T:Microsoft.Practices.ObjectBuilder2.BuilderStrategy" /> that generates IL to call
            chosen methods (as specified by the current <see cref="T:Microsoft.Practices.ObjectBuilder2.IMethodSelectorPolicy" />)
            as part of object build up.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicMethodCallStrategy.PreBuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Called during the chain of responsibility for a build operation. The
            PreBuildUp method is called when the chain is being executed in the
            forward direction.
            </summary>
      <param name="context">Context of the build operation.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicMethodCallStrategy.ThrowOnParameterResolveFailed(System.Exception,System.String,System.String)">
      <summary>
            A helper method used by the generated IL to throw an exception
            when an injection method parameter could not be resolved.
            </summary>
      <param name="inner">Exception that provides the failure info.</param>
      <param name="methodName">Name of the method that was going to be called.</param>
      <param name="parameterName">Parameter that failed to resolve.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.DynamicMethodPropertySetterStrategy">
      <summary>
            A <see cref="T:Microsoft.Practices.ObjectBuilder2.BuilderStrategy" /> that generates IL to resolve properties
            on an object being built.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicMethodPropertySetterStrategy.PreBuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Called during the chain of responsibility for a build operation.
            </summary>
      <param name="context">The context for the operation.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DynamicMethodPropertySetterStrategy.ThrowOnFailedPropertyValueResolution(System.Exception,System.String)">
      <summary>
            A helper method called by the generated IL to throw an exception if a property's
            value cannot be resolved.
            </summary>
      <param name="inner">The actual exception that caused the resolution to fail.</param>
      <param name="propertyName">Name of the property that didn't resolve.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IMethodSelectorPolicy">
      <summary>
            An <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderPolicy" /> that will examine the given
            types and return a sequence of <see cref="T:System.Reflection.MethodInfo" /> objects
            that should be called as part of building the object.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IMethodSelectorPolicy.SelectMethods(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Return the sequence of methods to call while building the target object.
            </summary>
      <param name="context">Current build context.</param>
      <returns>Sequence of methods to call.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.MethodSelectorPolicyBase`1">
      <summary>
            Base class that provides an implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IMethodSelectorPolicy" />
            which lets you override how the parameter resolvers are created.
            </summary>
      <typeparam name="TMarkerAttribute">Attribute that marks methods that should
            be called.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.MethodSelectorPolicyBase`1.SelectMethods(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Return the sequence of methods to call while building the target object.
            </summary>
      <param name="context">Current build context.</param>
      <returns>Sequence of methods to call.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.MethodSelectorPolicyBase`1.CreateResolver(System.Reflection.ParameterInfo)">
      <summary>
            Create a <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" /> instance for the given
            <see cref="T:System.Reflection.ParameterInfo" />.
            </summary>
      <param name="parameter">Parameter to create the resolver for.</param>
      <returns>The resolver object.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.MethodSelectorPolicy`1">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IMethodSelectorPolicy" /> that selects
            methods by looking for the given <typeparamref name="TMarkerAttribute" />
            attribute on those methods.
            </summary>
      <typeparam name="TMarkerAttribute">Type of attribute used to mark methods
            to inject.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.MethodSelectorPolicy`1.CreateResolver(System.Reflection.ParameterInfo)">
      <summary>
            Create a <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" /> instance for the given
            <see cref="T:System.Reflection.ParameterInfo" />.
            </summary>
      <param name="parameter">Parameter to create the resolver for.</param>
      <returns>The resolver object.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.SelectedMethod">
      <summary>
            Objects of this type are the return value from <see cref="M:Microsoft.Practices.ObjectBuilder2.IMethodSelectorPolicy.SelectMethods(Microsoft.Practices.ObjectBuilder2.IBuilderContext)" />.
            It encapsulates the desired <see cref="T:System.Reflection.MethodInfo" /> with the string keys
            needed to look up the <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" /> for each
            parameter.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.SelectedMethod.#ctor(System.Reflection.MethodInfo)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.ObjectBuilder2.SelectedMethod" /> instance which
            contains the given method.
            </summary>
      <param name="method">The method</param>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.SelectedMethod.Method">
      <summary>
            The constructor this object wraps.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IPropertySelectorPolicy">
      <summary>
            An <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderPolicy" /> that returns a sequence
            of properties that should be injected for the given type.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPropertySelectorPolicy.SelectProperties(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Returns sequence of properties on the given type that
            should be set as part of building that object.
            </summary>
      <param name="context">Current build context.</param>
      <returns>Sequence of <see cref="T:System.Reflection.PropertyInfo" /> objects
            that contain the properties to set.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.PropertySelectorBase`1">
      <summary>
            Base class that provides an implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IPropertySelectorPolicy" />
            which lets you override how the parameter resolvers are created.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PropertySelectorBase`1.SelectProperties(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Returns sequence of properties on the given type that
            should be set as part of building that object.
            </summary>
      <param name="context">current build context.</param>
      <returns>Sequence of <see cref="T:System.Reflection.PropertyInfo" /> objects
            that contain the properties to set.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PropertySelectorBase`1.CreateResolver(System.Reflection.PropertyInfo)">
      <summary>
            Create a <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" /> for the given
            property.
            </summary>
      <param name="property">Property to create resolver for.</param>
      <returns>The resolver object.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.PropertySelectorPolicy`1">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IPropertySelectorPolicy" /> that looks
            for properties marked with the <typeparamref name="TResolutionAttribute" />
            attribute that are also settable and not indexers.
            </summary>
      <typeparam name="TResolutionAttribute">
      </typeparam>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PropertySelectorPolicy`1.CreateResolver(System.Reflection.PropertyInfo)">
      <summary>
            Create a <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" /> for the given
            property.
            </summary>
      <param name="property">Property to create resolver for.</param>
      <returns>The resolver object.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.SelectedProperty">
      <summary>
            Objects of this type are returned from
            <see cref="M:Microsoft.Practices.ObjectBuilder2.IPropertySelectorPolicy.SelectProperties(Microsoft.Practices.ObjectBuilder2.IBuilderContext)" />.
            This class combines the <see cref="T:System.Reflection.PropertyInfo" /> about
            the property with the string key used to look up the resolver
            for this property's value.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.SelectedProperty.#ctor(System.Reflection.PropertyInfo,System.String)">
      <summary>
            Create an instance of <see cref="T:Microsoft.Practices.ObjectBuilder2.SelectedProperty" />
            with the given <see cref="T:System.Reflection.PropertyInfo" /> and key.
            </summary>
      <param name="property">The property.</param>
      <param name="key">Key to use to look up the resolver.</param>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.SelectedProperty.Property">
      <summary>
            PropertyInfo for this property.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.SelectedProperty.Key">
      <summary>
            Key to look up this property's resolver.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverTrackerPolicy">
      <summary>
            A builder policy that lets you keep track of the current
            resolvers and will remove them from the given policy set.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IDependencyResolverTrackerPolicy.AddResolverKey(System.Object)">
      <summary>
            Add a new resolver to track by key.
            </summary>
      <param name="key">Key that was used to add the resolver to the policy set.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IDependencyResolverTrackerPolicy.RemoveResolvers(Microsoft.Practices.ObjectBuilder2.IPolicyList)">
      <summary>
            Remove the currently tracked resolvers from the given policy list.
            </summary>
      <param name="policies">Policy list to remove the resolvers from.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.DependencyResolverTrackerPolicy">
      <summary>
            Implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverTrackerPolicy" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DependencyResolverTrackerPolicy.AddResolverKey(System.Object)">
      <summary>
            Add a new resolver to track by key.
            </summary>
      <param name="key">Key that was used to add the resolver to the policy set.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DependencyResolverTrackerPolicy.RemoveResolvers(Microsoft.Practices.ObjectBuilder2.IPolicyList)">
      <summary>
            Remove the currently tracked resolvers from the given policy list.
            </summary>
      <param name="policies">Policy list to remove the resolvers from.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DependencyResolverTrackerPolicy.GetTracker(Microsoft.Practices.ObjectBuilder2.IPolicyList,System.Object)">
      <summary>
            Get an instance that implements <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverTrackerPolicy" />,
            either the current one in the policy set or creating a new one if it doesn't
            exist.
            </summary>
      <param name="policies">Policy list to look up from.</param>
      <param name="buildKey">Build key to track.</param>
      <returns>The resolver tracker.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DependencyResolverTrackerPolicy.TrackKey(Microsoft.Practices.ObjectBuilder2.IPolicyList,System.Object,System.Object)">
      <summary>
            Add a key to be tracked to the current tracker.
            </summary>
      <param name="policies">Policy list containing the resolvers and trackers.</param>
      <param name="buildKey">Build key for the resolvers being tracked.</param>
      <param name="resolverKey">Key for the resolver.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.DependencyResolverTrackerPolicy.RemoveResolvers(Microsoft.Practices.ObjectBuilder2.IPolicyList,System.Object)">
      <summary>
            Remove the resolvers for the given build key.
            </summary>
      <param name="policies">Policy list containing the build key.</param>
      <param name="buildKey">Build key.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy">
      <summary>
            A <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderPolicy" /> that is used at build plan execution time
            to resolve a dependent value.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy.Resolve(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Get the value for a dependency.
            </summary>
      <param name="context">Current build context.</param>
      <returns>The value for the dependency.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.FixedTypeResolverPolicy">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" /> that
            calls back into the build chain to build up the dependency, passing
            a type given at compile time as its build key.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.FixedTypeResolverPolicy.#ctor(System.Type)">
      <summary>
            Create a new instance storing the given type.
            </summary>
      <param name="typeToBuild">Type to resolve.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.FixedTypeResolverPolicy.Resolve(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Get the value for a dependency.
            </summary>
      <param name="context">Current build context.</param>
      <returns>The value for the dependency.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IPolicyList">
      <summary>
            A custom collection over <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderPolicy" /> objects.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.Clear``1(System.Object)">
      <summary>
            Removes an individual policy type for a build key.
            </summary>
      <typeparam name="TPolicyInterface">The type the policy was registered as.</typeparam>
      <param name="buildKey">The key the policy applies.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.Clear(System.Type,System.Object)">
      <summary>
            Removes an individual policy type for a build key.
            </summary>
      <param name="policyInterface">The type of policy to remove.</param>
      <param name="buildKey">The key the policy applies.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.ClearAll">
      <summary>
            Removes all policies from the list.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.ClearDefault``1">
      <summary>
            Removes a default policy.
            </summary>
      <typeparam name="TPolicyInterface">The type the policy was registered as.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.ClearDefault(System.Type)">
      <summary>
            Removes a default policy.
            </summary>
      <param name="policyInterface">The type the policy was registered as.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.Get``1(System.Object)">
      <summary>
            Gets an individual policy.
            </summary>
      <typeparam name="TPolicyInterface">The interface the policy is registered under.</typeparam>
      <param name="buildKey">The key the policy applies.</param>
      <returns>The policy in the list, if present; returns null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.Get(System.Type,System.Object)">
      <summary>
            Gets an individual policy.
            </summary>
      <param name="policyInterface">The interface the policy is registered under.</param>
      <param name="buildKey">The key the policy applies.</param>
      <returns>The policy in the list, if present; returns null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.Get``1(System.Object,System.Boolean)">
      <summary>
            Gets an individual policy.
            </summary>
      <typeparam name="TPolicyInterface">The interface the policy is registered under.</typeparam>
      <param name="buildKey">The key the policy applies.</param>
      <param name="localOnly">true if the policy searches local only; otherwise false to seach up the parent chain.</param>
      <returns>The policy in the list, if present; returns null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.Get(System.Type,System.Object,System.Boolean)">
      <summary>
            Gets an individual policy.
            </summary>
      <param name="policyInterface">The interface the policy is registered under.</param>
      <param name="buildKey">The key the policy applies.</param>
      <param name="localOnly">true if the policy searches local only; otherwise false to seach up the parent chain.</param>
      <returns>The policy in the list, if present; returns null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.GetNoDefault``1(System.Object,System.Boolean)">
      <summary>
            Get the non default policy.
            </summary>
      <typeparam name="TPolicyInterface">The interface the policy is registered under.</typeparam>
      <param name="buildKey">The key the policy applies.</param>
      <param name="localOnly">true if the policy searches local only; otherwise false to seach up the parent chain.</param>
      <returns>The policy in the list, if present; returns null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.GetNoDefault(System.Type,System.Object,System.Boolean)">
      <summary>
            Get the non default policy.
            </summary>
      <param name="policyInterface">The interface the policy is registered under.</param>
      <param name="buildKey">The key the policy applies.</param>
      <param name="localOnly">true if the policy searches local only; otherwise false to seach up the parent chain.</param>
      <returns>The policy in the list, if present; returns null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.Set``1(``0,System.Object)">
      <summary>
            Sets an individual policy.
            </summary>
      <typeparam name="TPolicyInterface">The interface the policy is registered under.</typeparam>
      <param name="policy">The policy to be registered.</param>
      <param name="buildKey">The key the policy applies.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.Set(System.Type,Microsoft.Practices.ObjectBuilder2.IBuilderPolicy,System.Object)">
      <summary>
            Sets an individual policy.
            </summary>
      <param name="policyInterface">The <see cref="T:System.Type" /> of the policy.</param>
      <param name="policy">The policy to be registered.</param>
      <param name="buildKey">The key the policy applies.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.SetDefault``1(``0)">
      <summary>
            Sets a default policy. When checking for a policy, if no specific individual policy
            is available, the default will be used.
            </summary>
      <typeparam name="TPolicyInterface">The interface to register the policy under.</typeparam>
      <param name="policy">The default policy to be registered.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IPolicyList.SetDefault(System.Type,Microsoft.Practices.ObjectBuilder2.IBuilderPolicy)">
      <summary>
            Sets a default policy. When checking for a policy, if no specific individual policy
            is available, the default will be used.
            </summary>
      <param name="policyInterface">The interface to register the policy under.</param>
      <param name="policy">The default policy to be registered.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IStagedStrategyChain">
      <summary>
            This interface defines a standard method to convert any 
            <see cref="T:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1" /> regardless
            of the stage enum into a regular, flat strategy chain.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IStagedStrategyChain.MakeStrategyChain">
      <summary>
            Convert this <see cref="T:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1" /> into
            a flat <see cref="T:Microsoft.Practices.ObjectBuilder2.IStrategyChain" />.
            </summary>
      <returns>The flattened <see cref="T:Microsoft.Practices.ObjectBuilder2.IStrategyChain" />.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IStrategyChain">
      <summary>
            Represents a chain of responsibility for builder strategies.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IStrategyChain.Reverse">
      <summary>
            Reverse the order of the strategy chain.
            </summary>
      <returns>The reversed strategy chain.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IStrategyChain.ExecuteBuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Execute this strategy chain against the given context,
            calling the Buildup methods on the strategies.
            </summary>
      <param name="context">Context for the build process.</param>
      <returns>The build up object</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IStrategyChain.ExecuteTearDown(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Execute this strategy chain against the given context,
            calling the TearDown methods on the strategies.
            </summary>
      <param name="context">Context for the teardown process.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IBuildKey">
      <summary>
            Represents a build key based on type.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IBuildKey.ReplaceType(System.Type)">
      <summary>
            Construct a new build key object with the current type
            replaced with the specified <paramref name="newType" />.
            </summary>
      <remarks>This method creates a new build key object, the original is unchanged.</remarks>
      <param name="newType">New type to place in the build key.</param>
      <returns>The new build key.</returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IBuildKey.Type">
      <summary>
            Gets the <see cref="P:Microsoft.Practices.ObjectBuilder2.IBuildKey.Type" /> that represents the key.
            </summary>
      <value>
            The <see cref="P:Microsoft.Practices.ObjectBuilder2.IBuildKey.Type" /> that represents the key.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer">
      <summary>
            Represents a lifetime container.
            </summary>
      <remarks>
            A lifetime container tracks the lifetime of an object, and implements
            IDisposable. When the container is disposed, any objects in the
            container which implement IDisposable are also disposed.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer.Add(System.Object)">
      <summary>
            Adds an object to the lifetime container.
            </summary>
      <param name="item">The item to be added to the lifetime container.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer.Contains(System.Object)">
      <summary>
            Determine if a given object is in the lifetime container.
            </summary>
      <param name="item">
            The item to locate in the lifetime container.
            </param>
      <returns>
            Returns true if the object is contained in the lifetime
            container; returns false otherwise.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer.Remove(System.Object)">
      <summary>
            Removes an item from the lifetime container. The item is
            not disposed.
            </summary>
      <param name="item">The item to be removed.</param>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer.Count">
      <summary>
            Gets the number of references in the lifetime container
            </summary>
      <value>
            The number of references in the lifetime container
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.LifetimeContainer">
      <summary>
            Represents a lifetime container.
            </summary>
      <remarks>
            A lifetime container tracks the lifetime of an object, and implements
            IDisposable. When the container is disposed, any objects in the
            container which implement IDisposable are also disposed.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.LifetimeContainer.Add(System.Object)">
      <summary>
            Adds an object to the lifetime container.
            </summary>
      <param name="item">The item to be added to the lifetime container.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.LifetimeContainer.Contains(System.Object)">
      <summary>
            Determine if a given object is in the lifetime container.
            </summary>
      <param name="item">
            The item to locate in the lifetime container.
            </param>
      <returns>
            Returns true if the object is contained in the lifetime
            container; returns false otherwise.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.LifetimeContainer.Dispose">
      <summary>
            Releases the resources used by the <see cref="T:Microsoft.Practices.ObjectBuilder2.LifetimeContainer" />. 
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.LifetimeContainer.Dispose(System.Boolean)">
      <summary>
            Releases the managed resources used by the DbDataReader and optionally releases the unmanaged resources. 
            </summary>
      <param name="disposing">
            true to release managed and unmanaged resources; false to release only unmanaged resources.
            </param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.LifetimeContainer.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the lifetime container.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the life time container. 
            </returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.LifetimeContainer.Remove(System.Object)">
      <summary>
            Removes an item from the lifetime container. The item is
            not disposed.
            </summary>
      <param name="item">The item to be removed.</param>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.LifetimeContainer.Count">
      <summary>
            Gets the number of references in the lifetime container
            </summary>
      <value>
            The number of references in the lifetime container
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IReadableLocator">
      <summary>
            Represents a locator that can be read from.
            </summary>
      <remarks>
        <para>A locator is a dictionary of keys to values, but it keeps the values with
            weak references, so that locating an object does not keep it alive. If you
            want to keep the object alive too, you should consider using an
            <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" />.</para>
        <para>Locators have a built-in concept of hierarchy, so you can ask questions
            of a locator and tell it whether to return results from the current locator
            only, or whether to ask the parent locator when local lookups fail.</para>
      </remarks>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IReadableLocator.Contains(System.Object)">
      <summary>
            Determine if the locator contains an object for the given key.
            </summary>
      <param name="key">The key to check.</param>
      <returns>
            true if the locator contains an object for the key; returns
            false otherwise.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IReadableLocator.FindBy(System.Predicate{System.Collections.Generic.KeyValuePair{System.Object,System.Object}})">
      <summary>
            Finds objects in the locator using the predicate, and returns a temporary locator
            filled with the found objects.
            </summary>
      <param name="predicate">The predicate to test whether to include an object.</param>
      <returns>The new locator</returns>
      <exception cref="T:System.ArgumentNullException">Predicate is null.</exception>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IReadableLocator.Get``1">
      <summary>
            Gets an object from the locator, registered with the key of typeof(T).
            </summary>
      <typeparam name="TItem">The type of the object to find.</typeparam>
      <returns>The object, if found; null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IReadableLocator.Get``1(System.Object)">
      <summary>
            Gets an object from the locator, registered with the given key.
            </summary>
      <typeparam name="TItem">The type of the object to find.</typeparam>
      <param name="key">The key that the object is registered with.</param>
      <returns>The object, if found; null otherwise.</returns>
      <exception cref="T:System.ArgumentNullException">Key is null.</exception>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IReadableLocator.Get(System.Object)">
      <summary>
            Gets an object from the locator, registered with the given key.
            </summary>
      <param name="key">The key that the object is registered with.</param>
      <returns>The object, if found; null otherwise.</returns>
      <exception cref="T:System.ArgumentNullException">Key is null.</exception>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IReadableLocator.Count">
      <summary>
            Gets the number of items in the locator.
            </summary>
      <value>
            The number of items in the locator.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IReadableLocator.ParentLocator">
      <summary>
            Gets the parent locator.
            </summary>
      <value>
            The parent locator.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.IReadableLocator.ReadOnly">
      <summary>
            Determines if the locator is read-only.
            </summary>
      <value>
            true if the locator is read-only; otherwise, false.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IReadWriteLocator">
      <summary>
            Represents a locator that can be read from and written to.
            </summary>
      <remarks>
        <para>
            A locator is dictionary of keys to values, but it keeps the values with
            weak references, so that locating an object does not keep it alive. If you
            want to keep the object alive too, you should consider using an
            <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" />.
            </para>
        <para>
            Locators have a built-in concept of hierarchy, so you can ask questions
            of a locator and tell it whether to return results from the current locator
            only, or whether to ask the parent locator when local lookups fail.</para>
      </remarks>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IReadWriteLocator.Add(System.Object,System.Object)">
      <summary>
            Adds an object to the locator, with the given key.
            </summary>
      <param name="key">The key to register the object with.</param>
      <param name="value">The object to be registered.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> or value are null.</exception>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IReadWriteLocator.Remove(System.Object)">
      <summary>
            Removes an object from the locator.
            </summary>
      <param name="key">The key under which the object was registered.</param>
      <returns>
            Returns true if the object was found in the locator; returns
            false otherwise.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is null.</exception>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ReadableLocator">
      <summary>
            Represents an abstract implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadableLocator" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadableLocator.#ctor">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.ReadableLocator" /> class.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadableLocator.#ctor(Microsoft.Practices.ObjectBuilder2.IReadableLocator)">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.ReadableLocator" /> class with a parent <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadableLocator" />.
            </summary>
      <param name="parentLocator">A parent <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadableLocator" />.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadableLocator.Contains(System.Object)">
      <summary>
            Determine if the locator contains an object for the given key.
            </summary>
      <param name="key">The key to check.</param>
      <returns>
            true if the locator contains an object for the key; returns
            false otherwise.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadableLocator.FindBy(System.Predicate{System.Collections.Generic.KeyValuePair{System.Object,System.Object}})">
      <summary>
            Finds objects in the locator using the predicate, and returns a temporary locator
            filled with the found objects.
            </summary>
      <param name="predicate">The predicate to test whether to include an object.</param>
      <returns>The new locator</returns>
      <exception cref="T:System.ArgumentNullException">Predicate is null.</exception>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadableLocator.Get``1">
      <summary>
            Gets an object from the locator, registered with the key of typeof(T).
            </summary>
      <typeparam name="TItem">The type of the object to find.</typeparam>
      <returns>The object, if found; null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadableLocator.Get``1(System.Object)">
      <summary>
            Gets an object from the locator, registered with the given key.
            </summary>
      <typeparam name="TItem">The type of the object to find.</typeparam>
      <param name="key">The key that the object is registered with.</param>
      <returns>The object, if found; null otherwise.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is null.</exception>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadableLocator.Get(System.Object)">
      <summary>
            Gets an object from the locator, registered with the given key.
            </summary>
      <param name="key">The key that the object is registered with.</param>
      <returns>The object, if found; null otherwise.</returns>
      <exception cref="T:System.ArgumentNullException">Key is null.</exception>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadableLocator.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the locator.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the locator. 
            </returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.ReadableLocator.Count">
      <summary>
            Gets the number of items in the locator.
            </summary>
      <value>
            The number of items in the locator.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.ReadableLocator.ParentLocator">
      <summary>
            Gets the parent locator.
            </summary>
      <value>
            The parent locator.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.ReadableLocator.ReadOnly">
      <summary>
            Determines if the locator is read-only.
            </summary>
      <value>
            true if the locator is read-only; otherwise, false.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ReadWriteLocator">
      <summary>
            Represents an abstract implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadWriteLocator" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadWriteLocator.#ctor">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.ReadWriteLocator" /> class.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadWriteLocator.#ctor(Microsoft.Practices.ObjectBuilder2.IReadableLocator)">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.ReadWriteLocator" /> class with a parent <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadableLocator" />.
            </summary>
      <param name="parentLocator">A parent <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadableLocator" />.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadWriteLocator.Add(System.Object,System.Object)">
      <summary>
            Adds an object to the locator, with the given key.
            </summary>
      <param name="key">The key to register the object with.</param>
      <param name="value">The object to be registered.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> or value are null.</exception>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadWriteLocator.Remove(System.Object)">
      <summary>
            Removes an object from the locator.
            </summary>
      <param name="key">The key under which the object was registered.</param>
      <returns>
            Returns true if the object was found in the locator; returns
            false otherwise.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is null.</exception>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.ReadWriteLocator.ReadOnly">
      <summary>
            Determines if the locator is read-only.
            </summary>
      <value>
            true if the locator is read-only; otherwise, false.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.Locator">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadableLocator" /> and <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadWriteLocator" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Locator.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.Locator" /> class. 
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Locator.#ctor(Microsoft.Practices.ObjectBuilder2.IReadableLocator)">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.Locator" /> class as a child of the <paramref name="parentLocator" />. 
            </summary>
      <param name="parentLocator">The parent locator.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Locator.Add(System.Object,System.Object)">
      <summary>
            Adds an object to the locator, with the given key.
            </summary>
      <param name="key">The key to register the object with.</param>
      <param name="value">The object to be registered.</param>
      <exception cref="T:System.ArgumentNullException">Key or value are null.</exception>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Locator.Contains(System.Object)">
      <summary>
            Determine if the locator contains an object for the given key.
            </summary>
      <param name="key">The key to check.</param>
      <returns>
            true if the locator contains an object for the key; returns
            false otherwise.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Locator.Get(System.Object)">
      <summary>
            Gets an object from the locator, registered with the given key.
            </summary>
      <param name="key">The key that the object is registered with.</param>
      <returns>The object, if found; null otherwise.</returns>
      <exception cref="T:System.ArgumentNullException">Key is null.</exception>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Locator.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through a locator.
            </summary>
      <returns>
            An <see cref="T:System.Collections.Generic.IEnumerator`1" /> object that can be used to iterate through the locator. 
            </returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Locator.Remove(System.Object)">
      <summary>
            Removes an object from the locator.
            </summary>
      <param name="key">The key under which the object was registered.</param>
      <returns>
            Returns true if the object was found in the locator; returns
            false otherwise.
            </returns>
      <exception cref="T:System.ArgumentNullException">Key is null.</exception>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.Locator.Count">
      <summary>
            Gets the number of items in the locator.
            </summary>
      <value>
            The number of items in the locator.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ReadOnlyLocator">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadableLocator" /> that wraps an existing locator
            to ensure items are not written into the locator.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadOnlyLocator.#ctor(Microsoft.Practices.ObjectBuilder2.IReadableLocator)">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.ReadableLocator" /> class with an <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadableLocator" /> to wrap.
            </summary>
      <param name="innerLocator">The inner locator to be wrapped.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadOnlyLocator.Contains(System.Object)">
      <summary>
            Determine if the locator contains an object for the given key.
            </summary>
      <param name="key">The key to check.</param>
      <returns>
            true if the locator contains an object for the key; returns
            false otherwise.
            </returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadOnlyLocator.Get(System.Object)">
      <summary>
            Gets an object from the locator, registered with the given key.
            </summary>
      <param name="key">The key that the object is registered with.</param>
      <returns>The object, if found; null otherwise.</returns>
      <exception cref="T:System.ArgumentNullException">Key is null.</exception>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ReadOnlyLocator.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the locator.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the locator. 
            </returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.ReadOnlyLocator.Count">
      <summary>
            Gets the number of items in the locator.
            </summary>
      <value>
            The number of items in the locator.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.ReadOnlyLocator.ParentLocator">
      <summary>
            Gets the parent locator.
            </summary>
      <value>
            The parent locator.
            </value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.ReadOnlyLocator.ReadOnly">
      <summary>
            Determines if the locator is read-only.
            </summary>
      <value>
            true if the locator is read-only; otherwise, false.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.PolicyList">
      <summary>
            A custom collection wrapper over <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderPolicy" /> objects.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.#ctor">
      <summary>
            Initialize a new instance of a <see cref="T:Microsoft.Practices.ObjectBuilder2.PolicyList" /> class.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.#ctor(Microsoft.Practices.ObjectBuilder2.IPolicyList)">
      <summary>
            Initialize a new instance of a <see cref="T:Microsoft.Practices.ObjectBuilder2.PolicyList" /> class with another policy list.
            </summary>
      <param name="innerPolicyList">An inner policy list to search.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.Clear``1(System.Object)">
      <summary>
            Removes an individual policy type for a build key.
            </summary>
      <typeparam name="TPolicyInterface">The type the policy was registered as.</typeparam>
      <param name="buildKey">The key the policy applies.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.Clear(System.Type,System.Object)">
      <summary>
            Removes an individual policy type for a build key.
            </summary>
      <param name="policyInterface">The type of policy to remove.</param>
      <param name="buildKey">The key the policy applies.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.ClearAll">
      <summary>
            Removes all policies from the list.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.ClearDefault``1">
      <summary>
            Removes a default policy.
            </summary>
      <typeparam name="TPolicyInterface">The type the policy was registered as.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.ClearDefault(System.Type)">
      <summary>
            Removes a default policy.
            </summary>
      <param name="policyInterface">The type the policy was registered as.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.Get``1(System.Object)">
      <summary>
            Gets an individual policy.
            </summary>
      <typeparam name="TPolicyInterface">The interface the policy is registered under.</typeparam>
      <param name="buildKey">The key the policy applies.</param>
      <returns>The policy in the list, if present; returns null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.Get(System.Type,System.Object)">
      <summary>
            Gets an individual policy.
            </summary>
      <param name="policyInterface">The interface the policy is registered under.</param>
      <param name="buildKey">The key the policy applies.</param>
      <returns>The policy in the list, if present; returns null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.Get``1(System.Object,System.Boolean)">
      <summary>
            Gets an individual policy.
            </summary>
      <typeparam name="TPolicyInterface">The interface the policy is registered under.</typeparam>
      <param name="buildKey">The key the policy applies.</param>
      <param name="localOnly">true if the policy searches local only; otherwise false to seach up the parent chain.</param>
      <returns>The policy in the list, if present; returns null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.Get(System.Type,System.Object,System.Boolean)">
      <summary>
            Gets an individual policy.
            </summary>
      <param name="policyInterface">The interface the policy is registered under.</param>
      <param name="buildKey">The key the policy applies.</param>
      <param name="localOnly">true if the policy searches local only; otherwise false to seach up the parent chain.</param>
      <returns>The policy in the list, if present; returns null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.GetNoDefault``1(System.Object,System.Boolean)">
      <summary>
            Get the non default policy.
            </summary>
      <typeparam name="TPolicyInterface">The interface the policy is registered under.</typeparam>
      <param name="buildKey">The key the policy applies.</param>
      <param name="localOnly">true if the policy searches local only; otherwise false to seach up the parent chain.</param>
      <returns>The policy in the list, if present; returns null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.GetNoDefault(System.Type,System.Object,System.Boolean)">
      <summary>
            Get the non default policy.
            </summary>
      <param name="policyInterface">The interface the policy is registered under.</param>
      <param name="buildKey">The key the policy applies.</param>
      <param name="localOnly">true if the policy searches local only; otherwise false to seach up the parent chain.</param>
      <returns>The policy in the list, if present; returns null otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.Set``1(``0,System.Object)">
      <summary>
            Sets an individual policy.
            </summary>
      <typeparam name="TPolicyInterface">The interface the policy is registered under.</typeparam>
      <param name="policy">The policy to be registered.</param>
      <param name="buildKey">The key the policy applies.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.Set(System.Type,Microsoft.Practices.ObjectBuilder2.IBuilderPolicy,System.Object)">
      <summary>
            Sets an individual policy.
            </summary>
      <param name="policyInterface">The <see cref="T:System.Type" /> of the policy.</param>
      <param name="policy">The policy to be registered.</param>
      <param name="buildKey">The key the policy applies.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.SetDefault``1(``0)">
      <summary>
            Sets a default policy. When checking for a policy, if no specific individual policy
            is available, the default will be used.
            </summary>
      <typeparam name="TPolicyInterface">The interface to register the policy under.</typeparam>
      <param name="policy">The default policy to be registered.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.PolicyList.SetDefault(System.Type,Microsoft.Practices.ObjectBuilder2.IBuilderPolicy)">
      <summary>
            Sets a default policy. When checking for a policy, if no specific individual policy
            is available, the default will be used.
            </summary>
      <param name="policyInterface">The interface to register the policy under.</param>
      <param name="policy">The default policy to be registered.</param>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.PolicyList.Count">
      <summary>
            Gets the number of items in the locator.
            </summary>
      <value>
            The number of items in the locator.
            </value>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ILifetimeFactoryPolicy">
      <summary>
            A builder policy used to create lifetime policy instances.
            Used by the LifetimeStrategy when instantiating open
            generic types.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ILifetimeFactoryPolicy.CreateLifetimePolicy">
      <summary>
            Create a new instance of <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimePolicy" />.
            </summary>
      <returns>The new instance.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.ILifetimePolicy">
      <summary>
            A <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderPolicy" /> that controls how instances are
            persisted and recovered from an external store. Used to implement
            things like singletons and per-http-request lifetime.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ILifetimePolicy.GetValue">
      <summary>
            Retrieve a value from the backing store associated with this Lifetime policy.
            </summary>
      <returns>the object desired, or null if no such object is currently stored.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ILifetimePolicy.SetValue(System.Object)">
      <summary>
            Stores the given value into backing store for retrieval later.
            </summary>
      <param name="newValue">The object to store.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.ILifetimePolicy.RemoveValue">
      <summary>
            Remove the value this lifetime policy is managing from backing store.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.LifetimeStrategy">
      <summary>
            An <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderStrategy" /> implementation that uses
            a <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimePolicy" /> to figure out if an object
            has already been created and to update or remove that
            object from some backing store.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.LifetimeStrategy.PreBuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Called during the chain of responsibility for a build operation. The
            PreBuildUp method is called when the chain is being executed in the
            forward direction.
            </summary>
      <param name="context">Context of the build operation.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.LifetimeStrategy.PostBuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Called during the chain of responsibility for a build operation. The
            PostBuildUp method is called when the chain has finished the PreBuildUp
            phase and executes in reverse order from the PreBuildUp calls.
            </summary>
      <param name="context">Context of the build operation.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.SingletonLifetimePolicy">
      <summary>
            A <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimePolicy" /> that stores objects in the locator and
            lifetime container provided by the context.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.SingletonLifetimePolicy.GetValue">
      <summary>
            Retrieve a value from the backing store associated with this Lifetime policy.
            </summary>
      <returns>the object desired, or null if no such object is currently stored.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.SingletonLifetimePolicy.SetValue(System.Object)">
      <summary>
            Stores the given value into backing store for retrieval later.
            </summary>
      <param name="newValue">The object being stored.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.SingletonLifetimePolicy.RemoveValue">
      <summary>
            Remove the given object from backing store.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.SingletonLifetimePolicy.Recover">
      <summary>
            A method that does whatever is needed to clean up
            as part of cleaning up after an exception.
            </summary>
      <remarks>
            Don't do anything that could throw in this method,
            it will cause later recover operations to get skipped
            and play real havok with the stack trace.
            </remarks>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.TransientLifetimePolicy">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimePolicy" /> that does nothing,
            ensuring that a new object gets created every time.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.TransientLifetimePolicy.GetValue">
      <summary>
            Retrieve a value from the backing store associated with this Lifetime policy.
            </summary>
      <returns>the object desired, or null if no such object is currently stored.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.TransientLifetimePolicy.SetValue(System.Object)">
      <summary>
            Stores the given value into backing store for retrieval later.
            </summary>
      <param name="newValue">The object being stored.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.TransientLifetimePolicy.RemoveValue">
      <summary>
            Remove the given object from backing store.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1">
      <summary>
            Represents a chain of responsibility for builder strategies partitioned by stages.
            </summary>
      <typeparam name="TStageEnum">The stage enumeration to partition the strategies.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1.#ctor">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1" /> class.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1.#ctor(Microsoft.Practices.ObjectBuilder2.StagedStrategyChain{`0})">
      <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1" /> class with an inner strategy chain to use when building.
            </summary>
      <param name="innerChain">The inner strategy chain to use first when finding strategies in the build operation.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1.Add(Microsoft.Practices.ObjectBuilder2.IBuilderStrategy,`0)">
      <summary>
            Adds a strategy to the chain at a particular stage.
            </summary>
      <param name="strategy">The strategy to add to the chain.</param>
      <param name="stage">The stage to add the strategy.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1.AddNew``1(`0)">
      <summary>
            Add a new strategy for the <paramref name="stage" />.
            </summary>
      <typeparam name="TStrategy">The <see cref="T:System.Type" /> of <see cref="T:Microsoft.Practices.ObjectBuilder2.IBuilderStrategy" /></typeparam>
      <param name="stage">The stage to add the strategy.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1.Clear">
      <summary>
            Clear the current strategy chain list.
            </summary>
      <remarks>
            This will not clear the inner strategy chain if this instane was created with one.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1.MakeStrategyChain">
      <summary>
            Makes a strategy chain based on this instance.
            </summary>
      <returns>A new <see cref="T:Microsoft.Practices.ObjectBuilder2.StrategyChain" />.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.StrategyChain">
      <summary>
            Represents a chain of responsibility for builder strategies.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StrategyChain.#ctor">
      <summary>
            Initialzie a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.StrategyChain" /> class.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StrategyChain.#ctor(System.Collections.IEnumerable)">
      <summary>
            Initialzie a new instance of the <see cref="T:Microsoft.Practices.ObjectBuilder2.StrategyChain" /> class with a colleciton of strategies.
            </summary>
      <param name="strategies">A collection of strategies to initialize the chain.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StrategyChain.Add(Microsoft.Practices.ObjectBuilder2.IBuilderStrategy)">
      <summary>
            Adds a strategy to the chain.
            </summary>
      <param name="strategy">The strategy to add to the chain.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StrategyChain.AddRange(System.Collections.IEnumerable)">
      <summary>
            Adds strategies to the chain.
            </summary>
      <param name="strategyEnumerable">The strategies to add to the chain.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StrategyChain.Reverse">
      <summary>
            Reverse the order of the strategy chain.
            </summary>
      <returns>The reversed strategy chain.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Execute this strategy chain against the given context to build up.
            </summary>
      <param name="context">Context for the build processes.</param>
      <returns>The build up object</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteTearDown(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Execute this strategy chain against the given context,
            calling the TearDown methods on the strategies.
            </summary>
      <param name="context">Context for the teardown process.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.StrategyChain.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator"></see> object that can be used to iterate through the collection.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.BuildKey">
      <summary>
            Utility methods for dealing with arbitrary build key objects.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuildKey.GetType(System.Object)">
      <summary>
            Gets the <see cref="T:System.Type" /> of object to build from the build key.
            </summary>
      <param name="buildKey">The build key to get the <see cref="T:System.Type" />.</param>
      <returns>The <see cref="T:System.Type" /> of object to build from the key.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuildKey.TryGetType(System.Object,System.Type@)">
      <summary>
            Tries to get the <see cref="T:System.Type" /> from <paramref name="buildKey" />.
            </summary>
      <param name="buildKey">The build key to get the <see cref="T:System.Type" />.</param>
      <param name="type">
      </param>
      <returns>true if the <see cref="T:System.Type" /> was found; otherwise, false.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.BuildKey.ReplaceType(System.Object,System.Type)">
      <summary>
            Given a <paramref name="buildKey" />, return a new build key
            which is the same as the original, except that the type has
            been replaced with <paramref name="newType" />.
            </summary>
      <param name="buildKey">original build key</param>
      <param name="newType">New type to put in new build key.</param>
      <returns>The new build key.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.Guard">
      <summary>
            Represents a simple class for validating parameters and throwing exceptions.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Guard.ArgumentNotNull(System.Object,System.String)">
      <summary>
            Validates <paramref name="argumentValue" /> is not null and throws <see cref="T:System.ArgumentNullException" /> if it is null.
            </summary>
      <param name="argumentValue">The value to validate.</param>
      <param name="argumentName">The name of <paramref name="argumentValue" />.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Guard.ArgumentNotNullOrEmpty(System.String,System.String)">
      <summary>
            Validates <paramref name="argumentValue" /> is not null or an empty string and throws <see cref="T:System.ArgumentNullException" /> if it is null or an empty string .
            </summary>
      <param name="argumentValue">The value to validate.</param>
      <param name="argumentName">The name of <paramref name="argumentValue" />.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.WeakRefDictionary`2">
      <summary>
            Represents a dictionary which stores the values as weak references instead of strong
            references. Null values are supported.
            </summary>
      <typeparam name="TKey">The key type</typeparam>
      <typeparam name="TValue">The value type</typeparam>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.WeakRefDictionary`2.Add(`0,`1)">
      <summary>
            Gets the count of the number of items in the dictionary.
            </summary>
      <value>
            The count of the number of items in the dictionary.
            </value>
      <remarks>
            Since the items in the dictionary are held by weak reference, the count value
            cannot be relied upon to guarantee the number of objects that would be discovered via
            enumeration. Treat the Count as an estimate only.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.WeakRefDictionary`2.ContainsKey(`0)">
      <summary>
            Determines if the dictionary contains a value for the key.
            </summary>
      <param name="key">The key to look for.</param>
      <returns>true if the key is contained in the dictionary; otherwise, false.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.WeakRefDictionary`2.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the dictionary.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the dictionary. 
            </returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.WeakRefDictionary`2.Remove(`0)">
      <summary>
            Removes an item from the dictionary.
            </summary>
      <param name="key">The key of the item to be removed.</param>
      <returns>Returns true if the key was in the dictionary; return false otherwise.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.WeakRefDictionary`2.TryGet(`0,`1@)">
      <summary>
            Attempts to get a value from the dictionary.
            </summary>
      <param name="key">The key</param>
      <param name="value">The value</param>
      <returns>Returns true if the value was present; false otherwise.</returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.WeakRefDictionary`2.Count">
      <summary>
            Returns a count of the number of items in the dictionary.
            </summary>
      <remarks>
            Since the items in the dictionary are held by weak reference, the count value
            cannot be relied upon to guarantee the number of objects that would be discovered via
            enumeration. Treat the Count as an estimate only.
            </remarks>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.WeakRefDictionary`2.Item(`0)">
      <summary>
            Retrieves a value from the dictionary.
            </summary>
      <param name="key">The key to look for.</param>
      <returns>The value in the dictionary.</returns>
      <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when the key does exist in the dictionary.
            Since the dictionary contains weak references, the key may have been removed by the
            garbage collection of the object.</exception>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.IllegalInjectionMethodException">
      <summary>
            The exception thrown when injection is attempted on a method
            that is an open generic or has out or ref params.
            </summary>
      <summary>
            The exception thrown when injection is attempted on a method
            that is an open generic or has out or ref params.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IllegalInjectionMethodException.#ctor">
      <summary>
            Construct a new <see cref="T:Microsoft.Practices.ObjectBuilder2.IllegalInjectionMethodException" /> with no
            message.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IllegalInjectionMethodException.#ctor(System.String)">
      <summary>
            Construct a <see cref="T:Microsoft.Practices.ObjectBuilder2.IllegalInjectionMethodException" /> with the given message
            </summary>
      <param name="message">Message to return.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IllegalInjectionMethodException.#ctor(System.String,System.Exception)">
      <summary>
            Construct a <see cref="T:Microsoft.Practices.ObjectBuilder2.IllegalInjectionMethodException" /> with the given message
            and inner exception.
            </summary>
      <param name="message">Message to return.</param>
      <param name="innerException">Inner exception</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.IllegalInjectionMethodException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Used for serialization.
            </summary>
      <param name="info">Serialization info.</param>
      <param name="context">Serialization context.</param>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey">
      <summary>
            Build key used to combine a type object with a string name. Used by
            ObjectBuilder to indicate exactly what is being built.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey.#ctor(System.Type,System.String)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey" /> instance with the given
            type and name.
            </summary>
      <param name="type">
        <see cref="P:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey.Type" /> to build.</param>
      <param name="name">Key to use to look up type mappings and singletons.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey.#ctor(System.Type)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey" /> instance for the default
            buildup of the given type.
            </summary>
      <param name="type">
        <see cref="P:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey.Type" /> to build.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey.Make``1">
      <summary>
            This helper method creates a new <see cref="T:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey" /> instance. It is
            initialized for the default key for the given type.
            </summary>
      <typeparam name="T">Type to build.</typeparam>
      <returns>A new <see cref="T:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey" /> instance.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey.Make``1(System.String)">
      <summary>
            This helper method creates a new <see cref="T:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey" /> instance for
            the given type and key.
            </summary>
      <typeparam name="T">Type to build</typeparam>
      <param name="name">Key to use to look up type mappings and singletons.</param>
      <returns>A new <see cref="T:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey" /> instance initialized with the given type and name.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey.ReplaceType(System.Type)">
      <summary>
            Construct a new build key object with the current type
            replaced with the specified <paramref name="newType" />.
            </summary>
      <remarks>This method creates a new build key object, the original is unchanged.</remarks>
      <param name="newType">New type to place in the build key.</param>
      <returns>The new build key.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey.Equals(System.Object)">
      <summary>
            Compare two <see cref="T:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey" /> instances.
            </summary>
      <remarks>Two <see cref="T:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey" /> instances compare equal
            if they contain the same name and the same type. Also, comparing
            against a different type will also return false.</remarks>
      <param name="obj">Object to compare to.</param>
      <returns>True if the two keys are equal, false if not.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey.GetHashCode">
      <summary>
            Calculate a hash code for this instance.
            </summary>
      <returns>A hash code.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey.op_Equality(Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey,Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey)">
      <summary>
            Compare two <see cref="T:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey" /> instances for equality.
            </summary>
      <remarks>Two <see cref="T:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey" /> instances compare equal
            if they contain the same name and the same type.</remarks>
      <param name="left">First of the two keys to compare.</param>
      <param name="right">Second of the two keys to compare.</param>
      <returns>True if the values of the keys are the same, else false.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey.op_Inequality(Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey,Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey)">
      <summary>
            Compare two <see cref="T:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey" /> instances for inequality.
            </summary>
      <remarks>Two <see cref="T:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey" /> instances compare equal
            if they contain the same name and the same type. If either field differs
            the keys are not equal.</remarks>
      <param name="left">First of the two keys to compare.</param>
      <param name="right">Second of the two keys to compare.</param>
      <returns>false if the values of the keys are the same, else true.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey.ToString">
      <summary>
            Formats the build key as a string (primarily for debugging).
            </summary>
      <returns>A readable string representation of the build key.</returns>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey.Type">
      <summary>
            Return the <see cref="P:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey.Type" /> stored in this build key.
            </summary>
      <value>The type to build.</value>
    </member>
    <member name="P:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey.Name">
      <summary>
            Returns the name stored in this build key.
            </summary>
      <remarks>The name to use when building.</remarks>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.Sequence">
      <summary>
            A series of helper methods to deal with sequences -
            objects that implement <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            </summary>
      <remarks>LINQ in C# 3.0 does pretty much the same stuff,
            but we're keeping C# 2.0 compatibility here.</remarks>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.Sequence.Reducer`2">
      <summary>
            A delegate that defines the function passed to the <see cref="M:Microsoft.Practices.ObjectBuilder2.Sequence.Reduce``2(System.Collections.Generic.IEnumerable{``0},``1,Microsoft.Practices.ObjectBuilder2.Sequence.Reducer{``0,``1})" /> methods.
            </summary>
      <typeparam name="TSource">Type of item being reduced.</typeparam>
      <typeparam name="TDest">Type of the accumulator object.</typeparam>
      <param name="currentItem">Current item to process.</param>
      <param name="accumulator">Current value of the accumulator.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Sequence.ToList``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Given an <see cref="T:System.Collections.Generic.IEnumerable`1" />, return a
            new <see cref="T:System.Collections.Generic.List`1" /> containing the same contents.
            </summary>
      <typeparam name="T">Type of item store in the sequence.</typeparam>
      <param name="seq">Sequence to create list from.</param>
      <returns>The new <see cref="T:System.Collections.Generic.List`1" /></returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Sequence.OfType``1(System.Collections.IEnumerable)">
      <summary>
            Given an <see cref="T:System.Collections.IEnumerable" /> return a new
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains
            all the objects in <paramref name="source" /> that
            are castable to <typeparamref name="TResult" />.
            </summary>
      <typeparam name="TResult">Desired type for objects.</typeparam>
      <param name="source">Input sequence.</param>
      <returns>New output sequence.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Sequence.Collect``1(``0[])">
      <summary>
            A function that turns an arbitrary parameter list into an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            </summary>
      <typeparam name="T">Type of arguments.</typeparam>
      <param name="arguments">The items to put into the collection.</param>
      <returns>An array that contains the values of the <paramref name="arguments" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Sequence.ToArray``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Create an array containing the elements of the given sequence.
            </summary>
      <typeparam name="T">Type of sequence and array.</typeparam>
      <param name="sequence">Input sequence.</param>
      <returns>The resulting array.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Sequence.Where``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
      <summary>
            Given a sequence of <typeparamref name="T" />, returns a sequence
            containing those elements that satisfy the given predicate <paramref name="pred" />.
            </summary>
      <typeparam name="T">Type of items in the sequence.</typeparam>
      <param name="sequence">Source sequence.</param>
      <param name="pred">Predicate used to test which items match.</param>
      <returns>The sequence of items that satify <paramref name="pred" />. This
            sequence may be empty.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Sequence.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
      <summary>
            Tests the given <paramref name="sequence" />, returning true if any
            element in <paramref name="sequence" /> satisfies the given predicate.
            </summary>
      <typeparam name="T">Type of elements in sequence.</typeparam>
      <param name="sequence">Sequence to test.</param>
      <param name="pred">Predicate to use to test for existence.</param>
      <returns>true if any elements satify pred, false if not.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Sequence.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
      <summary>
            Tests the given <paramref name="sequence" />, returning true only if all
            elements in <paramref name="sequence" /> satisfies the given predicate.
            </summary>
      <typeparam name="T">Type of elements in sequence.</typeparam>
      <param name="sequence">Sequence to test.</param>
      <param name="pred">Predicate to use to test.</param>
      <returns>true if all elements satify pred, false if not.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Sequence.Map``2(System.Collections.Generic.IEnumerable{``0},System.Converter{``0,``1})">
      <summary>
            Given a sequence of <typeparamref name="TIn" />, returns a sequence of
            <typeparamref name="TOut" /> created by running the items in <paramref name="input" />
            through <paramref name="converter" />.
            </summary>
      <typeparam name="TIn">Type of items in input.</typeparam>
      <typeparam name="TOut">Type of items in output.</typeparam>
      <param name="input">Input sequence.</param>
      <param name="converter">Mapping function.</param>
      <returns>The converted output sequence.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Sequence.Reduce``2(System.Collections.Generic.IEnumerable{``0},``1,Microsoft.Practices.ObjectBuilder2.Sequence.Reducer{``0,``1})">
      <summary>
            Run a functional Reduce operation. See other methods for examples.
            </summary>
      <typeparam name="TSource">Type of inputs.</typeparam>
      <typeparam name="TDest">Type of final output.</typeparam>
      <param name="sequence">Sequence of input items.</param>
      <param name="initialValue">Initial value for accumulator.</param>
      <param name="reducer">Reduce function.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Sequence.ToString``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Converter{``0,System.String})">
      <summary>
            Convert the given sequence to a single string. The items in the string are
            separated by the given separator, and each object is converted to a string
            using the <paramref name="converter" /> method given.
            </summary>
      <typeparam name="T">Type of input sequence.</typeparam>
      <param name="sequence">Input sequence.</param>
      <param name="separator">Separator string.</param>
      <param name="converter">Function to convert <typeparamref name="T" /> instances to
            strings.</param>
      <returns>The collected string.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Sequence.ToString``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            Convert the given sequence to a single string. The items in the string are separated
            by the given separator, and each object is converted to a string by calling its
            <see cref="M:System.Object.ToString" />  method.
            </summary>
      <typeparam name="T">Type of input sequence.</typeparam>
      <param name="sequence">Input sequence.</param>
      <param name="separator">Separator string.</param>
      <returns>The collected string.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Sequence.First``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Return the first item in the given sequence.
            </summary>
      <exception cref="T:System.InvalidOperationException">Thrown if the sequence is empty.</exception>
      <typeparam name="T">Type of items in the sequence.</typeparam>
      <param name="sequence">The sequence.</param>
      <returns>First item in the sequence.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Sequence.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <summary>
            Execute the given action delegate for each item in the sequence.
            </summary>
      <typeparam name="TItem">Type of item in the sequence.</typeparam>
      <param name="sequence">The sequence of items.</param>
      <param name="action">Action to perform on each item.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Sequence.Concat``1(System.Collections.Generic.IEnumerable{``0}[])">
      <summary>
            Concatenate multiple sequences into a single one.
            </summary>
      <typeparam name="TItem">Type of sequences in the sequence.</typeparam>
      <param name="sequences">The sequences to combine.</param>
      <returns>The combined sequence.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.Seq">
      <summary>
            Static class containing constructor methods for
            instances of <see cref="T:Microsoft.Practices.ObjectBuilder2.Seq`1" />, so that we
            get type inference.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Seq.Make``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Make a new instance of <see cref="T:Microsoft.Practices.ObjectBuilder2.Seq`1" /> that wraps
            the given items.
            </summary>
      <typeparam name="T">Type of items in the sequence.</typeparam>
      <param name="items">Items in the sequence.</param>
      <returns>The sequence.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Seq.Collect``1(``0[])">
      <summary>
            Make a new instance of <see cref="T:Microsoft.Practices.ObjectBuilder2.Seq`1" /> that wraps
            the given items.
            </summary>
      <typeparam name="T">Type of items in the sequence.</typeparam>
      <param name="items">Items in the sequence.</param>
      <returns>The sequence.</returns>
    </member>
    <member name="T:Microsoft.Practices.ObjectBuilder2.Seq`1">
      <summary>
            And another helper class that makes it possible to chain sequence operations together.
            </summary>
      <typeparam name="T">Type of item contained in the sequence.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Seq`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.ObjectBuilder2.Seq`1" /> instance wrapping the given IEnumerable.
            </summary>
      <param name="items">The sequence to wrap.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Seq`1.GetEnumerator">
      <summary>
                                Returns an enumerator that iterates through the collection.
            </summary>
      <returns>
                                A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Seq`1.ToList">
      <summary>
            Given a sequence object, return a list containing those items.
            </summary>
      <returns>The materialized list.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Seq`1.ToArray">
      <summary>
            Return an array with the same contents as this sequence.
            </summary>
      <returns>The materialized array.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Seq`1.Where(System.Predicate{`0})">
      <summary>
            Returns new sequence containing only the items for which the predicate is true.
            </summary>
      <param name="predicate">Test to indicate sequence inclusion</param>
      <returns>New sequence.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Seq`1.Exists(System.Predicate{`0})">
      <summary>
            Tests the sequence, returning true if any
            element satisfies the given predicate.
            </summary>
      <param name="predicate">Predicate to use to test for existence.</param>
      <returns>true if any elements satify pred, false if not.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Seq`1.ForAll(System.Predicate{`0})">
      <summary>
            Tests the sequence, returning true only if all
            elements satisfy the given predicate.
            </summary>
      <param name="predicate">Predicate to use to test.</param>
      <returns>true if all elements satify pred, false if not.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Seq`1.Map``1(System.Converter{`0,``0})">
      <summary>
            Return a new sequence consisting of the result of running each element through
            the given <paramref name="converter" />.
            </summary>
      <typeparam name="TOut">Desired output type.</typeparam>
      <param name="converter">Converter delegate.</param>
      <returns>New Sequence</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Seq`1.Reduce``1(``0,Microsoft.Practices.ObjectBuilder2.Sequence.Reducer{`0,``0})">
      <summary>
            Run a functional Reduce operation. See other methods for examples.
            </summary>
      <typeparam name="TDest">Type of final output.</typeparam>
      <param name="initialValue">Initial value for accumulator.</param>
      <param name="reducer">Reduce function.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Seq`1.ToString(System.String,System.Converter{`0,System.String})">
      <summary>
            Convert the given sequence to a single string. The items in the string are
            separated by the given separator, and each object is converted to a string
            using the <paramref name="converter" /> method given.
            </summary>
      <param name="separator">Separator string.</param>
      <param name="converter">Function to convert <typeparamref name="T" /> instances to
            strings.</param>
      <returns>The collected string.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Seq`1.ToString(System.String)">
      <summary>
            Convert the given sequence to a single string. The items in the string are separated
            by the given separator, and each object is converted to a string by calling its
            <see cref="M:System.Object.ToString" />  method.
            </summary>
      <param name="separator">Separator string.</param>
      <returns>The collected string.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Seq`1.First">
      <summary>
            Return the first item in the given sequence.
            </summary>
      <exception cref="T:System.InvalidOperationException">Thrown if the sequence is empty.</exception>
      <returns>First item in the sequence.</returns>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Seq`1.ForEach(System.Action{`0})">
      <summary>
            Execute the given action delegate for each item in the sequence.
            </summary>
      <param name="action">Action to perform on each item.</param>
    </member>
    <member name="M:Microsoft.Practices.ObjectBuilder2.Seq`1.Concat(System.Collections.Generic.IEnumerable{`0}[])">
      <summary>
            Concatenate multiple sequences with this one to return a single
            sequence containing all items.
            </summary>
      <param name="sequences">Sequences to combine.</param>
      <returns>The combined sequence.</returns>
    </member>
    <member name="T:Microsoft.Practices.ServiceLocation.ActivationException">
      <summary>
            The standard exception thrown when a ServiceLocator has an error in resolving an object.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ServiceLocation.ActivationException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:System.Exception" /> class.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ServiceLocation.ActivationException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Exception" /> class with a specified error message.
            </summary>
      <param name="message">
            The message that describes the error. 
             </param>
    </member>
    <member name="M:Microsoft.Practices.ServiceLocation.ActivationException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Exception" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
      <param name="message">
            The error message that explains the reason for the exception. 
            </param>
      <param name="innerException">
            The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified. 
            </param>
    </member>
    <member name="M:Microsoft.Practices.ServiceLocation.ActivationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:System.Exception" /> class with serialized data.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown. 
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination. 
            </param>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="info" /> parameter is null. 
            </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">
            The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). 
            </exception>
    </member>
    <member name="T:Microsoft.Practices.ServiceLocation.IServiceLocator">
      <summary>
            The generic Service Locator interface. This interface is used
            to retrieve services (instances identified by type and optional
            name) from a container.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ServiceLocation.IServiceLocator.GetInstance(System.Type)">
      <summary>
            Get an instance of the given <paramref name="serviceType" />.
            </summary>
      <param name="serviceType">Type of object requested.</param>
      <exception cref="T:Microsoft.Practices.ServiceLocation.ActivationException">if there is an error resolving
            the service instance.</exception>
      <returns>The requested service instance.</returns>
    </member>
    <member name="M:Microsoft.Practices.ServiceLocation.IServiceLocator.GetInstance(System.Type,System.String)">
      <summary>
            Get an instance of the given named <paramref name="serviceType" />.
            </summary>
      <param name="serviceType">Type of object requested.</param>
      <param name="key">Name the object was registered with.</param>
      <exception cref="T:Microsoft.Practices.ServiceLocation.ActivationException">if there is an error resolving
            the service instance.</exception>
      <returns>The requested service instance.</returns>
    </member>
    <member name="M:Microsoft.Practices.ServiceLocation.IServiceLocator.GetAllInstances(System.Type)">
      <summary>
            Get all instances of the given <paramref name="serviceType" /> currently
            registered in the container.
            </summary>
      <param name="serviceType">Type of object requested.</param>
      <exception cref="T:Microsoft.Practices.ServiceLocation.ActivationException">if there is are errors resolving
            the service instance.</exception>
      <returns>A sequence of instances of the requested <paramref name="serviceType" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.ServiceLocation.IServiceLocator.GetInstance``1">
      <summary>
            Get an instance of the given <typeparamref name="TService" />.
            </summary>
      <typeparam name="TService">Type of object requested.</typeparam>
      <exception cref="T:Microsoft.Practices.ServiceLocation.ActivationException">if there is are errors resolving
            the service instance.</exception>
      <returns>The requested service instance.</returns>
    </member>
    <member name="M:Microsoft.Practices.ServiceLocation.IServiceLocator.GetInstance``1(System.String)">
      <summary>
            Get an instance of the given named <typeparamref name="TService" />.
            </summary>
      <typeparam name="TService">Type of object requested.</typeparam>
      <param name="key">Name the object was registered with.</param>
      <exception cref="T:Microsoft.Practices.ServiceLocation.ActivationException">if there is are errors resolving
            the service instance.</exception>
      <returns>The requested service instance.</returns>
    </member>
    <member name="M:Microsoft.Practices.ServiceLocation.IServiceLocator.GetAllInstances``1">
      <summary>
            Get all instances of the given <typeparamref name="TService" /> currently
            registered in the container.
            </summary>
      <typeparam name="TService">Type of object requested.</typeparam>
      <exception cref="T:Microsoft.Practices.ServiceLocation.ActivationException">if there is are errors resolving
            the service instance.</exception>
      <returns>A sequence of instances of the requested <typeparamref name="TService" />.</returns>
    </member>
    <member name="T:Microsoft.Practices.ServiceLocation.Properties.Resources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ServiceLocation.Properties.Resources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ServiceLocation.Properties.Resources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ServiceLocation.Properties.Resources.ActivateAllExceptionMessage">
      <summary>
              Looks up a localized string similar to Activation error occured while trying to get all instances of type {0}.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.ServiceLocation.Properties.Resources.ActivationExceptionMessage">
      <summary>
              Looks up a localized string similar to Activation error occured while trying to get instance of type {0}, key "{1}".
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ServiceLocation.ServiceLocator">
      <summary>
            This class provides the ambient container for this application. If your
            framework defines such an ambient container, use ServiceLocator.Current
            to get it.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ServiceLocation.ServiceLocator.SetLocatorProvider(Microsoft.Practices.ServiceLocation.ServiceLocatorProvider)">
      <summary>
            Set the delegate that is used to retrieve the current container.
            </summary>
      <param name="newProvider">Delegate that, when called, will return
            the current ambient container.</param>
    </member>
    <member name="P:Microsoft.Practices.ServiceLocation.ServiceLocator.Current">
      <summary>
            The current ambient container.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.ServiceLocation.ServiceLocatorImplBase">
      <summary>
            This class is a helper that provides a default implementation
            for most of the methods of <see cref="T:Microsoft.Practices.ServiceLocation.IServiceLocator" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.ServiceLocation.ServiceLocatorImplBase.GetService(System.Type)">
      <summary>
            Implementation of <see cref="M:System.IServiceProvider.GetService(System.Type)" />.
            </summary>
      <param name="serviceType">The requested service.</param>
      <exception cref="T:Microsoft.Practices.ServiceLocation.ActivationException">if there is an error in resolving the service instance.</exception>
      <returns>The requested object.</returns>
    </member>
    <member name="M:Microsoft.Practices.ServiceLocation.ServiceLocatorImplBase.GetInstance(System.Type)">
      <summary>
            Get an instance of the given <paramref name="serviceType" />.
            </summary>
      <param name="serviceType">Type of object requested.</param>
      <exception cref="T:Microsoft.Practices.ServiceLocation.ActivationException">if there is an error resolving
            the service instance.</exception>
      <returns>The requested service instance.</returns>
    </member>
    <member name="M:Microsoft.Practices.ServiceLocation.ServiceLocatorImplBase.GetInstance(System.Type,System.String)">
      <summary>
            Get an instance of the given named <paramref name="serviceType" />.
            </summary>
      <param name="serviceType">Type of object requested.</param>
      <param name="key">Name the object was registered with.</param>
      <exception cref="T:Microsoft.Practices.ServiceLocation.ActivationException">if there is an error resolving
            the service instance.</exception>
      <returns>The requested service instance.</returns>
    </member>
    <member name="M:Microsoft.Practices.ServiceLocation.ServiceLocatorImplBase.GetAllInstances(System.Type)">
      <summary>
            Get all instances of the given <paramref name="serviceType" /> currently
            registered in the container.
            </summary>
      <param name="serviceType">Type of object requested.</param>
      <exception cref="T:Microsoft.Practices.ServiceLocation.ActivationException">if there is are errors resolving
            the service instance.</exception>
      <returns>A sequence of instances of the requested <paramref name="serviceType" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.ServiceLocation.ServiceLocatorImplBase.GetInstance``1">
      <summary>
            Get an instance of the given <typeparamref name="TService" />.
            </summary>
      <typeparam name="TService">Type of object requested.</typeparam>
      <exception cref="T:Microsoft.Practices.ServiceLocation.ActivationException">if there is are errors resolving
            the service instance.</exception>
      <returns>The requested service instance.</returns>
    </member>
    <member name="M:Microsoft.Practices.ServiceLocation.ServiceLocatorImplBase.GetInstance``1(System.String)">
      <summary>
            Get an instance of the given named <typeparamref name="TService" />.
            </summary>
      <typeparam name="TService">Type of object requested.</typeparam>
      <param name="key">Name the object was registered with.</param>
      <exception cref="T:Microsoft.Practices.ServiceLocation.ActivationException">if there is are errors resolving
            the service instance.</exception>
      <returns>The requested service instance.</returns>
    </member>
    <member name="M:Microsoft.Practices.ServiceLocation.ServiceLocatorImplBase.GetAllInstances``1">
      <summary>
            Get all instances of the given <typeparamref name="TService" /> currently
            registered in the container.
            </summary>
      <typeparam name="TService">Type of object requested.</typeparam>
      <exception cref="T:Microsoft.Practices.ServiceLocation.ActivationException">if there is are errors resolving
            the service instance.</exception>
      <returns>A sequence of instances of the requested <typeparamref name="TService" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.ServiceLocation.ServiceLocatorImplBase.DoGetInstance(System.Type,System.String)">
      <summary>
            When implemented by inheriting classes, this method will do the actual work of resolving
            the requested service instance.
            </summary>
      <param name="serviceType">Type of instance requested.</param>
      <param name="key">Name of registered service you want. May be null.</param>
      <returns>The requested service instance.</returns>
    </member>
    <member name="M:Microsoft.Practices.ServiceLocation.ServiceLocatorImplBase.DoGetAllInstances(System.Type)">
      <summary>
            When implemented by inheriting classes, this method will do the actual work of
            resolving all the requested service instances.
            </summary>
      <param name="serviceType">Type of service requested.</param>
      <returns>Sequence of service instance objects.</returns>
    </member>
    <member name="M:Microsoft.Practices.ServiceLocation.ServiceLocatorImplBase.FormatActivationExceptionMessage(System.Exception,System.Type,System.String)">
      <summary>
            Format the exception message for use in an <see cref="T:Microsoft.Practices.ServiceLocation.ActivationException" />
            that occurs while resolving a single service.
            </summary>
      <param name="actualException">The actual exception thrown by the implementation.</param>
      <param name="serviceType">Type of service requested.</param>
      <param name="key">Name requested.</param>
      <returns>The formatted exception message string.</returns>
    </member>
    <member name="M:Microsoft.Practices.ServiceLocation.ServiceLocatorImplBase.FormatActivateAllExceptionMessage(System.Exception,System.Type)">
      <summary>
            Format the exception message for use in an <see cref="T:Microsoft.Practices.ServiceLocation.ActivationException" />
            that occurs while resolving multiple service instances.
            </summary>
      <param name="actualException">The actual exception thrown by the implementation.</param>
      <param name="serviceType">Type of service requested.</param>
      <returns>The formatted exception message string.</returns>
    </member>
    <member name="T:Microsoft.Practices.ServiceLocation.ServiceLocatorProvider">
      <summary>
            This delegate type is used to provide a method that will
            return the current container. Used with the <see cref="T:Microsoft.Practices.ServiceLocation.ServiceLocator" />
            static accessor class.
            </summary>
      <returns>An <see cref="T:Microsoft.Practices.ServiceLocation.IServiceLocator" />.</returns>
    </member>
    <member name="T:Microsoft.Practices.Unity.DependencyResolutionAttribute">
      <summary>
            Base class for attributes that can be placed on parameters
            or properties to specify how to resolve the value for
            that parameter or property.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.DependencyResolutionAttribute.CreateResolver(System.Type)">
      <summary>
            Create an instance of <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" /> that
            will be used to get the value for the member this attribute is
            applied to.
            </summary>
      <param name="typeToResolve">Type of parameter or property that
            this attribute is decoration.</param>
      <returns>The resolver object.</returns>
    </member>
    <member name="T:Microsoft.Practices.Unity.InjectionConstructorAttribute">
      <summary>
            This attribute is used to indicate which constructor to choose when
            the container attempts to build a type.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.InjectionMethodAttribute">
      <summary>
            This attribute is used to mark methods that should be called when
            the container is building an object.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.DependencyAttribute">
      <summary>
            This attribute is used to mark properties and parameters as targets for injection.
            </summary>
      <remarks>
            For properties, this attribute is necessary for injection to happen. For parameters,
            it's not needed unless you want to specify additional information to control how
            the parameter is resolved.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.Unity.DependencyAttribute.#ctor">
      <summary>
            Create an instance of <see cref="T:Microsoft.Practices.Unity.DependencyAttribute" /> with no name.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.DependencyAttribute.#ctor(System.String)">
      <summary>
            Create an instance of <see cref="T:Microsoft.Practices.Unity.DependencyAttribute" /> with the given name.
            </summary>
      <param name="name">Name to use when resolving this dependency.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.DependencyAttribute.CreateResolver(System.Type)">
      <summary>
            Create an instance of <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" /> that
            will be used to get the value for the member this attribute is
            applied to.
            </summary>
      <param name="typeToResolve">Type of parameter or property that
            this attribute is decoration.</param>
      <returns>The resolver object.</returns>
    </member>
    <member name="P:Microsoft.Practices.Unity.DependencyAttribute.Name">
      <summary>
            The name specified in the constructor.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.IUnityContainerExtensionConfigurator">
      <summary>
            Base interface for all extension configuration interfaces.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.IUnityContainerExtensionConfigurator.Container">
      <summary>
            Retrieve the container instance that we are currently configuring.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.UnityContainerExtension">
      <summary>
            Base class for all <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> extension objects.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerExtension.InitializeExtension(Microsoft.Practices.Unity.ExtensionContext)">
      <summary>
            The container calls this method when the extension is added.
            </summary>
      <param name="context">A <see cref="T:Microsoft.Practices.Unity.ExtensionContext" /> instance that gives the
            extension access to the internals of the container.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerExtension.Initialize">
      <summary>
            Initial the container with this extension's functionality.
            </summary>
      <remarks>
            When overridden in a derived class, this method will modify the given
            <see cref="T:Microsoft.Practices.Unity.ExtensionContext" /> by adding strategies, policies, etc. to
            install it's functions into the container.</remarks>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerExtension.Remove">
      <summary>
            Removes the extension's functions from the container.
            </summary>
      <remarks>
        <para>
            This method is called when extensions are being removed from the container. It can be
            used to do things like disconnect event handlers or clean up member state. You do not
            need to remove strategies or policies here; the container will do that automatically.
            </para>
        <para>
            The default implementation of this method does nothing.</para>
      </remarks>
    </member>
    <member name="P:Microsoft.Practices.Unity.UnityContainerExtension.Container">
      <summary>
            The container this extension has been added to.
            </summary>
      <value>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> that this extension has been added to.</value>
    </member>
    <member name="P:Microsoft.Practices.Unity.UnityContainerExtension.Context">
      <summary>
            The <see cref="T:Microsoft.Practices.Unity.ExtensionContext" /> object used to manipulate
            the inner state of the container.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.UnityDefaultStrategiesExtension">
      <summary>
            This extension installs the default strategies and policies into the container
            to implement the standard behavior of the Unity container.
            </summary>
      <summary>
            This extension installs the default strategies and policies into the container
            to implement the standard behavior of the Unity container.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityDefaultStrategiesExtension.SetDynamicBuilderMethodCreatorPolicy">
      <summary>
            Add the correct <see cref="T:Microsoft.Practices.ObjectBuilder2.IDynamicBuilderMethodCreatorPolicy" /> to the policy
            set. This version adds the appropriate policy for running on the desktop CLR.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityDefaultStrategiesExtension.Initialize">
      <summary>
            Add the default ObjectBuilder strategies &amp; policies to the container.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.ExtensionContext">
      <summary>
            The <see cref="T:Microsoft.Practices.Unity.ExtensionContext" /> class provides the means for extension objects
            to manipulate the internal state of the <see cref="T:Microsoft.Practices.Unity.UnityContainer" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.ExtensionContext.RegisterNamedType(System.Type,System.String)">
      <summary>
            Store a type/name pair for later resolution.
            </summary>
      <remarks>
        <para>
            When users register type mappings (or other things) with a named key, this method
            allows you to register that name with the container so that when the <see cref="M:Microsoft.Practices.Unity.IUnityContainer.ResolveAll``1" />
            method is called, that name is included in the list that is returned.
            </para>
      </remarks>
      <param name="t">
        <see cref="T:System.Type" /> to register.</param>
      <param name="name">Name assocated with that type.</param>
    </member>
    <member name="P:Microsoft.Practices.Unity.ExtensionContext.Container">
      <summary>
            The container that this context is associated with.
            </summary>
      <value>The <see cref="T:Microsoft.Practices.Unity.IUnityContainer" /> object.</value>
    </member>
    <member name="P:Microsoft.Practices.Unity.ExtensionContext.Strategies">
      <summary>
            The strategies this container uses.
            </summary>
      <value>The <see cref="T:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1" /> that the container uses to build objects.</value>
    </member>
    <member name="P:Microsoft.Practices.Unity.ExtensionContext.BuildPlanStrategies">
      <summary>
            The strategies this container uses to construct build plans.
            </summary>
      <value>The <see cref="T:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1" /> that this container uses when creating
            build plans.</value>
    </member>
    <member name="P:Microsoft.Practices.Unity.ExtensionContext.Policies">
      <summary>
            The policies this container uses.
            </summary>
      <remarks>The <see cref="T:Microsoft.Practices.ObjectBuilder2.IPolicyList" /> the that container uses to build objects.</remarks>
    </member>
    <member name="P:Microsoft.Practices.Unity.ExtensionContext.Locator">
      <summary>
            The <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadWriteLocator" /> that this container uses.
            </summary>
      <value>The Locator is an object that is used to store information to be found later during the build process.</value>
    </member>
    <member name="P:Microsoft.Practices.Unity.ExtensionContext.Lifetime">
      <summary>
            The <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> that this container uses.
            </summary>
      <value>The <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer" /> is used to manage <see cref="T:System.IDisposable" /> objects that the container is managing.</value>
    </member>
    <member name="E:Microsoft.Practices.Unity.ExtensionContext.Registering">
      <summary>
            This event is raised when the <see cref="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType(System.Type,System.Type,System.String,Microsoft.Practices.Unity.LifetimeManager,Microsoft.Practices.Unity.InjectionMember[])" /> method,
            or one of its overloads, is called.
            </summary>
    </member>
    <member name="E:Microsoft.Practices.Unity.ExtensionContext.RegisteringInstance">
      <summary>
            This event is raised when the <see cref="M:Microsoft.Practices.Unity.IUnityContainer.RegisterInstance(System.Type,System.String,System.Object,Microsoft.Practices.Unity.LifetimeManager)" /> method,
            or one of its overloads, is called.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.NamedEventArgs">
      <summary>
            An EventArgs class that holds a string Name.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.NamedEventArgs.#ctor">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.NamedEventArgs" /> with a null name.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.NamedEventArgs.#ctor(System.String)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.NamedEventArgs" /> with the given name.
            </summary>
      <param name="name">Name to store.</param>
    </member>
    <member name="P:Microsoft.Practices.Unity.NamedEventArgs.Name">
      <summary>
            The name.
            </summary>
      <value>Name used for this event arg object.</value>
    </member>
    <member name="T:Microsoft.Practices.Unity.RegisterEventArgs">
      <summary>
            Event argument class for the <see cref="E:Microsoft.Practices.Unity.ExtensionContext.Registering" /> event.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.RegisterEventArgs.#ctor(System.Type,System.Type,System.String,Microsoft.Practices.Unity.LifetimeManager)">
      <summary>
            Create a new instance of <see cref="T:Microsoft.Practices.Unity.RegisterEventArgs" />.
            </summary>
      <param name="typeFrom">Type to map from.</param>
      <param name="typeTo">Type to map to.</param>
      <param name="name">Name for the registration.</param>
      <param name="lifetimeManager">
        <see cref="P:Microsoft.Practices.Unity.RegisterEventArgs.LifetimeManager" /> to manage instances.</param>
    </member>
    <member name="P:Microsoft.Practices.Unity.RegisterEventArgs.TypeFrom">
      <summary>
            Type to map from.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.RegisterEventArgs.TypeTo">
      <summary>
            Type to map to.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.RegisterEventArgs.LifetimeManager">
      <summary>
        <see cref="P:Microsoft.Practices.Unity.RegisterEventArgs.LifetimeManager" /> to manage instances.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.RegisterInstanceEventArgs">
      <summary>
            Event argument class for the <see cref="E:Microsoft.Practices.Unity.ExtensionContext.RegisteringInstance" /> event.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.RegisterInstanceEventArgs.#ctor">
      <summary>
            Create a default <see cref="T:Microsoft.Practices.Unity.RegisterInstanceEventArgs" /> instance.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.RegisterInstanceEventArgs.#ctor(System.Type,System.Object,System.String,Microsoft.Practices.Unity.LifetimeManager)">
      <summary>
            Create a <see cref="T:Microsoft.Practices.Unity.RegisterInstanceEventArgs" /> instance initialized with the given arguments.
            </summary>
      <param name="registeredType">Type of instance being registered.</param>
      <param name="instance">The instance object itself.</param>
      <param name="name">Name to register under, null if default registration.</param>
      <param name="lifetimeManager">
        <see cref="P:Microsoft.Practices.Unity.RegisterInstanceEventArgs.LifetimeManager" /> object that handles how
            the instance will be owned.</param>
    </member>
    <member name="P:Microsoft.Practices.Unity.RegisterInstanceEventArgs.RegisteredType">
      <summary>
            Type of instance being registered.
            </summary>
      <value>
            Type of instance being registered.
            </value>
    </member>
    <member name="P:Microsoft.Practices.Unity.RegisterInstanceEventArgs.Instance">
      <summary>
            Instance object being registered.
            </summary>
      <value>Instance object being registered</value>
    </member>
    <member name="P:Microsoft.Practices.Unity.RegisterInstanceEventArgs.LifetimeManager">
      <summary>
        <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> that controls ownership of
            this instance.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.InjectionParameterValue">
      <summary>
            Base type for objects that are used to configure parameters for
            constructor or method injection, or for getting the value to
            be injected into a property.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.InjectionParameterValue.MatchesType(System.Type)">
      <summary>
            Test to see if this parameter value has a matching type for the given type.
            </summary>
      <param name="t">Type to check.</param>
      <returns>True if this parameter value is compatible with type <paramref name="t" />,
            false if not.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.InjectionParameterValue.GetResolverPolicy(System.Type)">
      <summary>
            Return a <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" /> instance that will
            return this types value for the parameter.
            </summary>
      <param name="typeToBuild">Type that contains the member that needs this parameter. Used
            to resolve open generic parameters.</param>
      <returns>The <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.InjectionParameterValue.ToParameters(System.Object[])">
      <summary>
            Convert the given set of arbitrary values to a sequence of InjectionParameterValue
            objects. The rules are: If it's already an InjectionParameterValue, return it. If
            it's a Type, return a ResolvedParameter object for that type. Otherwise return
            an InjectionParameter object for that value.
            </summary>
      <param name="values">The values to build the sequence from.</param>
      <returns>The resulting converted sequence.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.InjectionParameterValue.ToParameter(System.Object)">
      <summary>
            Convert an arbitrary value to an InjectionParameterValue object. The rules are: 
            If it's already an InjectionParameterValue, return it. If it's a Type, return a
            ResolvedParameter object for that type. Otherwise return an InjectionParameter
            object for that value.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>The resulting <see cref="T:Microsoft.Practices.Unity.InjectionParameterValue" />.</returns>
    </member>
    <member name="P:Microsoft.Practices.Unity.InjectionParameterValue.ParameterTypeName">
      <summary>
            Name for the type represented by this <see cref="T:Microsoft.Practices.Unity.InjectionParameterValue" />.
            This may be an actual type name or a generic argument name.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.GenericParameter">
      <summary>
            A <see cref="T:Microsoft.Practices.Unity.InjectionParameterValue" /> that lets you specify that
            an instance of a generic type parameter should be resolved.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.GenericParameter.#ctor(System.String)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.GenericParameter" /> instance that specifies
            that the given named generic parameter should be resolved.
            </summary>
      <param name="genericParameterName">The generic parameter name to resolve.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.GenericParameter.#ctor(System.String,System.String)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.GenericParameter" /> instance that specifies
            that the given named generic parameter should be resolved.
            </summary>
      <param name="genericParameterName">The generic parameter name to resolve.</param>
      <param name="resolutionKey">name to use when looking up in the container.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.GenericParameter.MatchesType(System.Type)">
      <summary>
            Test to see if this parameter value has a matching type for the given type.
            </summary>
      <param name="t">Type to check.</param>
      <returns>True if this parameter value is compatible with type <paramref name="t" />,
            false if not.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.GenericParameter.GetResolverPolicy(System.Type)">
      <summary>
            Return a <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" /> instance that will
            return this types value for the parameter.
            </summary>
      <param name="typeToBuild">Type that contains the member that needs this parameter. Used
            to resolve open generic parameters.</param>
      <returns>The <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" />.</returns>
    </member>
    <member name="P:Microsoft.Practices.Unity.GenericParameter.ParameterTypeName">
      <summary>
            Name for the type represented by this <see cref="T:Microsoft.Practices.Unity.InjectionParameterValue" />.
            This may be an actual type name or a generic argument name.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.GenericResolvedArrayParameter">
      <summary>
            A <see cref="T:Microsoft.Practices.Unity.InjectionParameterValue" /> that lets you specify that
            an array containing the registered instances of a generic type parameter 
            should be resolved.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.GenericResolvedArrayParameter.#ctor(System.String,System.Object[])">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.GenericResolvedArrayParameter" /> instance that specifies
            that the given named generic parameter should be resolved.
            </summary>
      <param name="genericParameterName">The generic parameter name to resolve.</param>
      <param name="elementValues">The values for the elements, that will
            be converted to <see cref="T:Microsoft.Practices.Unity.InjectionParameterValue" /> objects.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.GenericResolvedArrayParameter.MatchesType(System.Type)">
      <summary>
            Test to see if this parameter value has a matching type for the given type.
            </summary>
      <param name="t">Type to check.</param>
      <returns>True if this parameter value is compatible with type <paramref name="t" />,
            false if not.</returns>
      <remarks>A type is considered compatible if it is an array type of rank one
            and its element type is a generic type parameter with a name matching this generic
            parameter name configured for the receiver.</remarks>
    </member>
    <member name="M:Microsoft.Practices.Unity.GenericResolvedArrayParameter.GetResolverPolicy(System.Type)">
      <summary>
            Return a <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" /> instance that will
            return this types value for the parameter.
            </summary>
      <param name="typeToBuild">Type that contains the member that needs this parameter. Used
            to resolve open generic parameters.</param>
      <returns>The <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" />.</returns>
    </member>
    <member name="P:Microsoft.Practices.Unity.GenericResolvedArrayParameter.ParameterTypeName">
      <summary>
            Name for the type represented by this <see cref="T:Microsoft.Practices.Unity.InjectionParameterValue" />.
            This may be an actual type name or a generic argument name.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.InjectedMembers">
      <summary>
            A Unity container extension that allows you to configure
            which constructors, properties, and methods get injected
            via an API rather than through attributes.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.InjectedMembers.Initialize">
      <summary>
            Initial the container with this extension's functionality.
            </summary>
      <remarks>
            When overridden in a derived class, this method will modify the given
            <see cref="T:Microsoft.Practices.Unity.ExtensionContext" /> by adding strategies, policies, etc. to
            install it's functions into the container.</remarks>
    </member>
    <member name="M:Microsoft.Practices.Unity.InjectedMembers.ConfigureInjectionFor``1(Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            API to configure the injection settings for a particular type.
            </summary>
      <typeparam name="TTypeToInject">Type the injection is being configured for.</typeparam>
      <param name="injectionMembers">Objects containing the details on which members to inject and how.</param>
      <returns>This extension object.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.InjectedMembers.ConfigureInjectionFor``1(System.String,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            API to configure the injection settings for a particular type/name pair.
            </summary>
      <typeparam name="TTypeToInject">Type the injection is being configured for.</typeparam>
      <param name="name">Name of registration</param>
      <param name="injectionMembers">Objects containing the details on which members to inject and how.</param>
      <returns>This extension object.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.InjectedMembers.ConfigureInjectionFor(System.Type,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            API to configure the injection settings for a particular type.
            </summary>
      <param name="typeToInject">Type to configure.</param>
      <param name="injectionMembers">Objects containing the details on which members to inject and how.</param>
      <returns>This extension object.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.InjectedMembers.ConfigureInjectionFor(System.Type,System.String,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            API to configure the injection settings for a particular type/name pair.
            </summary>
      <param name="typeToInject">Type to configure.</param>
      <param name="name">Name of registration.</param>
      <param name="injectionMembers">Objects containing the details on which members to inject and how.</param>
      <returns>This extension object.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.InjectedMembers.ClearExistingBuildPlan(System.Type,System.String)">
      <summary>
            Remove policies associated with building this type. This removes the
            compiled build plan so that it can be rebuilt with the new settings
            the next time this type is resolved.
            </summary>
      <param name="typeToInject">Type of object to clear the plan for.</param>
      <param name="name">Name the object is being registered with.</param>
    </member>
    <member name="T:Microsoft.Practices.Unity.InjectionMember">
      <summary>
            Base class for objects that can be used to configure what
            class members get injected by the container.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.InjectionMember.AddPolicies(System.Type,Microsoft.Practices.ObjectBuilder2.IPolicyList)">
      <summary>
            Add policies to the <paramref name="policies" /> to configure the
            container to call this constructor with the appropriate parameter values.
            </summary>
      <param name="typeToCreate">Type to register.</param>
      <param name="policies">Policy list to add policies to.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.InjectionMember.AddPolicies(System.Type,System.String,Microsoft.Practices.ObjectBuilder2.IPolicyList)">
      <summary>
            Add policies to the <paramref name="policies" /> to configure the
            container to call this constructor with the appropriate parameter values.
            </summary>
      <param name="typeToCreate">Type to register.</param>
      <param name="name">Name used to resolve the type object.</param>
      <param name="policies">Policy list to add policies to.</param>
    </member>
    <member name="T:Microsoft.Practices.Unity.InjectionConstructor">
      <summary>
            A class that holds the collection of information
            for a constructor, so that the container can
            be configured to call this constructor.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.InjectionConstructor.#ctor(System.Object[])">
      <summary>
            Create a new instance of <see cref="T:Microsoft.Practices.Unity.InjectionConstructor" /> that looks
            for a constructor with the given set of parameters.
            </summary>
      <param name="parameterValues">The values for the parameters, that will
            be converted to <see cref="T:Microsoft.Practices.Unity.InjectionParameterValue" /> objects.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.InjectionConstructor.AddPolicies(System.Type,System.String,Microsoft.Practices.ObjectBuilder2.IPolicyList)">
      <summary>
            Add policies to the <paramref name="policies" /> to configure the
            container to call this constructor with the appropriate parameter values.
            </summary>
      <param name="typeToCreate">Type to register.</param>
      <param name="name">Name used to resolve the type object.</param>
      <param name="policies">Policy list to add policies to.</param>
    </member>
    <member name="T:Microsoft.Practices.Unity.InjectionMethod">
      <summary>
            An <see cref="T:Microsoft.Practices.Unity.InjectionMember" /> that configures the
            container to call a method as part of buildup.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.InjectionMethod.#ctor(System.String,System.Object[])">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.InjectionMethod" /> instance which will configure
            the container to call the given methods with the given parameters.
            </summary>
      <param name="methodName">Name of the method to call.</param>
      <param name="methodParameters">Parameter values for the method.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.InjectionMethod.AddPolicies(System.Type,System.String,Microsoft.Practices.ObjectBuilder2.IPolicyList)">
      <summary>
            Add policies to the <paramref name="policies" /> to configure the
            container to call this constructor with the appropriate parameter values.
            </summary>
      <param name="typeToCreate">Type to register.</param>
      <param name="name">Name used to resolve the type object.</param>
      <param name="policies">Policy list to add policies to.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.InjectionMethod.MethodNameMatches(System.Reflection.MemberInfo,System.String)">
      <summary>
            A small function to handle name matching. You can override this
            to do things like case insensitive comparisons.
            </summary>
      <param name="targetMethod">MethodInfo for the method you're checking.</param>
      <param name="nameToMatch">Name of the method you're looking for.</param>
      <returns>True if a match, false if not.</returns>
    </member>
    <member name="T:Microsoft.Practices.Unity.TypedInjectionValue">
      <summary>
            A base class for implementing <see cref="T:Microsoft.Practices.Unity.InjectionParameterValue" /> classes
            that deal in explicit types.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.TypedInjectionValue.#ctor(System.Type)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.TypedInjectionValue" /> that exposes
            information about the given <paramref name="parameterType" />.
            </summary>
      <param name="parameterType">Type of the parameter.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.TypedInjectionValue.MatchesType(System.Type)">
      <summary>
            Test to see if this parameter value has a matching type for the given type.
            </summary>
      <param name="t">Type to check.</param>
      <returns>True if this parameter value is compatible with type <paramref name="t" />,
            false if not.</returns>
    </member>
    <member name="P:Microsoft.Practices.Unity.TypedInjectionValue.ParameterType">
      <summary>
            The type of parameter this object represents.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.TypedInjectionValue.ParameterTypeName">
      <summary>
            Name for the type represented by this <see cref="T:Microsoft.Practices.Unity.InjectionParameterValue" />.
            This may be an actual type name or a generic argument name.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.InjectionParameter">
      <summary>
            A class that holds on to the given value and provides
            the required <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" />
            when the container is configured.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.InjectionParameter.#ctor(System.Object)">
      <summary>
            Create an instance of <see cref="T:Microsoft.Practices.Unity.InjectionParameter" /> that stores
            the given value, using the runtime type of that value as the
            type of the parameter.
            </summary>
      <param name="parameterValue">Value to be injected for this parameter.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.InjectionParameter.#ctor(System.Type,System.Object)">
      <summary>
            Create an instance of <see cref="T:Microsoft.Practices.Unity.InjectionParameter" /> that stores
            the given value, associated with the given type.
            </summary>
      <param name="parameterType">Type of the parameter.</param>
      <param name="parameterValue">Value of the parameter</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.InjectionParameter.GetResolverPolicy(System.Type)">
      <summary>
            Return a <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" /> instance that will
            return this types value for the parameter.
            </summary>
      <param name="typeToBuild">Type that contains the member that needs this parameter. Used
            to resolve open generic parameters.</param>
      <returns>The <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" />.</returns>
    </member>
    <member name="T:Microsoft.Practices.Unity.InjectionParameter`1">
      <summary>
            A generic version of <see cref="T:Microsoft.Practices.Unity.InjectionParameter" /> that makes it a
            little easier to specify the type of the parameter.
            </summary>
      <typeparam name="TParameter">Type of parameter.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.Unity.InjectionParameter`1.#ctor(`0)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.InjectionParameter`1" />.
            </summary>
      <param name="parameterValue">Value for the parameter.</param>
    </member>
    <member name="T:Microsoft.Practices.Unity.InjectionProperty">
      <summary>
            This class stores information about which properties to inject,
            and will configure the container accordingly.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.InjectionProperty.#ctor(System.String)">
      <summary>
            Configure the container to inject the given property name,
            resolving the value via the container.
            </summary>
      <param name="propertyName">Name of the property to inject.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.InjectionProperty.#ctor(System.String,System.Object)">
      <summary>
            Configure the container to inject the given property name,
            using the value supplied. This value is converted to an
            <see cref="T:Microsoft.Practices.Unity.InjectionParameterValue" /> object using the
            rules defined by the <see cref="M:Microsoft.Practices.Unity.InjectionParameterValue.ToParameters(System.Object[])" />
            method.
            </summary>
      <param name="propertyName">Name of property to inject.</param>
      <param name="propertyValue">Value for property.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.InjectionProperty.AddPolicies(System.Type,System.String,Microsoft.Practices.ObjectBuilder2.IPolicyList)">
      <summary>
            Add policies to the <paramref name="policies" /> to configure the
            container to call this constructor with the appropriate parameter values.
            </summary>
      <param name="typeToCreate">Type to register.</param>
      <param name="name">Name used to resolve the type object.</param>
      <param name="policies">Policy list to add policies to.</param>
    </member>
    <member name="T:Microsoft.Practices.Unity.ResolvedArrayParameter">
      <summary>
            A class that stores a type, and generates a 
            resolver object that resolves all the named instances or the
            type registered in a container.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.ResolvedArrayParameter.#ctor(System.Type,System.Object[])">
      <summary>
            Construct a new <see cref="T:Microsoft.Practices.Unity.ResolvedArrayParameter" /> that
            resolves to the given element type and collection of element values.
            </summary>
      <param name="elementType">The type of elements to resolve.</param>
      <param name="elementValues">The values for the elements, that will
            be converted to <see cref="T:Microsoft.Practices.Unity.InjectionParameterValue" /> objects.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.ResolvedArrayParameter.#ctor(System.Type,System.Type,System.Object[])">
      <summary>
            Construct a new <see cref="T:Microsoft.Practices.Unity.ResolvedArrayParameter" /> that
            resolves to the given array and element types and collection of element values.
            </summary>
      <param name="arrayParameterType">The type for the array of elements to resolve.</param>
      <param name="elementType">The type of elements to resolve.</param>
      <param name="elementValues">The values for the elements, that will
            be converted to <see cref="T:Microsoft.Practices.Unity.InjectionParameterValue" /> objects.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.ResolvedArrayParameter.GetResolverPolicy(System.Type)">
      <summary>
            Return a <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" /> instance that will
            return this types value for the parameter.
            </summary>
      <param name="typeToBuild">Type that contains the member that needs this parameter. Used
            to resolve open generic parameters.</param>
      <returns>The <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" />.</returns>
    </member>
    <member name="T:Microsoft.Practices.Unity.ResolvedArrayParameter`1">
      <summary>
            A generic version of <see cref="T:Microsoft.Practices.Unity.ResolvedArrayParameter" /> for convenience
            when creating them by hand.
            </summary>
      <typeparam name="TElement">Type of the elements for the array of the parameter.</typeparam>
    </member>
    <member name="M:Microsoft.Practices.Unity.ResolvedArrayParameter`1.#ctor(System.Object[])">
      <summary>
            Construct a new <see cref="T:Microsoft.Practices.Unity.ResolvedArrayParameter`1" /> that
            resolves to the given element generic type with the given element values.
            </summary>
      <param name="elementValues">The values for the elements, that will
            be converted to <see cref="T:Microsoft.Practices.Unity.InjectionParameterValue" /> objects.</param>
    </member>
    <member name="T:Microsoft.Practices.Unity.IUnityContainer">
      <summary>
            Interface defining the behavior of the Unity dependency injection container.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType``1(Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            Register a type with specific members to be injected.
            </summary>
      <typeparam name="T">Type this registration is for.</typeparam>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType``2(Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            Register a type mapping with the container.
            </summary>
      <remarks>
        <para>
            This method is used to tell the container that when asked for type <typeparamref name="TFrom" />,
            actually return an instance of type <typeparamref name="TTo" />. This is very useful for
            getting instances of interfaces.
            </para>
        <para>
            This overload registers a default mapping and transient lifetime.
            </para>
      </remarks>
      <typeparam name="TFrom">
        <see cref="T:System.Type" /> that will be requested.</typeparam>
      <typeparam name="TTo">
        <see cref="T:System.Type" /> that will actually be returned.</typeparam>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType``2(Microsoft.Practices.Unity.LifetimeManager,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            Register a type mapping with the container, where the created instances will use
            the given <see cref="T:Microsoft.Practices.Unity.LifetimeManager" />.
            </summary>
      <typeparam name="TFrom">
        <see cref="T:System.Type" /> that will be requested.</typeparam>
      <typeparam name="TTo">
        <see cref="T:System.Type" /> that will actually be returned.</typeparam>
      <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> that controls the lifetime
            of the returned instance.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType``2(System.String,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            Register a type mapping with the container.
            </summary>
      <remarks>
            This method is used to tell the container that when asked for type <typeparamref name="TFrom" />,
            actually return an instance of type <typeparamref name="TTo" />. This is very useful for
            getting instances of interfaces.
            </remarks>
      <typeparam name="TFrom">
        <see cref="T:System.Type" /> that will be requested.</typeparam>
      <typeparam name="TTo">
        <see cref="T:System.Type" /> that will actually be returned.</typeparam>
      <param name="name">Name of this mapping.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType``2(System.String,Microsoft.Practices.Unity.LifetimeManager,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            Register a type mapping with the container, where the created instances will use
            the given <see cref="T:Microsoft.Practices.Unity.LifetimeManager" />.
            </summary>
      <typeparam name="TFrom">
        <see cref="T:System.Type" /> that will be requested.</typeparam>
      <typeparam name="TTo">
        <see cref="T:System.Type" /> that will actually be returned.</typeparam>
      <param name="name">Name to use for registration, null if a default registration.</param>
      <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> that controls the lifetime
            of the returned instance.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType``1(Microsoft.Practices.Unity.LifetimeManager,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            Register a <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> for the given type with the container.
            No type mapping is performed for this type.
            </summary>
      <typeparam name="T">The type to apply the <paramref name="lifetimeManager" /> to.</typeparam>
      <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> that controls the lifetime
            of the returned instance.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType``1(System.String,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            Register a <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> for the given type with the container.
            No type mapping is performed for this type.
            </summary>
      <typeparam name="T">The type to configure injection on.</typeparam>
      <param name="name">Name that will be used to request the type.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType``1(System.String,Microsoft.Practices.Unity.LifetimeManager,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            Register a <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> for the given type and name with the container.
            No type mapping is performed for this type.
            </summary>
      <typeparam name="T">The type to apply the <paramref name="lifetimeManager" /> to.</typeparam>
      <param name="name">Name that will be used to request the type.</param>
      <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> that controls the lifetime
            of the returned instance.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType(System.Type,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            Register a type with specific members to be injected.
            </summary>
      <param name="t">Type this registration is for.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType(System.Type,System.Type,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            Register a type mapping with the container.
            </summary>
      <remarks>
        <para>
            This method is used to tell the container that when asked for type <paramref name="from" />,
            actually return an instance of type <paramref name="to" />. This is very useful for
            getting instances of interfaces.
            </para>
        <para>
            This overload registers a default mapping.
            </para>
      </remarks>
      <param name="from">
        <see cref="T:System.Type" /> that will be requested.</param>
      <param name="to">
        <see cref="T:System.Type" /> that will actually be returned.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType(System.Type,System.Type,System.String,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            Register a type mapping with the container.
            </summary>
      <remarks>
            This method is used to tell the container that when asked for type <paramref name="from" />,
            actually return an instance of type <paramref name="to" />. This is very useful for
            getting instances of interfaces.
            </remarks>
      <param name="from">
        <see cref="T:System.Type" /> that will be requested.</param>
      <param name="to">
        <see cref="T:System.Type" /> that will actually be returned.</param>
      <param name="name">Name to use for registration, null if a default registration.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType(System.Type,System.Type,Microsoft.Practices.Unity.LifetimeManager,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            Register a type mapping with the container, where the created instances will use
            the given <see cref="T:Microsoft.Practices.Unity.LifetimeManager" />.
            </summary>
      <param name="from">
        <see cref="T:System.Type" /> that will be requested.</param>
      <param name="to">
        <see cref="T:System.Type" /> that will actually be returned.</param>
      <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> that controls the lifetime
            of the returned instance.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType(System.Type,Microsoft.Practices.Unity.LifetimeManager,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            Register a <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> for the given type and name with the container.
            No type mapping is performed for this type.
            </summary>
      <param name="t">The <see cref="T:System.Type" /> to apply the <paramref name="lifetimeManager" /> to.</param>
      <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> that controls the lifetime
            of the returned instance.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType(System.Type,System.String,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            Register a <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> for the given type and name with the container.
            No type mapping is performed for this type.
            </summary>
      <param name="t">The <see cref="T:System.Type" /> to configure in the container.</param>
      <param name="name">Name to use for registration, null if a default registration.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType(System.Type,System.String,Microsoft.Practices.Unity.LifetimeManager,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            Register a <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> for the given type and name with the container.
            No type mapping is performed for this type.
            </summary>
      <param name="t">The <see cref="T:System.Type" /> to apply the <paramref name="lifetimeManager" /> to.</param>
      <param name="name">Name to use for registration, null if a default registration.</param>
      <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> that controls the lifetime
            of the returned instance.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType(System.Type,System.Type,System.String,Microsoft.Practices.Unity.LifetimeManager,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            Register a type mapping with the container, where the created instances will use
            the given <see cref="T:Microsoft.Practices.Unity.LifetimeManager" />.
            </summary>
      <param name="from">
        <see cref="T:System.Type" /> that will be requested.</param>
      <param name="to">
        <see cref="T:System.Type" /> that will actually be returned.</param>
      <param name="name">Name to use for registration, null if a default registration.</param>
      <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> that controls the lifetime
            of the returned instance.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterInstance``1(``0)">
      <summary>
            Register an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
        <para>
            This overload does a default registration and has the container take over the lifetime of the instance.</para>
      </remarks>
      <typeparam name="TInterface">Type of instance to register (may be an implemented interface instead of the full type).</typeparam>
      <param name="instance">Object to returned.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterInstance``1(``0,Microsoft.Practices.Unity.LifetimeManager)">
      <summary>
            Register an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
        <para>
            This overload does a default registration (name = null).
            </para>
      </remarks>
      <typeparam name="TInterface">Type of instance to register (may be an implemented interface instead of the full type).</typeparam>
      <param name="instance">Object to returned.</param>
      <param name="lifetimeManager">
        <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> object that controls how this instance will be managed by the container.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterInstance``1(System.String,``0)">
      <summary>
            Register an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
        <para>
            This overload automatically has the container take ownership of the <paramref name="instance" />.</para>
      </remarks>
      <typeparam name="TInterface">Type of instance to register (may be an implemented interface instead of the full type).</typeparam>
      <param name="instance">Object to returned.</param>
      <param name="name">Name for registration.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterInstance``1(System.String,``0,Microsoft.Practices.Unity.LifetimeManager)">
      <summary>
            Register an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
      </remarks>
      <typeparam name="TInterface">Type of instance to register (may be an implemented interface instead of the full type).</typeparam>
      <param name="instance">Object to returned.</param>
      <param name="name">Name for registration.</param>
      <param name="lifetimeManager">
        <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> object that controls how this instance will be managed by the container.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterInstance(System.Type,System.Object)">
      <summary>
            Register an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
        <para>
            This overload does a default registration and has the container take over the lifetime of the instance.</para>
      </remarks>
      <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
      <param name="instance">Object to returned.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterInstance(System.Type,System.Object,Microsoft.Practices.Unity.LifetimeManager)">
      <summary>
            Register an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
        <para>
            This overload does a default registration (name = null).
            </para>
      </remarks>
      <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
      <param name="instance">Object to returned.</param>
      <param name="lifetimeManager">
        <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> object that controls how this instance will be managed by the container.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterInstance(System.Type,System.String,System.Object)">
      <summary>
            Register an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
        <para>
            This overload automatically has the container take ownership of the <paramref name="instance" />.</para>
      </remarks>
      <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
      <param name="instance">Object to returned.</param>
      <param name="name">Name for registration.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterInstance(System.Type,System.String,System.Object,Microsoft.Practices.Unity.LifetimeManager)">
      <summary>
            Register an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
      </remarks>
      <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
      <param name="instance">Object to returned.</param>
      <param name="name">Name for registration.</param>
      <param name="lifetime">
        <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> object that controls how this instance will be managed by the container.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.Resolve``1">
      <summary>
            Resolve an instance of the default requested type from the container.
            </summary>
      <typeparam name="T">
        <see cref="T:System.Type" /> of object to get from the container.</typeparam>
      <returns>The retrieved object.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.Resolve``1(System.String)">
      <summary>
            Resolve an instance of the requested type with the given name from the container.
            </summary>
      <typeparam name="T">
        <see cref="T:System.Type" /> of object to get from the container.</typeparam>
      <param name="name">Name of the object to retrieve.</param>
      <returns>The retrieved object.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.Resolve(System.Type)">
      <summary>
            Resolve an instance of the default requested type from the container.
            </summary>
      <param name="t">
        <see cref="T:System.Type" /> of object to get from the container.</param>
      <returns>The retrieved object.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.Resolve(System.Type,System.String)">
      <summary>
            Resolve an instance of the requested type with the given name from the container.
            </summary>
      <param name="t">
        <see cref="T:System.Type" /> of object to get from the container.</param>
      <param name="name">Name of the object to retrieve.</param>
      <returns>The retrieved object.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.ResolveAll``1">
      <summary>
            Return instances of all registered types requested.
            </summary>
      <remarks>
        <para>
            This method is useful if you've registered multiple types with the same
            <see cref="T:System.Type" /> but different names.
            </para>
        <para>
            Be aware that this method does NOT return an instance for the default (unnamed) registration.
            </para>
      </remarks>
      <typeparam name="T">The type requested.</typeparam>
      <returns>Set of objects of type <typeparamref name="T" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.ResolveAll(System.Type)">
      <summary>
            Return instances of all registered types requested.
            </summary>
      <remarks>
        <para>
            This method is useful if you've registered multiple types with the same
            <see cref="T:System.Type" /> but different names.
            </para>
        <para>
            Be aware that this method does NOT return an instance for the default (unnamed) registration.
            </para>
      </remarks>
      <param name="t">The type requested.</param>
      <returns>Set of objects of type <paramref name="t" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.BuildUp``1(``0)">
      <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
      <remarks>
        <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para>
        <para>
            This overload uses the default registrations.
            </para>
      </remarks>
      <typeparam name="T">
        <see cref="T:System.Type" /> of object to perform injection on.</typeparam>
      <param name="existing">Instance to build up.</param>
      <returns>The resulting object. By default, this will be <paramref name="existing" />, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <typeparamref name="T" />).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.BuildUp``1(``0,System.String)">
      <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
      <remarks>
        <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para>
      </remarks>
      <typeparam name="T">
        <see cref="T:System.Type" /> of object to perform injection on.</typeparam>
      <param name="existing">Instance to build up.</param>
      <param name="name">name to use when looking up the typemappings and other configurations.</param>
      <returns>The resulting object. By default, this will be <paramref name="existing" />, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <typeparamref name="T" />).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.BuildUp(System.Type,System.Object)">
      <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
      <remarks>
        <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para>
        <para>
            This overload uses the default registrations.
            </para>
      </remarks>
      <param name="t">
        <see cref="T:System.Type" /> of object to perform injection on.</param>
      <param name="existing">Instance to build up.</param>
      <returns>The resulting object. By default, this will be <paramref name="existing" />, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <paramref name="t" />).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.BuildUp(System.Type,System.Object,System.String)">
      <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
      <remarks>
        <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para>
      </remarks>
      <param name="t">
        <see cref="T:System.Type" /> of object to perform injection on.</param>
      <param name="existing">Instance to build up.</param>
      <param name="name">name to use when looking up the typemappings and other configurations.</param>
      <returns>The resulting object. By default, this will be <paramref name="existing" />, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <paramref name="t" />).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.Teardown(System.Object)">
      <summary>
            Run an existing object through the container, and clean it up.
            </summary>
      <param name="o">The object to tear down.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.AddExtension(Microsoft.Practices.Unity.UnityContainerExtension)">
      <summary>
            Add an extension object to the container.
            </summary>
      <param name="extension">
        <see cref="T:Microsoft.Practices.Unity.UnityContainerExtension" /> to add.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.AddNewExtension``1">
      <summary>
            Creates a new extension object and adds it to the container.
            </summary>
      <typeparam name="TExtension">Type of <see cref="T:Microsoft.Practices.Unity.UnityContainerExtension" /> to add. The extension type
            must have a zero-argument public constructor.</typeparam>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.Configure``1">
      <summary>
            Resolve access to a configuration interface exposed by an extension.
            </summary>
      <remarks>Extensions can expose configuration interfaces as well as adding
            strategies and policies to the container. This method walks the list of
            added extensions and returns the first one that implements the requested type.
            </remarks>
      <typeparam name="TConfigurator">The configuration interface required.</typeparam>
      <returns>The requested extension's configuration interface, or null if not found.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.Configure(System.Type)">
      <summary>
            Resolve access to a configuration interface exposed by an extension.
            </summary>
      <remarks>Extensions can expose configuration interfaces as well as adding
            strategies and policies to the container. This method walks the list of
            added extensions and returns the first one that implements the requested type.
            </remarks>
      <param name="configurationInterface">
        <see cref="T:System.Type" /> of configuration interface required.</param>
      <returns>The requested extension's configuration interface, or null if not found.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.RemoveAllExtensions">
      <summary>
            Remove all installed extensions from this container.
            </summary>
      <remarks>
        <para>
            This method removes all extensions from the container, including the default ones
            that implement the out-of-the-box behavior. After this method, if you want to use
            the container again you will need to either readd the default extensions or replace
            them with your own.
            </para>
        <para>
            The registered instances and singletons that have already been set up in this container
            do not get removed.
            </para>
      </remarks>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.IUnityContainer.CreateChildContainer">
      <summary>
            Create a child container.
            </summary>
      <remarks>
            A child container shares the parent's configuration, but can be configured with different
            settings or lifetime.</remarks>
      <returns>The new child container.</returns>
    </member>
    <member name="P:Microsoft.Practices.Unity.IUnityContainer.Parent">
      <summary>
            The parent of this container.
            </summary>
      <value>The parent container, or null if this container doesn't have one.</value>
    </member>
    <member name="T:Microsoft.Practices.Unity.LifetimeManager">
      <summary>
            Base class for Lifetime managers - classes that control how
            and when instances are created by the Unity container.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.LifetimeManager.GetValue">
      <summary>
            Retrieve a value from the backing store associated with this Lifetime policy.
            </summary>
      <returns>the object desired, or null if no such object is currently stored.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.LifetimeManager.SetValue(System.Object)">
      <summary>
            Stores the given value into backing store for retrieval later.
            </summary>
      <param name="newValue">The object being stored.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.LifetimeManager.RemoveValue">
      <summary>
            Remove the given object from backing store.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.SynchronizedLifetimeManager">
      <summary>
            Base class for Lifetime managers which need to synchronize calls to
            <see cref="M:Microsoft.Practices.Unity.SynchronizedLifetimeManager.GetValue" />.
            </summary>
      <remarks>
        <para>
            The purpose of this class is to provide a basic implementation of the lifetime manager synchronization pattern.
            </para>
        <para>
            Calls to the <see cref="M:Microsoft.Practices.Unity.SynchronizedLifetimeManager.GetValue" /> method of a <see cref="T:Microsoft.Practices.Unity.SynchronizedLifetimeManager" /> 
            instance acquire a lock, and if the instance has not been initialized with a value yet the lock will only be released 
            when such an initialization takes place by calling the <see cref="M:Microsoft.Practices.Unity.SynchronizedLifetimeManager.SetValue(System.Object)" /> method or if 
            the build request which resulted in the call to the GetValue method fails.
            </para>
      </remarks>
      <see cref="T:Microsoft.Practices.Unity.LifetimeManager" />
    </member>
    <member name="M:Microsoft.Practices.Unity.SynchronizedLifetimeManager.GetValue">
      <summary>
            Retrieve a value from the backing store associated with this Lifetime policy.
            </summary>
      <returns>the object desired, or null if no such object is currently stored.</returns>
      <remarks>Calls to this method acquire a lock which is released only if a non-null value
            has been set for the lifetime manager.</remarks>
    </member>
    <member name="M:Microsoft.Practices.Unity.SynchronizedLifetimeManager.SynchronizedGetValue">
      <summary>
            Performs the actual retrieval of a value from the backing store associated 
            with this Lifetime policy.
            </summary>
      <returns>the object desired, or null if no such object is currently stored.</returns>
      <remarks>This method is invoked by <see cref="M:Microsoft.Practices.Unity.SynchronizedLifetimeManager.GetValue" />
            after it has acquired its lock.</remarks>
    </member>
    <member name="M:Microsoft.Practices.Unity.SynchronizedLifetimeManager.SetValue(System.Object)">
      <summary>
            Stores the given value into backing store for retrieval later.
            </summary>
      <param name="newValue">The object being stored.</param>
      <remarks>Setting a value will attempt to release the lock acquired by 
            <see cref="M:Microsoft.Practices.Unity.SynchronizedLifetimeManager.GetValue" />.</remarks>
    </member>
    <member name="M:Microsoft.Practices.Unity.SynchronizedLifetimeManager.SynchronizedSetValue(System.Object)">
      <summary>
            Performs the actual storage of the given value into backing store for retrieval later.
            </summary>
      <param name="newValue">The object being stored.</param>
      <remarks>This method is invoked by <see cref="M:Microsoft.Practices.Unity.SynchronizedLifetimeManager.SetValue(System.Object)" />
            before releasing its lock.</remarks>
    </member>
    <member name="M:Microsoft.Practices.Unity.SynchronizedLifetimeManager.RemoveValue">
      <summary>
            Remove the given object from backing store.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.SynchronizedLifetimeManager.Recover">
      <summary>
            A method that does whatever is needed to clean up
            as part of cleaning up after an exception.
            </summary>
      <remarks>
            Don't do anything that could throw in this method,
            it will cause later recover operations to get skipped
            and play real havok with the stack trace.
            </remarks>
    </member>
    <member name="T:Microsoft.Practices.Unity.ContainerControlledLifetimeManager">
      <summary>
            A <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> that holds onto the instance given to it.
            When the <see cref="T:Microsoft.Practices.Unity.ContainerControlledLifetimeManager" /> is disposed,
            the instance is disposed with it.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.ContainerControlledLifetimeManager.SynchronizedGetValue">
      <summary>
            Retrieve a value from the backing store associated with this Lifetime policy.
            </summary>
      <returns>the object desired, or null if no such object is currently stored.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.ContainerControlledLifetimeManager.SynchronizedSetValue(System.Object)">
      <summary>
            Stores the given value into backing store for retrieval later.
            </summary>
      <param name="newValue">The object being stored.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.ContainerControlledLifetimeManager.RemoveValue">
      <summary>
            Remove the given object from backing store.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.ContainerControlledLifetimeManager.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:Microsoft.Practices.Unity.ContainerControlledLifetimeManager.Dispose(System.Boolean)">
      <summary>
            Standard Dispose pattern implementation. Not needed, but it keeps FxCop happy.
            </summary>
      <param name="disposing">Always true, since we don't have a finalizer.</param>
    </member>
    <member name="T:Microsoft.Practices.Unity.ExternallyControlledLifetimeManager">
      <summary>
            A <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> that holds a weak reference to
            it's managed instance.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.ExternallyControlledLifetimeManager.GetValue">
      <summary>
            Retrieve a value from the backing store associated with this Lifetime policy.
            </summary>
      <returns>the object desired, or null if no such object is currently stored.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.ExternallyControlledLifetimeManager.SetValue(System.Object)">
      <summary>
            Stores the given value into backing store for retrieval later.
            </summary>
      <param name="newValue">The object being stored.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.ExternallyControlledLifetimeManager.RemoveValue">
      <summary>
            Remove the given object from backing store.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.LifetimeManagerFactory">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeFactoryPolicy" /> that
            creates instances of the type of the given Lifetime Manager
            by resolving them through the container.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.LifetimeManagerFactory.#ctor(Microsoft.Practices.Unity.ExtensionContext,System.Type)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.LifetimeManagerFactory" /> that will
            return instances of the given type, creating them by
            resolving through the container.
            </summary>
      <param name="containerContext">Container to resolve with.</param>
      <param name="lifetimeType">Type of LifetimeManager to create.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.LifetimeManagerFactory.CreateLifetimePolicy">
      <summary>
            Create a new instance of <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimePolicy" />.
            </summary>
      <returns>The new instance.</returns>
    </member>
    <member name="T:Microsoft.Practices.Unity.PerThreadLifetimeManager">
      <summary>
            A <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> that holds the instances given to it, 
            keeping one instance per thread.
            </summary>
      <remarks>
        <para>
            This LifetimeManager does not dispose the instances it holds.
            </para>
      </remarks>
    </member>
    <member name="M:Microsoft.Practices.Unity.PerThreadLifetimeManager.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Practices.Unity.PerThreadLifetimeManager" /> class.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.PerThreadLifetimeManager.GetValue">
      <summary>
            Retrieve a value from the backing store associated with this Lifetime policy for the 
            current thread.
            </summary>
      <returns>the object desired, or <see langword="null" /> if no such object is currently 
            stored for the current thread.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.PerThreadLifetimeManager.SetValue(System.Object)">
      <summary>
            Stores the given value into backing store for retrieval later when requested
            in the current thread.
            </summary>
      <param name="newValue">The object being stored.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.PerThreadLifetimeManager.RemoveValue">
      <summary>
            Remove the given object from backing store.
            </summary>
      <remarks>Not implemented for this lifetime manager.</remarks>
    </member>
    <member name="T:Microsoft.Practices.Unity.TransientLifetimeManager">
      <summary>
            An <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> implementation that does nothing,
            thus ensuring that instances are created new every time.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.TransientLifetimeManager.GetValue">
      <summary>
            Retrieve a value from the backing store associated with this Lifetime policy.
            </summary>
      <returns>the object desired, or null if no such object is currently stored.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.TransientLifetimeManager.SetValue(System.Object)">
      <summary>
            Stores the given value into backing store for retrieval later.
            </summary>
      <param name="newValue">The object being stored.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.TransientLifetimeManager.RemoveValue">
      <summary>
            Remove the given object from backing store.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.ArrayResolutionStrategy">
      <summary>
            This strategy implements the logic that will call container.ResolveAll
            when an array parameter is detected.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.ArrayResolutionStrategy.PreBuildUp(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Do the PreBuildUp stage of construction. This is where the actual work is performed.
            </summary>
      <param name="context">Current build context.</param>
    </member>
    <member name="T:Microsoft.Practices.Unity.ObjectBuilder.DefaultUnityConstructorSelectorPolicy">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IConstructorSelectorPolicy" /> that is
            aware of the build keys used by the Unity container.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.ObjectBuilder.DefaultUnityConstructorSelectorPolicy.CreateResolver(System.Reflection.ParameterInfo)">
      <summary>
            Create a <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" /> instance for the given
            <see cref="T:System.Reflection.ParameterInfo" />.
            </summary>
      <remarks>
            This implementation looks for the Unity <see cref="T:Microsoft.Practices.Unity.DependencyAttribute" /> on the
            parameter and uses it to create an instance of <see cref="T:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy" />
            for this parameter.</remarks>
      <param name="param">Parameter to create the resolver for.</param>
      <returns>The resolver object.</returns>
    </member>
    <member name="T:Microsoft.Practices.Unity.ObjectBuilder.DefaultUnityMethodSelectorPolicy">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IMethodSelectorPolicy" /> that is aware
            of the build keys used by the Unity container.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.ObjectBuilder.DefaultUnityMethodSelectorPolicy.CreateResolver(System.Reflection.ParameterInfo)">
      <summary>
            Create a <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" /> instance for the given
            <see cref="T:System.Reflection.ParameterInfo" />.
            </summary>
      <param name="parameter">Parameter to create the resolver for.</param>
      <returns>The resolver object.</returns>
    </member>
    <member name="T:Microsoft.Practices.Unity.ObjectBuilder.DefaultUnityPropertySelectorPolicy">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IPropertySelectorPolicy" /> that is aware of
            the build keys used by the unity container.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.ObjectBuilder.DefaultUnityPropertySelectorPolicy.CreateResolver(System.Reflection.PropertyInfo)">
      <summary>
            Create a <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" /> for the given
            property.
            </summary>
      <param name="property">Property to create resolver for.</param>
      <returns>The resolver object.</returns>
    </member>
    <member name="T:Microsoft.Practices.Unity.ObjectBuilder.LiteralValueDependencyResolverPolicy">
      <summary>
            A <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" /> implementation that returns
            the value set in the constructor.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.ObjectBuilder.LiteralValueDependencyResolverPolicy.#ctor(System.Object)">
      <summary>
            Create a new instance of <see cref="T:Microsoft.Practices.Unity.ObjectBuilder.LiteralValueDependencyResolverPolicy" />
            which will return the given value when resolved.
            </summary>
      <param name="dependencyValue">The value to return.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.ObjectBuilder.LiteralValueDependencyResolverPolicy.Resolve(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Get the value for a dependency.
            </summary>
      <param name="context">Current build context.</param>
      <returns>The value for the dependency.</returns>
    </member>
    <member name="T:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" /> that stores a
            type and name, and at resolution time puts them together into a
            <see cref="T:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy.#ctor(System.Type,System.String)">
      <summary>
            Create an instance of <see cref="T:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy" />
            with the given type and name.
            </summary>
      <param name="type">The type.</param>
      <param name="name">The name (may be null).</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy.Resolve(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Resolve the value for a dependency.
            </summary>
      <param name="context">Current build context.</param>
      <returns>The value for the dependency.</returns>
    </member>
    <member name="P:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy.Type">
      <summary>
            The type that this resolver resolves.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy.Name">
      <summary>
            The name that this resolver resolves.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.ResolvedArrayWithElementsResolverPolicy">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" /> that resolves to
            to an array populated with the values that result from resolving other instances
            of <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.ResolvedArrayWithElementsResolverPolicy.#ctor(System.Type,Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy[])">
      <summary>
            Create an instance of <see cref="T:Microsoft.Practices.Unity.ResolvedArrayWithElementsResolverPolicy" />
            with the given type and a collection of <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" />
            instances to use when populating the result.
            </summary>
      <param name="elementType">The type.</param>
      <param name="elementPolicies">The resolver policies to use when populating an array.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.ResolvedArrayWithElementsResolverPolicy.Resolve(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Resolve the value for a dependency.
            </summary>
      <param name="context">Current build context.</param>
      <returns>An array pupulated with the results of resolving the resolver policies.</returns>
    </member>
    <member name="T:Microsoft.Practices.Unity.ObjectBuilder.SpecifiedConstructorSelectorPolicy">
      <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IConstructorSelectorPolicy" /> that selects
            the given constructor and creates the appropriate resolvers to call it with
            the specified parameters.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.ObjectBuilder.SpecifiedConstructorSelectorPolicy.#ctor(System.Reflection.ConstructorInfo,Microsoft.Practices.Unity.InjectionParameterValue[])">
      <summary>
            Create an instance of <see cref="T:Microsoft.Practices.Unity.ObjectBuilder.SpecifiedConstructorSelectorPolicy" /> that
            will return the given constructor, being passed the given injection values
            as parameters.
            </summary>
      <param name="ctor">The constructor to call.</param>
      <param name="parameterValues">Set of <see cref="T:Microsoft.Practices.Unity.InjectionParameterValue" /> objects
            that describes how to obtain the values for the constructor parameters.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.ObjectBuilder.SpecifiedConstructorSelectorPolicy.SelectConstructor(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Choose the constructor to call for the given type.
            </summary>
      <param name="context">Current build context</param>
      <returns>The chosen constructor.</returns>
    </member>
    <member name="T:Microsoft.Practices.Unity.ObjectBuilder.SpecifiedMemberSelectorHelper">
      <summary>
            Helper class for implementing selector policies that need to
            set up dependency resolver policies.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.ObjectBuilder.SpecifiedMemberSelectorHelper.AddParameterResolvers(System.Type,Microsoft.Practices.ObjectBuilder2.IPolicyList,System.Collections.Generic.IEnumerable{Microsoft.Practices.Unity.InjectionParameterValue},Microsoft.Practices.ObjectBuilder2.SelectedMemberWithParameters)">
      <summary>
            Add dependency resolvers to the parameter set.
            </summary>
      <param name="typeToBuild">Type that's currently being built (used to resolve open generics).</param>
      <param name="policies">PolicyList to add the resolvers to.</param>
      <param name="parameterValues">Objects supplying the dependency resolvers.</param>
      <param name="result">Result object to store the keys in.</param>
    </member>
    <member name="T:Microsoft.Practices.Unity.ObjectBuilder.SpecifiedMethodsSelectorPolicy">
      <summary>
            A <see cref="T:Microsoft.Practices.ObjectBuilder2.IMethodSelectorPolicy" /> implementation that calls the specific
            methods with the given parameters.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.ObjectBuilder.SpecifiedMethodsSelectorPolicy.AddMethodAndParameters(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{Microsoft.Practices.Unity.InjectionParameterValue})">
      <summary>
            Add the given method and parameter collection to the list of methods
            that will be returned when the selector's <see cref="M:Microsoft.Practices.ObjectBuilder2.IMethodSelectorPolicy.SelectMethods(Microsoft.Practices.ObjectBuilder2.IBuilderContext)" />
            method is called.
            </summary>
      <param name="method">Method to call.</param>
      <param name="parameters">sequence of <see cref="T:Microsoft.Practices.Unity.InjectionParameterValue" /> objects
            that describe how to create the method parameter values.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.ObjectBuilder.SpecifiedMethodsSelectorPolicy.SelectMethods(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Return the sequence of methods to call while building the target object.
            </summary>
      <param name="context">Current build context.</param>
      <returns>Sequence of methods to call.</returns>
    </member>
    <member name="T:Microsoft.Practices.Unity.ObjectBuilder.SpecifiedPropertiesSelectorPolicy">
      <summary>
            An implemnetation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IPropertySelectorPolicy" /> which returns
            the set of specific properties that the selector was configured with.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.ObjectBuilder.SpecifiedPropertiesSelectorPolicy.AddPropertyAndValue(System.Reflection.PropertyInfo,Microsoft.Practices.Unity.InjectionParameterValue)">
      <summary>
            Add a property that will be par of the set returned when the 
            <see cref="M:Microsoft.Practices.Unity.ObjectBuilder.SpecifiedPropertiesSelectorPolicy.SelectProperties(Microsoft.Practices.ObjectBuilder2.IBuilderContext)" /> is called.
            </summary>
      <param name="property">The property to set.</param>
      <param name="value">
        <see cref="T:Microsoft.Practices.Unity.InjectionParameterValue" /> object describing
            how to create the value to inject.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.ObjectBuilder.SpecifiedPropertiesSelectorPolicy.SelectProperties(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
      <summary>
            Returns sequence of properties on the given type that
            should be set as part of building that object.
            </summary>
      <param name="context">Current build context.</param>
      <returns>Sequence of <see cref="T:System.Reflection.PropertyInfo" /> objects
            that contain the properties to set.</returns>
    </member>
    <member name="T:Microsoft.Practices.Unity.ResolutionFailedException">
      <summary>
            The exception thrown by the Unity container when
            an attempt to resolve a dependency fails.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.ResolutionFailedException.#ctor(System.Type,System.String,System.Exception)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.ResolutionFailedException" /> that records
            the exception for the given type and name.
            </summary>
      <param name="typeRequested">Type requested from the container.</param>
      <param name="nameRequested">Name requested from the container.</param>
      <param name="innerException">The actual exception that caused the failure of the build.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.ResolutionFailedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor to create a <see cref="T:Microsoft.Practices.Unity.ResolutionFailedException" /> from serialized state.
            </summary>
      <param name="info">Serialization info</param>
      <param name="context">Serialization context</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.ResolutionFailedException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Serialize this object into the given context.
            </summary>
      <param name="info">Serialization info</param>
      <param name="context">Streaming context</param>
    </member>
    <member name="P:Microsoft.Practices.Unity.ResolutionFailedException.TypeRequested">
      <summary>
            The type that was being requested from the container at the time of failure.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.ResolutionFailedException.NameRequested">
      <summary>
            The name that was being requested from the container at the time of failure.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.ResolvedParameter">
      <summary>
            A class that stores a name and type, and generates a 
            resolver object that resolves the parameter via the
            container.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.ResolvedParameter.#ctor(System.Type)">
      <summary>
            Construct a new <see cref="T:Microsoft.Practices.Unity.ResolvedParameter" /> that
            resolves to the given type.
            </summary>
      <param name="parameterType">Type of this parameter.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.ResolvedParameter.#ctor(System.Type,System.String)">
      <summary>
            Construct a new <see cref="T:Microsoft.Practices.Unity.ResolvedParameter" /> that
            resolves the given type and name.
            </summary>
      <param name="parameterType">Type of this parameter.</param>
      <param name="name">Name to use when resolving parameter.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.ResolvedParameter.GetResolverPolicy(System.Type)">
      <summary>
            Return a <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" /> instance that will
            return this types value for the parameter.
            </summary>
      <param name="typeToBuild">Type that contains the member that needs this parameter. Used
            to resolve open generic parameters.</param>
      <returns>The <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy" />.</returns>
    </member>
    <member name="T:Microsoft.Practices.Unity.ResolvedParameter`1">
      <summary>
            A generic version of <see cref="T:Microsoft.Practices.Unity.ResolvedParameter" /> for convenience
            when creating them by hand.
            </summary>
      <typeparam name="TParameter">Type of the parameter</typeparam>
    </member>
    <member name="M:Microsoft.Practices.Unity.ResolvedParameter`1.#ctor">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.ResolvedParameter`1" /> for the given
            generic type and the default name.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.ResolvedParameter`1.#ctor(System.String)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.ResolvedParameter`1" /> for the given
            generic type and name.
            </summary>
      <param name="name">Name to use to resolve this parameter.</param>
    </member>
    <member name="T:Microsoft.Practices.Unity.UnityContainerBase">
      <summary>
            A base class for implmenting <see cref="T:Microsoft.Practices.Unity.IUnityContainer" /> that provides
            reasonable implementations for most of the overloads defined by the interface.
            The overloads all call down to the non-generic versions of the methods with
            the most parameters.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType``1(Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            Register a type with specific members to be injected.
            </summary>
      <typeparam name="T">Type this registration is for.</typeparam>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType``2(Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            RegisterType a type mapping with the container.
            </summary>
      <remarks>
        <para>
            This method is used to tell the container that when asked for type <typeparamref name="TFrom" />,
            actually return an instance of type <typeparamref name="TTo" />. This is very useful for
            getting instances of interfaces.
            </para>
        <para>
            This overload registers a default mapping.
            </para>
      </remarks>
      <typeparam name="TFrom">
        <see cref="T:System.Type" /> that will be requested.</typeparam>
      <typeparam name="TTo">
        <see cref="T:System.Type" /> that will actually be returned.</typeparam>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType``2(System.String,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            RegisterType a type mapping with the container.
            </summary>
      <remarks>
            This method is used to tell the container that when asked for type <typeparamref name="TFrom" />,
            actually return an instance of type <typeparamref name="TTo" />. This is very useful for
            getting instances of interfaces.
            </remarks>
      <typeparam name="TFrom">
        <see cref="T:System.Type" /> that will be requested.</typeparam>
      <typeparam name="TTo">
        <see cref="T:System.Type" /> that will actually be returned.</typeparam>
      <param name="name">
      </param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType``2(Microsoft.Practices.Unity.LifetimeManager,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            RegisterType a type mapping with the container, where the created instances will use
            the given <see cref="T:Microsoft.Practices.Unity.LifetimeManager" />.
            </summary>
      <typeparam name="TFrom">
        <see cref="T:System.Type" /> that will be requested.</typeparam>
      <typeparam name="TTo">
        <see cref="T:System.Type" /> that will actually be returned.</typeparam>
      <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> that controls the lifetime
            of the returned instance.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType``2(System.String,Microsoft.Practices.Unity.LifetimeManager,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            RegisterType a type mapping with the container, where the created instances will use
            the given <see cref="T:Microsoft.Practices.Unity.LifetimeManager" />.
            </summary>
      <typeparam name="TFrom">
        <see cref="T:System.Type" /> that will be requested.</typeparam>
      <typeparam name="TTo">
        <see cref="T:System.Type" /> that will actually be returned.</typeparam>
      <param name="name">Name to use for registration, null if a default registration.</param>
      <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> that controls the lifetime
            of the returned instance.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType``1(Microsoft.Practices.Unity.LifetimeManager,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            RegisterType a <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> for the given type with the container.
            No type mapping is performed for this type.
            </summary>
      <typeparam name="T">The type to apply the <paramref name="lifetimeManager" /> to.</typeparam>
      <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> that controls the lifetime
            of the returned instance.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType``1(System.String,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            Register a <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> for the given type with the container.
            No type mapping is performed for this type.
            </summary>
      <typeparam name="T">The type to configure injection on.</typeparam>
      <param name="name">Name that will be used to request the type.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType``1(System.String,Microsoft.Practices.Unity.LifetimeManager,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            RegisterType a <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> for the given type and name with the container.
            No type mapping is performed for this type.
            </summary>
      <typeparam name="T">The type to apply the <paramref name="lifetimeManager" /> to.</typeparam>
      <param name="name">Name that will be used to request the type.</param>
      <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> that controls the lifetime
            of the returned instance.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType(System.Type,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            Register a type with specific members to be injected.
            </summary>
      <param name="t">Type this registration is for.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType(System.Type,System.Type,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            RegisterType a type mapping with the container.
            </summary>
      <remarks>
        <para>
            This method is used to tell the container that when asked for type <paramref name="from" />,
            actually return an instance of type <paramref name="to" />. This is very useful for
            getting instances of interfaces.
            </para>
        <para>
            This overload registers a default mapping.
            </para>
      </remarks>
      <param name="from">
        <see cref="T:System.Type" /> that will be requested.</param>
      <param name="to">
        <see cref="T:System.Type" /> that will actually be returned.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType(System.Type,System.Type,Microsoft.Practices.Unity.LifetimeManager,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            RegisterType a type mapping with the container, where the created instances will use
            the given <see cref="T:Microsoft.Practices.Unity.LifetimeManager" />.
            </summary>
      <param name="from">
        <see cref="T:System.Type" /> that will be requested.</param>
      <param name="to">
        <see cref="T:System.Type" /> that will actually be returned.</param>
      <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> that controls the lifetime
            of the returned instance.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType(System.Type,Microsoft.Practices.Unity.LifetimeManager,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            RegisterType a <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> for the given type and name with the container.
            No type mapping is performed for this type.
            </summary>
      <param name="t">The <see cref="T:System.Type" /> to apply the <paramref name="lifetimeManager" /> to.</param>
      <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> that controls the lifetime
            of the returned instance.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType(System.Type,System.String,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            Register a <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> for the given type and name with the container.
            No type mapping is performed for this type.
            </summary>
      <param name="t">The <see cref="T:System.Type" /> to configure in the container.</param>
      <param name="name">Name to use for registration, null if a default registration.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType(System.Type,System.String,Microsoft.Practices.Unity.LifetimeManager,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            RegisterType a <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> for the given type and name with the container.
            No type mapping is performed for this type.
            </summary>
      <param name="t">The <see cref="T:System.Type" /> to apply the <paramref name="lifetimeManager" /> to.</param>
      <param name="name">Name to use for registration, null if a default registration.</param>
      <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> that controls the lifetime
            of the returned instance.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType(System.Type,System.Type,System.String,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            RegisterType a type mapping with the container.
            </summary>
      <remarks>
            This method is used to tell the container that when asked for type <paramref name="from" />,
            actually return an instance of type <paramref name="to" />. This is very useful for
            getting instances of interfaces.
            </remarks>
      <param name="from">
        <see cref="T:System.Type" /> that will be requested.</param>
      <param name="to">
        <see cref="T:System.Type" /> that will actually be returned.</param>
      <param name="name">Name to use for registration, null if a default registration.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType(System.Type,System.Type,System.String,Microsoft.Practices.Unity.LifetimeManager,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            RegisterType a type mapping with the container, where the created instances will use
            the given <see cref="T:Microsoft.Practices.Unity.LifetimeManager" />.
            </summary>
      <param name="from">
        <see cref="T:System.Type" /> that will be requested.</param>
      <param name="to">
        <see cref="T:System.Type" /> that will actually be returned.</param>
      <param name="name">Name to use for registration, null if a default registration.</param>
      <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> that controls the lifetime
            of the returned instance.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterInstance``1(``0)">
      <summary>
            RegisterType an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
        <para>
            This overload does a default registration and has the container take over the lifetime of the instance.</para>
      </remarks>
      <typeparam name="TInterface">Type of instance to register (may be an implemented interface instead of the full type).</typeparam>
      <param name="instance">Object to returned.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterInstance``1(``0,Microsoft.Practices.Unity.LifetimeManager)">
      <summary>
            RegisterType an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
        <para>
            This overload does a default registration (name = null).
            </para>
      </remarks>
      <typeparam name="TInterface">Type of instance to register (may be an implemented interface instead of the full type).</typeparam>
      <param name="instance">Object to returned.</param>
      <param name="lifetimeManager">
        <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> object that controls how this instance will be managed by the container.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterInstance``1(System.String,``0)">
      <summary>
            RegisterType an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
        <para>
            This overload automatically has the container take ownership of the <paramref name="instance" />.</para>
      </remarks>
      <typeparam name="TInterface">Type of instance to register (may be an implemented interface instead of the full type).</typeparam>
      <param name="instance">Object to returned.</param>
      <param name="name">Name for registration.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterInstance``1(System.String,``0,Microsoft.Practices.Unity.LifetimeManager)">
      <summary>
            RegisterType an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
      </remarks>
      <typeparam name="TInterface">Type of instance to register (may be an implemented interface instead of the full type).</typeparam>
      <param name="instance">Object to returned.</param>
      <param name="name">Name for registration.</param>
      <param name="lifetimeManager">
        <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> object that controls how this instance will be managed by the container.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterInstance(System.Type,System.Object)">
      <summary>
            RegisterType an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
        <para>
            This overload does a default registration and has the container take over the lifetime of the instance.</para>
      </remarks>
      <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
      <param name="instance">Object to returned.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterInstance(System.Type,System.Object,Microsoft.Practices.Unity.LifetimeManager)">
      <summary>
            RegisterType an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
        <para>
            This overload does a default registration (name = null).
            </para>
      </remarks>
      <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
      <param name="instance">Object to returned.</param>
      <param name="lifetimeManager">
        <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> object that controls how this instance will be managed by the container.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterInstance(System.Type,System.String,System.Object)">
      <summary>
            RegisterType an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
        <para>
            This overload automatically has the container take ownership of the <paramref name="instance" />.</para>
      </remarks>
      <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
      <param name="instance">Object to returned.</param>
      <param name="name">Name for registration.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterInstance(System.Type,System.String,System.Object,Microsoft.Practices.Unity.LifetimeManager)">
      <summary>
            RegisterType an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
      </remarks>
      <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
      <param name="instance">Object to returned.</param>
      <param name="name">Name for registration.</param>
      <param name="lifetime">
        <para>If true, the container will take over the lifetime of the instance,
            calling Dispose on it (if it's <see cref="T:System.IDisposable" />) when the container is Disposed.</para>
        <para>
             If false, container will not maintain a strong reference to <paramref name="instance" />. User is reponsible
            for disposing instance, and for keeping the instance from being garbage collected.</para>
      </param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Resolve``1">
      <summary>
            Get an instance of the default requested type from the container.
            </summary>
      <typeparam name="T">
        <see cref="T:System.Type" /> of object to get from the container.</typeparam>
      <returns>The retrieved object.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Resolve``1(System.String)">
      <summary>
            Get an instance of the requested type with the given name from the container.
            </summary>
      <typeparam name="T">
        <see cref="T:System.Type" /> of object to get from the container.</typeparam>
      <param name="name">Name of the object to retrieve.</param>
      <returns>The retrieved object.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Resolve(System.Type)">
      <summary>
            Get an instance of the default requested type from the container.
            </summary>
      <param name="t">
        <see cref="T:System.Type" /> of object to get from the container.</param>
      <returns>The retrieved object.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Resolve(System.Type,System.String)">
      <summary>
            Get an instance of the requested type with the given name from the container.
            </summary>
      <param name="t">
        <see cref="T:System.Type" /> of object to get from the container.</param>
      <param name="name">Name of the object to retrieve.</param>
      <returns>The retrieved object.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.ResolveAll``1">
      <summary>
            Return instances of all registered types requested.
            </summary>
      <remarks>
        <para>
            This method is useful if you've registered multiple types with the same
            <see cref="T:System.Type" /> but different names.
            </para>
        <para>
            Be aware that this method does NOT return an instance for the default (unnamed) registration.
            </para>
      </remarks>
      <typeparam name="T">The type requested.</typeparam>
      <returns>Set of objects of type <typeparamref name="T" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.ResolveAll(System.Type)">
      <summary>
            Return instances of all registered types requested.
            </summary>
      <remarks>
        <para>
            This method is useful if you've registered multiple types with the same
            <see cref="T:System.Type" /> but different names.
            </para>
        <para>
            Be aware that this method does NOT return an instance for the default (unnamed) registration.
            </para>
      </remarks>
      <param name="t">The type requested.</param>
      <returns>Set of objects of type <paramref name="t" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.BuildUp``1(``0)">
      <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
      <remarks>
        <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para>
        <para>
            This overload uses the default registrations.
            </para>
      </remarks>
      <typeparam name="T">
        <see cref="T:System.Type" /> of object to perform injection on.</typeparam>
      <param name="existing">Instance to build up.</param>
      <returns>The resulting object. By default, this will be <paramref name="existing" />, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <typeparamref name="T" />).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.BuildUp``1(``0,System.String)">
      <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
      <remarks>
        <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para>
      </remarks>
      <typeparam name="T">
        <see cref="T:System.Type" /> of object to perform injection on.</typeparam>
      <param name="existing">Instance to build up.</param>
      <param name="name">name to use when looking up the typemappings and other configurations.</param>
      <returns>The resulting object. By default, this will be <paramref name="existing" />, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <typeparamref name="T" />).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.BuildUp(System.Type,System.Object)">
      <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
      <remarks>
        <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para>
        <para>
            This overload uses the default registrations.
            </para>
      </remarks>
      <param name="t">
        <see cref="T:System.Type" /> of object to perform injection on.</param>
      <param name="existing">Instance to build up.</param>
      <returns>The resulting object. By default, this will be <paramref name="existing" />, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <paramref name="t" />).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.BuildUp(System.Type,System.Object,System.String)">
      <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
      <remarks>
        <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para>
      </remarks>
      <param name="t">
        <see cref="T:System.Type" /> of object to perform injection on.</param>
      <param name="existing">Instance to build up.</param>
      <param name="name">name to use when looking up the typemappings and other configurations.</param>
      <returns>The resulting object. By default, this will be <paramref name="existing" />, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <paramref name="t" />).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Teardown(System.Object)">
      <summary>
            Run an existing object through the container, and clean it up.
            </summary>
      <param name="o">The object to tear down.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.AddExtension(Microsoft.Practices.Unity.UnityContainerExtension)">
      <summary>
            Add an extension object to the container.
            </summary>
      <param name="extension">
        <see cref="T:Microsoft.Practices.Unity.UnityContainerExtension" /> to add.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.AddNewExtension``1">
      <summary>
            Creates a new extension object and adds it to the container.
            </summary>
      <typeparam name="TExtension">Type of <see cref="T:Microsoft.Practices.Unity.UnityContainerExtension" /> to add. The extension type
            must have a zero-argument public constructor.</typeparam>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Configure``1">
      <summary>
            Get access to a configuration interface exposed by an extension.
            </summary>
      <remarks>Extensions can expose configuration interfaces as well as adding
            strategies and policies to the container. This method walks the list of
            added extensions and returns the first one that implements the requested type.
            </remarks>
      <typeparam name="TConfigurator">The configuration interface required.</typeparam>
      <returns>The requested extension's configuration interface, or null if not found.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Configure(System.Type)">
      <summary>
            Get access to a configuration interface exposed by an extension.
            </summary>
      <remarks>Extensions can expose configuration interfaces as well as adding
            strategies and policies to the container. This method walks the list of
            added extensions and returns the first one that implements the requested type.
            </remarks>
      <param name="configurationInterface">
        <see cref="T:System.Type" /> of configuration interface required.</param>
      <returns>The requested extension's configuration interface, or null if not found.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RemoveAllExtensions">
      <summary>
            Remove all installed extensions from this container.
            </summary>
      <remarks>
        <para>
            This method removes all extensions from the container, including the default ones
            that implement the out-of-the-box behavior. After this method, if you want to use
            the container again you will need to either readd the default extensions or replace
            them with your own.
            </para>
        <para>
            The registered instances and singletons that have already been set up in this container
            do not get removed.
            </para>
      </remarks>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.CreateChildContainer">
      <summary>
            Create a child container.
            </summary>
      <remarks>
            A child container shares the parent's configuration, but can be configured with different
            settings or lifetime.</remarks>
      <returns>The new child container.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Dispose">
      <summary>
            Dispose this container instance.
            </summary>
      <remarks>
            Disposing the container also disposes any child containers,
            and disposes any instances whose lifetimes are managed
            by the container.
            </remarks>
    </member>
    <member name="P:Microsoft.Practices.Unity.UnityContainerBase.Parent">
      <summary>
            The parent of this container.
            </summary>
      <value>The parent container, or null if this container doesn't have one.</value>
    </member>
    <member name="T:Microsoft.Practices.Unity.Utility.Guard">
      <summary>
            A static helper class that includes various parameter checking routines.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.Utility.Guard.ArgumentNotNull(System.Object,System.String)">
      <summary>
            Throws <see cref="T:System.ArgumentNullException" /> if the given argument is null.
            </summary>
      <exception cref="T:System.ArgumentNullException"> if tested value if null.</exception>
      <param name="argumentValue">Argument value to test.</param>
      <param name="argumentName">Name of the argument being tested.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.Utility.Guard.ArgumentNotNullOrEmpty(System.String,System.String)">
      <summary>
            Throws an exception if the tested string argument is null or the empty string.
            </summary>
      <exception cref="T:System.ArgumentNullException">Thrown if string value is null.</exception>
      <exception cref="T:System.ArgumentException">Thrown if the string is empty</exception>
      <param name="argumentValue">Argument value to check.</param>
      <param name="argumentName">Name of argument being checked.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.Utility.Guard.TypeIsAssignable(System.Type,System.Type,System.String)">
      <summary>
            Verifies that an argument type is assignable from the provided type (meaning
            interfaces are implemented, or classes exist in the base class hierarchy).
            </summary>
      <param name="assignmentTargetType">The argument type that will be assigned to.</param>
      <param name="assignmentValueType">The type of the value being assigned.</param>
      <param name="argumentName">Argument name.</param>
    </member>
    <member name="T:Microsoft.Practices.Unity.ObjectBuilder.UnityBuildStage">
      <summary>
            The build stages we use in the Unity container
            strategy pipeline.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Unity.ObjectBuilder.UnityBuildStage.Setup">
      <summary>
            First stage. By default, nothing happens here.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Unity.ObjectBuilder.UnityBuildStage.TypeMapping">
      <summary>
            Second stage. Type mapping occurs here.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Unity.ObjectBuilder.UnityBuildStage.Lifetime">
      <summary>
            Third stage. lifetime managers are checked here,
            and if they're available the rest of the pipeline is skipped.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Unity.ObjectBuilder.UnityBuildStage.PreCreation">
      <summary>
            Fourth stage. Reflection over constructors, properties, etc. is
            performed here.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Unity.ObjectBuilder.UnityBuildStage.Creation">
      <summary>
            Fifth stage. Instance creation happens here.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Unity.ObjectBuilder.UnityBuildStage.Initialization">
      <summary>
            Sixth stage. Property sets and method injection happens here.
            </summary>
    </member>
    <member name="F:Microsoft.Practices.Unity.ObjectBuilder.UnityBuildStage.PostInitialization">
      <summary>
            Seventh and final stage. By default, nothing happens here.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.Properties.Resources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Properties.Resources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Properties.Resources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Properties.Resources.ArgumentMustNotBeEmpty">
      <summary>
              Looks up a localized string similar to The provided string argument must not be empty..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Properties.Resources.CannotInjectGenericMethod">
      <summary>
              Looks up a localized string similar to The method {0}.{1}({2}) is an open generic method. Open generic methods cannot be injected..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Properties.Resources.CannotInjectIndexer">
      <summary>
              Looks up a localized string similar to The property {0} on type {1} is an indexer. Indexed properties cannot be injected..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Properties.Resources.CannotInjectMethodWithOutParams">
      <summary>
              Looks up a localized string similar to The method {0}.{1}({2}) has at least one out parameter. Methods with out parameters cannot be injected..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Properties.Resources.CannotInjectMethodWithRefParams">
      <summary>
              Looks up a localized string similar to The method {0}.{1}({2}) has at least one ref parameter.Methods with ref parameters cannot be injected..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Properties.Resources.CannotInjectStaticMethod">
      <summary>
              Looks up a localized string similar to The method {0}.{1}({2}) is static. Static methods cannot be injected..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Properties.Resources.LifetimeManagerInUse">
      <summary>
              Looks up a localized string similar to The lifetime manager is already registered. Lifetime managers cannot be reused, please create a new one..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Properties.Resources.NoMatchingGenericArgument">
      <summary>
              Looks up a localized string similar to The type {0} does not have a generic argument named "{1}".
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Properties.Resources.NoSuchConstructor">
      <summary>
              Looks up a localized string similar to The type {0} does not have a constructor that takes the parameters ({1})..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Properties.Resources.NoSuchMethod">
      <summary>
              Looks up a localized string similar to The type {0} does not have a public method named {1} that takes the parameters ({2})..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Properties.Resources.NoSuchProperty">
      <summary>
              Looks up a localized string similar to The type {0} does not contain a property named {1}..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Properties.Resources.NotAGenericType">
      <summary>
              Looks up a localized string similar to The type {0} is not a generic type, and you are attempting to inject a generic parameter named "{1}"..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Properties.Resources.NotAnArrayTypeWithRankOne">
      <summary>
              Looks up a localized string similar to The type {0} is not an array type with rank 1, and you are attempting to use a [DependencyArray] attribute on a parameter or property with this type..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Properties.Resources.PropertyNotSettable">
      <summary>
              Looks up a localized string similar to The property {0} on type {1} is not settable..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Properties.Resources.PropertyTypeMismatch">
      <summary>
              Looks up a localized string similar to The property {0} on type {1} is of type {2}, and cannot be injected with a value of type {3}..
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Properties.Resources.ResolutionFailed">
      <summary>
              Looks up a localized string similar to Resolution of the dependency failed, type = "{0}", name = "{1}". Exception message is: {2}.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Properties.Resources.TypesAreNotAssignable">
      <summary>
              Looks up a localized string similar to The type {1} cannot be assigned to variables of type {0}..
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.UnityContainer">
      <summary>
            A simple, extensible dependency injection container.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.UnityContainer.ExtensionContextImpl">
      <summary>
            Implementation of the ExtensionContext that is actually used
            by the UnityContainer implementation.
            </summary>
      <remarks>
            This is a nested class so that it can access state in the
            container that would otherwise be inaccessible.
            </remarks>
    </member>
    <member name="E:Microsoft.Practices.Unity.UnityContainer.ExtensionContextImpl.RegisteringInstance">
      <summary>
            This event is raised when the <see cref="M:Microsoft.Practices.Unity.UnityContainer.RegisterInstance(System.Type,System.String,System.Object,Microsoft.Practices.Unity.LifetimeManager)" /> method,
            or one of its overloads, is called.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.#ctor">
      <summary>
            Create a default <see cref="T:Microsoft.Practices.Unity.UnityContainer" />.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.#ctor(Microsoft.Practices.Unity.UnityContainer)">
      <summary>
            Create a <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> with the given parent container.
            </summary>
      <param name="parent">The parent <see cref="T:Microsoft.Practices.Unity.UnityContainer" />. The current object
            will apply its own settings first, and then check the parent for additional ones.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.RegisterType(System.Type,System.Type,System.String,Microsoft.Practices.Unity.LifetimeManager,Microsoft.Practices.Unity.InjectionMember[])">
      <summary>
            RegisterType a type mapping with the container, where the created instances will use
            the given <see cref="T:Microsoft.Practices.Unity.LifetimeManager" />.
            </summary>
      <param name="from">
        <see cref="T:System.Type" /> that will be requested.</param>
      <param name="to">
        <see cref="T:System.Type" /> that will actually be returned.</param>
      <param name="name">Name to use for registration, null if a default registration.</param>
      <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager" /> that controls the lifetime
            of the returned instance.</param>
      <param name="injectionMembers">Injection configuration objects.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.RegisterInstance(System.Type,System.String,System.Object,Microsoft.Practices.Unity.LifetimeManager)">
      <summary>
            RegisterType an instance with the container.
            </summary>
      <remarks>
        <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
      </remarks>
      <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
      <param name="instance">Object to returned.</param>
      <param name="name">Name for registration.</param>
      <param name="lifetime">
        <para>If true, the container will take over the lifetime of the instance,
            calling Dispose on it (if it's <see cref="T:System.IDisposable" />) when the container is Disposed.</para>
        <para>
             If false, container will not maintain a strong reference to <paramref name="instance" />. User is reponsible
            for disposing instance, and for keeping the instance from being garbage collected.</para>
      </param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.Resolve(System.Type,System.String)">
      <summary>
            Get an instance of the requested type with the given name from the container.
            </summary>
      <param name="t">
        <see cref="T:System.Type" /> of object to get from the container.</param>
      <param name="name">Name of the object to retrieve.</param>
      <returns>The retrieved object.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.ResolveAll(System.Type)">
      <summary>
            Return instances of all registered types requested.
            </summary>
      <remarks>
        <para>
            This method is useful if you've registered multiple types with the same
            <see cref="T:System.Type" /> but different names.
            </para>
        <para>
            Be aware that this method does NOT return an instance for the default (unnamed) registration.
            </para>
      </remarks>
      <param name="t">The type requested.</param>
      <returns>Set of objects of type <paramref name="t" />.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.BuildUp(System.Type,System.Object,System.String)">
      <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
      <remarks>
        <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para>
      </remarks>
      <param name="t">
        <see cref="T:System.Type" /> of object to perform injection on.</param>
      <param name="existing">Instance to build up.</param>
      <param name="name">name to use when looking up the typemappings and other configurations.</param>
      <returns>The resulting object. By default, this will be <paramref name="existing" />, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <paramref name="t" />).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.Teardown(System.Object)">
      <summary>
            Run an existing object through the container, and clean it up.
            </summary>
      <param name="o">The object to tear down.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.AddExtension(Microsoft.Practices.Unity.UnityContainerExtension)">
      <summary>
            Add an extension object to the container.
            </summary>
      <param name="extension">
        <see cref="T:Microsoft.Practices.Unity.UnityContainerExtension" /> to add.</param>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.Configure(System.Type)">
      <summary>
            Get access to a configuration interface exposed by an extension.
            </summary>
      <remarks>Extensions can expose configuration interfaces as well as adding
            strategies and policies to the container. This method walks the list of
            added extensions and returns the first one that implements the requested type.
            </remarks>
      <param name="configurationInterface">
        <see cref="T:System.Type" /> of configuration interface required.</param>
      <returns>The requested extension's configuration interface, or null if not found.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.RemoveAllExtensions">
      <summary>
            Remove all installed extensions from this container.
            </summary>
      <remarks>
        <para>
            This method removes all extensions from the container, including the default ones
            that implement the out-of-the-box behavior. After this method, if you want to use
            the container again you will need to either readd the default extensions or replace
            them with your own.
            </para>
        <para>
            The registered instances and singletons that have already been set up in this container
            do not get removed.
            </para>
      </remarks>
      <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer" /> object that this method was called on (this in C#, Me in Visual Basic).</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.CreateChildContainer">
      <summary>
            Create a child container.
            </summary>
      <remarks>
            A child container shares the parent's configuration, but can be configured with different
            settings or lifetime.</remarks>
      <returns>The new child container.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.Dispose">
      <summary>
            Dispose this container instance.
            </summary>
      <remarks>
            Disposing the container also disposes any child containers,
            and disposes any instances whose lifetimes are managed
            by the container.
            </remarks>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityContainer.Dispose(System.Boolean)">
      <summary>
            Dispose this container instance.
            </summary>
      <remarks>
            This class doesn't have a finalizer, so <paramref name="disposing" /> will always be true.</remarks>
      <param name="disposing">True if being called from the IDisposable.Dispose
            method, false if being called from a finalizer.</param>
    </member>
    <member name="P:Microsoft.Practices.Unity.UnityContainer.Parent">
      <summary>
            The parent of this container.
            </summary>
      <value>The parent container, or null if this container doesn't have one.</value>
    </member>
    <member name="T:Microsoft.Practices.Unity.UnityDefaultBehaviorExtension">
      <summary>
            This extension supplies the default behavior of the UnityContainer API
            by handling the context events and setting policies.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityDefaultBehaviorExtension.Initialize">
      <summary>
            Install the default container behavior into the container.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.UnityDefaultBehaviorExtension.Remove">
      <summary>
            Remove the default behavior from the container.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.Utility.MethodReflectionHelper">
      <summary>
            Helper class to wrap common reflection stuff dealing with
            methods.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.Utility.MethodReflectionHelper.#ctor(System.Reflection.MethodBase)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.Utility.MethodReflectionHelper" /> instance that
            lets us do more reflection stuff on that method.
            </summary>
      <param name="method">
      </param>
    </member>
    <member name="M:Microsoft.Practices.Unity.Utility.MethodReflectionHelper.GetClosedParameterTypes(System.Type[])">
      <summary>
            Given our set of generic type arguments, 
            </summary>
      <param name="genericTypeArguments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Microsoft.Practices.Unity.Utility.MethodReflectionHelper.MethodHasOpenGenericParameters">
      <summary>
            Returns true if any of the parameters of this method
            are open generics.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Utility.MethodReflectionHelper.ParameterTypes">
      <summary>
            Return the <see cref="T:System.Type" /> of each parameter for this
            method.
            </summary>
      <returns>Sequence of <see cref="T:System.Type" /> objects, one for
            each parameter in order.</returns>
    </member>
    <member name="T:Microsoft.Practices.Unity.Utility.Pair`2">
      <summary>
            A helper class that encapsulates two different
            data items together into a a single item.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.Utility.Pair`2.#ctor(`0,`1)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.Utility.Pair`2" /> containing
            the two values give.
            </summary>
      <param name="first">First value</param>
      <param name="second">Second value</param>
    </member>
    <member name="P:Microsoft.Practices.Unity.Utility.Pair`2.First">
      <summary>
            The first value of the pair.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Utility.Pair`2.Second">
      <summary>
            The second value of the pair.
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.Utility.Pair">
      <summary>
            Container for a Pair helper method.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.Utility.Pair.Make``2(``0,``1)">
      <summary>
            A helper factory method that lets users take advantage of type inference.
            </summary>
      <typeparam name="TFirstParam">Type of first value.</typeparam>
      <typeparam name="TSecondParam">Type of second value.</typeparam>
      <param name="first">First value.</param>
      <param name="second">Second value.</param>
      <returns>A new <see cref="T:Microsoft.Practices.Unity.Utility.Pair`2" /> instance.</returns>
    </member>
    <member name="T:Microsoft.Practices.Unity.Utility.ParameterMatcher">
      <summary>
            A utility class that handles the logic of matching parameter
            lists, so we can find the right constructor and method overloads.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.Utility.ParameterMatcher.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Practices.Unity.InjectionParameterValue})">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.Utility.ParameterMatcher" /> that will attempt to
            match the given parameter types.
            </summary>
      <param name="parametersToMatch">Target parameters to match against.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.Utility.ParameterMatcher.Matches(System.Collections.Generic.IEnumerable{System.Type})">
      <summary>
            Tests to see if the given set of types matches the ones
            we're looking for.
            </summary>
      <param name="candidate">parameter list to look for.</param>
      <returns>true if they match, false if they don't.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.Utility.ParameterMatcher.Matches(System.Collections.Generic.IEnumerable{System.Reflection.ParameterInfo})">
      <summary>
            Tests to see if the given set of types matches the ones we're looking for.
            </summary>
      <param name="candidate">Candidate method signature to look for.</param>
      <returns>True if they match, false if they don't.</returns>
    </member>
    <member name="T:Microsoft.Practices.Unity.Utility.ReflectionHelper">
      <summary>
            A small helper class to encapsulate details of the
            reflection API, particularly around generics.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.Utility.ReflectionHelper.#ctor(System.Type)">
      <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.Utility.ReflectionHelper" /> instance that
            lets you look at information about the given type.
            </summary>
      <param name="typeToReflect">Type to do reflection on.</param>
    </member>
    <member name="M:Microsoft.Practices.Unity.Utility.ReflectionHelper.MethodHasOpenGenericParameters(System.Reflection.MethodBase)">
      <summary>
            Test the given <see cref="T:System.Reflection.MethodBase" /> object, looking at
            the parameters. Determine if any of the parameters are
            open generic types that need type attributes filled in.
            </summary>
      <param name="method">The method to check.</param>
      <returns>True if any of the parameters are open generics. False if not.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.Utility.ReflectionHelper.GetClosedParameterType(System.Type[])">
      <summary>
            If this type is an open generic, use the
            given <paramref name="genericArguments" /> array to
            determine what the required closed type is and return that.
            </summary>
      <remarks>If the parameter is not an open type, just
            return this parameter's type.</remarks>
      <param name="genericArguments">Type arguments to substitute in for
            the open type parameters.</param>
      <returns>Corresponding closed type of this parameter.</returns>
    </member>
    <member name="M:Microsoft.Practices.Unity.Utility.ReflectionHelper.GetNamedGenericParameter(System.String)">
      <summary>
            Given a generic argument name, return the corresponding type for this
            closed type. For example, if the current type is Foo&lt;User&gt;, and the
            corresponding definition was Foo&lt;TSomething&gt;, calling this method
            and passing "TSomething" will return typeof(User).
            </summary>
      <param name="parameterName">Name of the generic parameter.</param>
      <returns>Type of the corresponding generic parameter, or null if there
            is no matching name.</returns>
    </member>
    <member name="P:Microsoft.Practices.Unity.Utility.ReflectionHelper.Type">
      <summary>
            The <see cref="P:Microsoft.Practices.Unity.Utility.ReflectionHelper.Type" /> object we're reflecting over.
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Utility.ReflectionHelper.IsGenericType">
      <summary>
            Is this type generic?
            </summary>
    </member>
    <member name="P:Microsoft.Practices.Unity.Utility.ReflectionHelper.IsOpenGeneric">
      <summary>
            Is this type an open generic (no type parameter specified)
            </summary>
    </member>
    <member name="T:Microsoft.Practices.Unity.Utility.ParameterReflectionHelper">
      <summary>
            Another reflection helper class that has extra methods
            for dealing with ParameterInfos.
            </summary>
    </member>
    <member name="M:Microsoft.Practices.Unity.Utility.ParameterReflectionHelper.#ctor(System.Reflection.ParameterInfo)">
      <summary>
            Create a new instance of <see cref="T:Microsoft.Practices.Unity.Utility.ParameterReflectionHelper" /> that
            lets you query information about the given ParameterInfo object.
            </summary>
      <param name="parameter">Parameter to query.</param>
    </member>
  </members>
</doc>